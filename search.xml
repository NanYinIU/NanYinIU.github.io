<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F12%2FSpringBoot%E5%90%AF%E5%8A%A8%E4%B9%8BrefreshContext%2F</url>
    <content type="text"><![CDATA[title: “SpringBoot启动之refreshContext”date: 2019-08-12 12:00:00copyright: turetags: Java SpringBootcategories: SpringBoot SpringBoot启动之refreshContext这篇主要要通过refreshContext方法来将SpringBoot是如何初始化ioc容器的。 refreshContext在SpringBoot中的run方法中，调用refreshContext()方法，进而调用 AbstractApplicationContext类中的refresh()方法。然后分析每个方法的代码，来看这些方法的作用。 12345678910111213141516171819202122232425262728293031323334@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 准备此上下文以进行刷新，设置其启动日期 // 并且设置 active 标志以及执行属性源（系统属性、环境变量）的任何初始化。 prepareRefresh(); // 告诉子类刷新 bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 为上下文准备 bean factory. prepareBeanFactory(beanFactory); // 接下来的方法就是装载组件的方法 try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // 使用beanFactory在上下文中注册bean invokeBeanFactoryPostProcessors(beanFactory); // 注册bean的拦截器 registerBeanPostProcessors(beanFactory); // 加载国际化 initMessageSource(); // 初始化上下文的事件广播 initApplicationEventMulticaster(); // 加载特殊的bean onRefresh(); // 加载所有的listeners并启动 registerListeners(); // 完成对所有的剩下的非懒加载的单例的创建 finishBeanFactoryInitialization(beanFactory); // 最后发布对应的事件。 finishRefresh(); &#125; &#125;&#125; prepareRefresh 准备刷新方法这个方法的作用就是为了接下来的refresh进行的准备。主要的有两个过程 调用initPropertySources()方法进行propertySource的初始化。 验证有没有缺失的必要的Property属性。 initPropertySources 初始化propertySource调用实现类的initPropertySources，根据debug的结果，进入到了子类GenericWebApplication类中，对servletContex进行属性设置。如下图中所展示的。 ![IMAGE](resources/35A360D4D16F0FE32C4F18C184FB074D.jpg =1200x435) obtainFreshBeanFactory 获得beanFactory该方法依靠refreshBeanFactory()来只是bean工厂的实际刷新。因为SpringBoot在ApplicationContext已经持有一个类型为DefaultListableBeanFactory类型的beanFactory。所以可以直接返回。 prepareBeanFactory准备BeanFactory配置BeanFactory的标准上下文特征。主要体现在一下几个方面： 设置classLoader和bean名称的解析策略等。 设置以Aware结尾的callback接口函数。通过对这些接口的实现。来达到对环境设置的目的。如可继承ResourceLoaderAware接口，来设置资源加载器，来实现自定义的资源加载。 使用特定的自动装配值注册特殊依赖关系类型。如beanFactory.registerResolvableDependency(ApplicationContext.class, this); 设置环境相关的bean.如beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); postProcessBeanFactory允许在上下文子类中对bean进行后处理。调用相关方法完成对beanFactory的后置处理其的加载。在之后的invokeBeanFactoryPostProcessors实例化并调用所有已注册的BeanFactoryPostProcessor bean。在方法registerBeanPostProcessors中实例化并注册所有BeanPostProcessor bean。 initMessageSource 初始化MessageSource1234567891011121314151617181920protected void initMessageSource() &#123; // 先获得bean工厂 ConfigurableListableBeanFactory beanFactory = getBeanFactory(); // 如果存在bean名称为messageSource的bean // 也就是国际化的Message if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123; // 获得messageSource this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); // Make MessageSource aware of parent MessageSource. if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123; HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource; if (hms.getParentMessageSource() == null) &#123; // Only set parent context as parent MessageSource if no parent MessageSource // registered already. hms.setParentMessageSource(getInternalParentMessageSource()); &#125; &#125; //。。。这里省略 &#125;&#125; 在debug时的结果，因为SpringBoot默认实现类Message，所以容器会加载SpringBoot配置好的国际化配置文件。如图中的basenameSet;![IMAGE](resources/7517F683FBB61095E8482415D2C4E673.jpg =1189x338) onRefresh在这一步，SpringBoot会根据应用类型来判断，如果是web应用，则会启动默认的web容器，如tomcat。它回去找所有的类型为ServletWebServerFactory的类。然后获取第一个getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);进行bean注入。这样通过注入的bean就能够启动web容器了。 ![IMAGE](resources/74F314A51E513D3A08C7F54609854583.jpg =1311x170) SpringBoot中默认实现有以上几种。 registerListeners 注册listeners在这一步，注册类型为ApplicationListener的所有listeners; finishBeanFactoryInitialization 完成所有非懒加载的bean的初始化finishRefresh 完成刷新这步有以下几个操作。 clearResourceCaches方法。 清空context-level的缓存。 initLifecycleProcessor方法，用来设置生命周期processer 发布最后的事件（ContextRefreshedEvent） 以上就完成了refresh方法中的所有操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot启动原理]]></title>
    <url>%2F2019%2F08%2F05%2FSpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SpringBoot的启动原理创建启动器SpringBoot通过调用主程序启动应用环境。下面代码为应用启动器的基本代码。 启动器123456789101112// 标注这是SpringBoot应用@SpringBootApplication// 开启cache@EnableCachingpublic class WebProjectApplication &#123; public static void main(String[] args) &#123; // fastJson不使用循环引用 （$ref） JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.DisableCircularReferenceDetect.getMask(); // 使用SpringApplication启动应用 SpringApplication.run(WebProjectApplication.class); &#125;&#125; 进入SpringApplication.run方法之后，发现程序会调用new SpringApplication 来创建应用。 123public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args)&#123; return new SpringApplication(primarySources).run(args);&#125; 在new SpringApplication创建实例的过程中，应用容器会从加载一些主类。比如代码中所写的： 初始化SpringApplication123456789101112131415public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; // 这里的 primarySources 就是 上面的 WebProjectApplication this.resourceLoader = resourceLoader; Assert.notNull(primarySources, "PrimarySources must not be null"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // 根据classpath 来判断应当启动什么样的应用程序？ 1. 非web 2.web并使用内容selvlet容器 // 3. web 但不实用内置web容器 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 设置 Initializer setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 设置 Listener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //判断主运行程序是哪个，比如有多个主程序，到底使用哪个。 this.mainApplicationClass = deduceMainApplicationClass();&#125; 在创建的过程中，在setInitializers和setListeners的过程是类似的。主要方法就是从META-INF/spring.factories中加载特定的key值下的value。 12345678910private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; ClassLoader classLoader = getClassLoader(); // 使用set加载所有的全类名 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 根据类名通过反射创建实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); // 返回实例 return instances;&#125; 上面分析了getSpringFactoriesInstances这个方法是如何获取实例的，其中获取的途径就是使用SpringFactoriesLoader.loadFactoryNames获取全类名，然后通过反射进行创建实例。 12345678910111213141516public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // 获取传递进来的 类名 String factoryClassName = factoryClass.getName(); // 如果不存在就返回一个空的list，如果不为空则返回一个全类名的一个list // 这个list是从下面是方法中的result中直接获取value return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;// 节选一段代码来看loadSpringFactories 方法是如何实现的private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; // 从路径上获取resource 这个路径正是 META-INF/spring.factories 加载所有的 // 这个路径下的url 组成一个result Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) &#123; // 循环 上面的一系列方法只是为给SpringApplication进行初始化的相关操作，下一步，调用SpringApplication.run正式运行容器. 启动器启动在新建完SpringApplication后，使用run方法正式启动容器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950new SpringApplication(primarySources).run(args); // 这个run方法直接调用的是以下代码public ConfigurableApplicationContext run(String... args) &#123; // 创建一个跑表 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; // arrayList类型的Exception Reporters Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 配置headless configureHeadlessProperty(); // 获取所有的listeners SpringApplicationRunListeners listeners = getRunListeners(args); // 启动listeners listeners.starting(); try &#123; // 封装命令行args ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //通过设置spring.beaninfo.ignore来忽略bean设置 configureIgnoreBeanInfo(environment); // 打印Spring标记 Banner printedBanner = printBanner(environment); // 策略创建指定的applicationContext context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 刷新上下文，创建ioc refreshContext(context); // 在上下文刷新之后调用 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; // 完成监听器的启动 listeners.started(context); // 调用callRunners callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); getRunListeners方法与启动Listeners获得所有的listeners，然后调用 listeners.starting();运行监听器。 在这个方法中,使用到了getSpringFactoriesInstances方法，上面说到，这个方法实际上就是从spring.factory中获取所有的key为特定值的类。在getRunListeners方法里就是获取所有的key为SpringApplicationRunListener的所有value。参考下图中内容： 12345private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125; 经过上面的步骤，就可以获取到所有的RunListeners。使用starting方法来批量的开启listener。其内部实现如下面的代码。是使用for循环将所有加载到的listeners启动。 12345public void starting() &#123; for (SpringApplicationRunListener listener : this.listeners) &#123; listener.starting(); &#125;&#125; prepareEnvironment 准备环境12345678910111213141516171819private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // 获得配置环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); // 配置环境 configureEnvironment(environment, applicationArguments.getSourceArgs()); // 在环境准备好后立即调用监听器的environmentPrepared方法 // 需要在SpringApplication创建之前执行 listeners.environmentPrepared(environment); // 绑定到SpringApplication bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; //将ConfigurationPropertySources支持指定的环境。 ConfigurationPropertySources.attach(environment); return environment;&#125; 在配置环境的过程中，需要配置properties属性和profile。 12345678910protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123; // 如果需要进行在properties属性上的类型转换 if (this.addConversionService) &#123; ConversionService conversionService = ApplicationConversionService.getSharedInstance(); environment.setConversionService((ConfigurableConversionService) conversionService); &#125; configurePropertySources(environment, args); // 配置profile，包括激活的配置文件等。 configureProfiles(environment, args);&#125; configureProfiles 配置profile12345678protected void configureProfiles(ConfigurableEnvironment environment, String[] args) &#123; //设置激活的profile，可以通过属性 spring.profiles.active来设置 environment.getActiveProfiles(); Set&lt;String&gt; profiles = new LinkedHashSet&lt;&gt;(this.additionalProfiles); profiles.addAll(Arrays.asList(environment.getActiveProfiles())); // 在环境中设置激活的profiles environment.setActiveProfiles(StringUtils.toStringArray(profiles));&#125; printBanner 打印标志printBanner方法用来打印运行程序时的标志，见下图 这个方法最后通过print方法来输出 1234567891011121314public Banner print(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123; // 获取banner Banner banner = getBanner(environment); banner.printBanner(environment, sourceClass, out); return new PrintedBanner(banner, sourceClass);&#125;// 默认是 DEFAULT_BANNERprivate static final String[] BANNER = &#123; "", " . ____ _ __ _ _", " /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\", "( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\", " \\\\/ ___)| |_)| | | | | || (_| | ) ) ) )", " ' |____| .__|_| |_|_| |_\\__, | / / / /", " =========|_|==============|___/=/_/_/_/" &#125;;private static final String SPRING_BOOT = " :: Spring Boot :: "; createApplicationContext 创建应用上下文环境createApplicationContext方法用来策略创建指定的applicationContext; 1234567891011121314151617181920212223242526272829protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; // 如果是servlet环境 case SERVLET: // 创建AnnotationConfigServletWebServerApplicationContext // 适用于默认的web环境 contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: // 创建AnnotationConfigReactiveWebServerApplicationContext // 适用于reactive web环境 contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: // 创建AnnotationConfigApplicationContext，非web环境 contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( "Unable create a default ApplicationContext, " + "please specify an ApplicationContextClass", ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; prepareContext 准备上下文12345678910111213141516171819202122private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; context.setEnvironment(environment); /** * 后置处理context * 1. 创建一个单例的beanNameGenerator * 2. 如果resourceLoader不为空，则设置resourceLoader和classLoader\ * 3. 设置用于属性值转换的ConversionService */ postProcessApplicationContext(context); // 通过在 初始化SpringApplication 这里设置的Initializers来对环境进行设置 applyInitializers(context); // 告诉监听器上下文准备好了 listeners.contextPrepared(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // ... 中间省略 // 再次调用监听器的事件，通知监听器上下文已经加载完成 listeners.contextLoaded(context);&#125; refreshContext 刷新上下文用于刷新上下文，刷新上下文的过程其实就是IOC容器初始化的过程(扫描、加载、创建所有的组件)。如果是web应用，还会自动启动嵌入式的tomcat.具体方法会单拿出来一篇来分析refresh的过程。 12345678910111213141516171819202122232425262728293031323334@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 准备此上下文以进行刷新，设置其启动日期 // 并且设置 active 标志以及执行属性源（系统属性、环境变量）的任何初始化。 prepareRefresh(); // 告诉子类刷新 bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 为上下文准备 bean factory. prepareBeanFactory(beanFactory); // 接下来的方法就是装载组件的方法 try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // 使用beanFactory在上下文中注册bean invokeBeanFactoryPostProcessors(beanFactory); // 注册bean的拦截器 registerBeanPostProcessors(beanFactory); // 加载国际化 initMessageSource(); // 初始化上下文的事件广播 initApplicationEventMulticaster(); // 加载特殊的bean onRefresh(); // 加载所有的listeners并启动 registerListeners(); // 完成对所有的剩下的非懒加载的单例的创建 finishBeanFactoryInitialization(beanFactory); // 最后发布对应的事件。 finishRefresh(); &#125; &#125;&#125; 调用callRunners启动过程图解使用一张简单的流程图将上面所有的主要方法串联起来，来查看SpringBoot的启动流程。 在整个启动流程的过程中又一个重要的组件就是listeners.它来监听应用运行的过程。在程序中的体现就是特定的节点调用listeners的回调方法。具体的调用listeners过程如下图所展示的： 结束这篇文章根据代码来分析SpringBoot的启动过程。分析的比较潦草，有些地方分析的不清晰或者分析出错的地方，欢迎指正，共同进步！。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的错误处理机制]]></title>
    <url>%2F2019%2F07%2F17%2F2019-07-17-SpringBoot%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在web开发中的异常错误处理SpringBoot默认有一套对web开发错误处理的机制，在autoConfiguration包下面找到了ErrorMvcAutoConfiguration。 12345678@Configuration// 只有基于servlet的web程序@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class &#125;)// 需要先加载WebMvcAutoConfiguration@AutoConfigureBefore(WebMvcAutoConfiguration.class)@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class, WebMvcProperties.class &#125;)public class ErrorMvcAutoConfiguration &#123; 处理机制在这个自动配置类中，由三个最基本的bean组件组成，下面挨个看这些注入到容器中的bean的含义 errorPageCustomizer 定义错误页面12345678910111213141516@Beanpublic ErrorPageCustomizer errorPageCustomizer() &#123; return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath);&#125;// 在ErrorPageCustomizer有一个registerErrorPages 注册页面的方法public void registerErrorPages(ErrorPageRegistry errorPageRegistry) &#123; ErrorPage errorPage = new ErrorPage( // 用于获取error页面的地址 this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())); errorPageRegistry.addErrorPages(errorPage); &#125;// 地址在 this.properties.getError().getPath()变量中具体的值： @Value("$&#123;error.path:/error&#125;")// 配置文件中error.path下的/error或者根目录下的/error文件夹 private String path = "/error"; 所以errorPageCustomizer的主要功能就是找到地址，拼装成ErrorPage; WhitelabelErrorViewConfiguration 空白页的配置123456789protected static class WhitelabelErrorViewConfiguration &#123; // 在StaticView中定义了默认的Whitelabel页面格式， private final StaticView defaultErrorView = new StaticView(); @Bean(name = "error") @ConditionalOnMissingBean(name = "error") public View defaultErrorView() &#123; return this.defaultErrorView; &#125; basicErrorController 控制器basicErrorController就是简单的控制器 12345@Controller //controller实现 注册到容器中// 错误映射地址 error.path 或// server.error.path 下 /error@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController 在这个Controller中映射到了/error地址上，有具有两个RequestMapping进行映射。 请求的媒体类型为text/html时12345678910111213@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)// 媒体类型为 text/html 时候使用这个对/error的接收public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; // 获得request中的状态码 // Integer statusCode = // (Integer) request.getAttribute("javax.servlet.error.status_code"); HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView("error", model);&#125; 其中使用夫类中的getErrorAttributes方法来获取基本属性数据，通过return this.errorAttributes.getErrorAttributes(webRequest, includeStackTrace)直接调用已经注入到容器中的ErrorAttributes类及其子类。如默认的DefaultErrorAttributes。 1234567891011121314@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;&gt;(); // 返回到页面的当前系统时间 errorAttributes.put("timestamp", new Date()); // 下面的 javax.xxxx 都是从requeset中得到的 // 返回状态码 javax.servlet.error.status_code addStatus(errorAttributes, webRequest); //错误信息 avax.servlet.error.message addErrorDetails(errorAttributes, webRequest, includeStackTrace); // 请求路径 javax.servlet.error.request_uri addPath(errorAttributes, webRequest); return errorAttributes;&#125; 在获取完需要返回的数据之后，返回一个modelAndView对象，也就是一个带有显示的界面。 默认使用DefaultErrorViewResolver来进行对ErrorView的解析。 12345678910@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; // 获取modelandview对象 ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; // 如果没有modelandview modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125; 如果没有通过resolve方法找到一个modelAndView。则会有类似通过 5xx.html 页面来展示5开头的那些错误的页面。可选值有下面两种： 123views.put(Series.CLIENT_ERROR, "4xx");views.put(Series.SERVER_ERROR, "5xx");SERIES_VIEWS = Collections.unmodifiableMap(views); 12345678910111213141516// 使用resolve方法来获取ModelAndViewprivate ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //这里的viewName为状态编码，视图为 error/「状态码值」 String errorViewName = "error/" + viewName; TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; // 如403错误，那么就会返回 error/403.html 前提是有模版引擎 return new ModelAndView(errorViewName, model); &#125; // 没有就去 &#123; "classpath:/META-INF/resources/", // "classpath:/resources/", "classpath:/static/", "classpath:/public/" &#125;; // 这几个路径上找 路径下的error/xxx.html，这些路径就是默认的资源文件路径 return resolveResource(errorViewName, model);&#125; 如果到上一步仍不存在view则说明，模版引擎/基本资源文件夹下均不存在error文件夹下的xxx.html文件，则会返回一个默认的view 。(modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);，就是在标题【WhitelabelErrorViewConfiguration】中提及到的StaticView。 请求为其他媒体类型1234567@RequestMappingpublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); // 直接返回map return new ResponseEntity&lt;&gt;(body, status);&#125; errorAttributes 错误页面属性信息12345@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException());&#125; 这个bean主要是使用getErrorAttributes提供ErrorController返回值的信息，如果状态码等。。如果想更改错误信息的返回值内容，可以继承DefaultErrorAttributes,然后在getErrorAttributes方法里添加想要添加的内容即可。 添加错误页面和修改返回信息下面具体来根据SpringBoot特性来添加错误页面，如404，500等。 ​ 因为在处理机制这章里说明了SpringBoot如何处理错误，他会默认的访问/error/地址，并且如果是text/html的媒体类型，也就是网页访问的话，如果有模版引擎，他会去找在/error文件中对应编码的xxx.html页面进而去渲染这个页面。 ​ 比如访问404，他会去找classpath:/error/404.html页面去渲染，如果没有，他会去找classpath:/error/4xx.html，如果还没有，他会返回一个页面。 添加error页面​ 为了演示，创建404.html和4xx.html，来达到这样的目的:如果发生404错误，则访问404.html页面，如果发生402或者以4开头的错误，则访问4xx.html页面。 目录结构和示例内容参考如下： 定义异常和对应的异常处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class NoAuthException extends RuntimeException &#123; public NoAuthException() &#123; super("无权限异常"); &#125;&#125;public class NoUserExcetion extends RuntimeException &#123; public NoUserExcetion() &#123; super("无用户异常"); &#125;&#125;// 异常处理类@ControllerAdvicepublic class MyExecptionHandler &#123; // 处理NoAuthException 异常 @ExceptionHandler(value = NoAuthException.class) public String handlerNoAuthException(HttpServletRequest request)&#123; // 这是必须的；定义返回的code值，返回指定的错误页面 request.setAttribute("javax.servlet.error.status_code",402); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code",402); map.put("message","this is my no auth message"); // 将自定义信息放入 request中 request.setAttribute("errData",map); return "forward:/error"; &#125; //处理NoUserExcetion 异常 @ExceptionHandler(value = NoUserExcetion.class) public String handlerNoUserException(HttpServletRequest request)&#123; request.setAttribute("javax.servlet.error.status_code",400); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code",404); map.put("message","this is my no auth message"); request.setAttribute("errData",map); return "forward:/error"; &#125;&#125;// controller类@RequestMapping("/hello")@ResponseBodypublic String hello(String name)&#123; if("abc".equals(name))&#123; // 如果是 /hello?name=abc的时候抛出NoAuthException异常 跳转到4xx页面 throw new NoAuthException(); &#125; if("123".equals(name))&#123; // 如果是 /hello?name=123的时候抛出NoUserExcetion的异常 跳转到404页面 throw new NoUserExcetion(); &#125; return "hello world";&#125; 定义自定义属性类12345678910111213@Component// 放到容器中，默认会替换到springboot的默认的DefaultErrorAttributespublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; // 获取DefaultErrorAttributes的基本属性 Map&lt;String,Object&gt; map = super.getErrorAttributes(webRequest,includeStackTrace); Map&lt;String,Object&gt; errData = (Map&lt;String, Object&gt;) webRequest.getAttribute("errData", 0); // 从request中获取自定义的data，添加到返回的信息中。 map.put("errData",errData); return map; &#125;&#125; 通过以上的设置，可以得到如下结果： 如果是 /hello?name=abc的时候抛出NoAuthException异常 跳转到4xx页面 如果是 /hello?name=123的时候抛出NoUserExcetion的异常 跳转到404页面 如果没有访问地址也会到404页面 测试结果 访问/hello?name=abc 跳转到4xx页面 访问/hello?name=123 跳转到404页面 结论在考虑对web错误页面处理的角度，无非就是两个方面： 一、 页面样式​ 在有模版引擎的情况下，通过DefaultErrorController在/error上的访问处理，来自动渲染在template/error/目录下的对应的错误code.html的的展示,如404.html。并且支持模糊匹配，如创建4xx.html页面，那么如果没有发现特定的错误代码页面，则自动的使用4xx页面。 二、 页面内容页面内容可以通过继承DefaultErrorAttributes类来进行简单的实现，如果想全部替换掉SpringBoot的默认全部的返回内容，则需要实现ErrorAttributes进行实现，需要注意的是必须放到容器中才能生效。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的WEB开发之国际化]]></title>
    <url>%2F2019%2F07%2F15%2FSpringBoot%E7%9A%84WEB%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[准备工作SpringBoot默认是支持Thymeleaf模版引擎的。相应的如果使用Thymeleaf就可以使用thymeleaf的语法在页面显示返回给页面的数据。 使用thymeleaf导入starter 如图，SpringBoot自动配置是导入有Thymeleaf相关自动配置文件的，但是，红色部分是缺少的部分，也就是说少包。自然SpringBoot会提供这些相关的包的starters. 那么在官网上的starters中可以找到spring-boot-starter-thymeleaf，说明SpringBoot提供Thymeleaf的starter需要导入，才能使用Thymeleaf。 在SpringBoot中Thymeleaf的自动配置12345678910111213@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123;// charset private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;// 默认加载模版的路径 public static final String DEFAULT_PREFIX = "classpath:/templates/";// 默认加载的文件类型 是html public static final String DEFAULT_SUFFIX = ".html";// 可自己修改配置文件中的 前缀和后缀，如果 spring.thymeleaf.suffix=.htmlx private String prefix = DEFAULT_PREFIX; private String suffix = DEFAULT_SUFFIX; 使用Thymeleaf进行页面渲染所以在SpringBoot中在Controller中使用如下： 12345678@Controllerpublic class HelloController &#123; @RequestMapping("/home") public String home(Map&lt;String,String&gt; map)&#123; map.put("hello","Hello World~~~"); return "home"; &#125;&#125; 这样映射器就会自动映射到classpath:/templates/home.html文件上。 在templates下建立home.html文件 1234567891011&lt;!DOCTYPE html&gt; &lt;!--引入 xmlns:th 用于thymeleaf语法提示--&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;hello&#125;"&gt;hello world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 重启后查看http://localhost:8080/home发现已经可以让 /home 映射到 home.html 文件上了。并且根据我们传过来的值 Hello World~~~ 显示在页面上了。 Thymeleaf语法可直接参考官方的文档; 使用SpringMVC SpringMvc框架是一种丰富model view controller 的web框架。SpringMVC通过使用 @Controller 和 @RestController 完成对 HTTP 请求的处理。通过使用 @RequestMapping 完成对请求对controller的映射。 自动配置 SpringBoot 对 SpringMVC 在自动配置的时候，进行了很多默认的设置。包括前一篇文章中的关于静态资源加载的两种方式（ Webjars 和本地加载位置），也是通过 SpringBoot 进行自动配置的。更多的 SpringBoot 对 SpringMVC 在哪些地方进行了自动配置，可以参考文档中的SpringMVC 特性。 自动配置代码参考拿 ContentNegotiatingViewResolver这个bean来说，SpringMVC的自动配置类是如何对拓展的支持。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Bean@ConditionalOnBean(ViewResolver.class)// 如果类路径中不存在ContentNegotiatingViewResolver这个类的时候@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;// 返回这个Resolver ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver uses all the other view resolvers to locate // a view so it should have a high precedence resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver;&#125;// ContentNegotiatingViewResolver 类中的初始化servlet容器方法protected void initServletContext(ServletContext servletContext) &#123;// 找出所有的容器中的ViewResolver Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values(); if (this.viewResolvers == null) &#123; this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size()); // 循环添加到viewResolver中 for (ViewResolver viewResolver : matchingBeans) &#123; if (this != viewResolver) &#123; this.viewResolvers.add(viewResolver); &#125; &#125; &#125;@Override@Nullable//实现ViewResolver的实现方法public View resolveViewName(String viewName, Locale locale) throws Exception &#123; RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, "No current ServletRequestAttributes"); List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest()); if (requestedMediaTypes != null) &#123; // 获取候选的view // 在getCandidateViews这个方法里就是把全局的viewResolver循环一遍 List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes); // 寻找最好的/最合适的view View bestView = getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) &#123; return bestView; &#125; 通过上述代码的描述，可以发现如果自己实现ViewResolver，只需要实现ViewResolver后加入到容器中即可。SpringBoot会自动获取容器中的ViewResover。 定制开发如果想保留 SpringBoot 的MVC特性，并且想去添加MVC配置如拦截器，视图控制器等，你可以添加自己的配置类，并且继承WebMvcConfigurer,但是需要注意的是不能使用 @EnableWebMvc 注解。如果使用 @EnableWebMvc 注解，则表示要你全面接管SpringMvc配置功能，不使用SpringBoot自动配置的功能。 使用bean的方式，让 InnerViewResolver 自动发现容器中的ViewResolver 12345678910111213141516@Configuration//@EnableWebMvc // 使用这个注解表示完全不实用SpringBoot对SpringMVC的自动配置功能。public class MvcConfig implements WebMvcConfigurer &#123; @Bean public MyViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125; class InnerViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; return null; &#125; &#125; 这样将一个ViewResolver放到容器中，那么前面说到的 InnerViewResolver 会自动的发现这个bean来使用。 使用 WebMvcConfigurer 实现 123456789101112131415161718192021222324@Configuration//@EnableWebMvcpublic class MvcConfig implements WebMvcConfigurer &#123; @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; registry.viewResolver(new InnerViewResolver()); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addRedirectViewController("/index","/home"); &#125;// ViewResolverRegistry 类中的viewResolver方法，直接添加到全局变量 viewResolvers中，代替前面的遍历public void viewResolver(ViewResolver viewResolver) &#123; if (viewResolver instanceof ContentNegotiatingViewResolver) &#123; throw new BeanInitializationException( "addViewResolver cannot be used to configure a ContentNegotiatingViewResolver. " + "Please use the method enableContentNegotiation instead."); &#125; this.viewResolvers.add(viewResolver);&#125; 继承WebMvcConfigurer使用继承方法，将类放到容器中。 国际化开发下面从自动配置入手，来看SpringBoot是怎么配置国际化的。 让SpringBoot配置指定国际化文件1234567891011121314151617public class MessageSourceAutoConfiguration &#123; private static final Resource[] NO_RESOURCES = &#123;&#125;;// 在配置文件中可以进行配置的内容 以spring.message开头 @Bean @ConfigurationProperties(prefix = "spring.messages") public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125;/***********************MessageSourceProperties**********************/public class MessageSourceProperties &#123; /** * 以逗号分隔的基本名称列表 每一个都是在完整的路径下加载，比如 i18n.home,i18n.hello这样 * 如果在类路径上，就去掉i18n. */ private String basename = "messages"; 如果对basename的值的设置仍有疑惑，那来直接看解析basename的代码。 1234567891011121314151617181920212223242526272829public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 获得propertiesf中的spring.messages.basename属性，如果没有默认是messages String basename = context.getEnvironment().getProperty("spring.messages.basename", "messages"); ConditionOutcome outcome = cache.get(basename); if (outcome == null) &#123; // 调用方法解析basename outcome = getMatchOutcomeForBasename(context, basename); cache.put(basename, outcome); &#125; return outcome;&#125;private ConditionOutcome getMatchOutcomeForBasename(ConditionContext context, String basename) &#123; ConditionMessage.Builder message = ConditionMessage.forCondition("ResourceBundle"); for (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) &#123; // 将basename以逗号分隔，循环这个数组 for (Resource resource : getResources(context.getClassLoader(), name)) &#123; // 这里的getResource方法 是加载classpath + name + .properties中的内容 // 所以国际化文件只支持 properties文件，其他文件不支持 // return new PathMatchingResourcePatternResolver(classLoader) // .getResources("classpath*:" + target + ".properties"); if (resource.exists()) &#123; // 对每一个获取Resource 新建一个match实例对象 return ConditionOutcome.match(message.found("bundle").items(resource)); &#125; &#125; &#125; return ConditionOutcome.noMatch(message.didNotFind("bundle with basename " + basename).atAll());&#125; 国际化步骤上面通过对SpringBoot对国际化的配置的分析，知道了在properties文件中怎么更改国际化文件的配置信息。下面来具体操作，进行国际化。 默认的国际化创建国际化的properties在resources文件夹下创建文件夹i18n ,在文件夹下右键创建Resource Bundle 文件。 左边project locale中有三个选项，default和自己添加的zh_CN和en_US分别表示中文和英文。点击add All后确认，创建文件。如下图： 双击其中的一个配置文件比如index.properties，使用idea可以发现编辑区的左下角有一个Resource Bundle tab页，点击之后，来到如下图的界面，新建一个选项，输入各配置文件中的值。 创建controller和html页面 创建controller 1234@RequestMapping("/index")public String index()&#123; return "index";&#125; 创建html页面 12345678910&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;-- 使用th:text会替换标签内的文本内容 使用#&#123;&#125;来表示国际化内容--&gt;&lt;h1 th:text="#&#123;index&#125;"&gt;这里是主页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 重启程序，发现index页面上显示的是主页，这个内容，正好是在index_zh_CN.properties中定义的index的值。SpringBoot会根据请求头中的语言来判断使用哪个配置文件中的内容。 如何切换页面的中英文？在dispatcherServlet中在渲染视图的时候，会通过locale的属性来改变渲染后的语言。 12345protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 可以通过请求的locale来定义返回的locale Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); 通过debug发现this.localeResolver中是有值的，说明Spring容器中有localeResolver,进而可以得出结论：SpringBoot中自动配置来默认的localeResover。 在WebMvcAutoConfiguration中的确配置了关于locale的信息。 123456789101112@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; // 设置了 容器中的localeResolver 为 AcceptHeaderLocaleResolver AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125; 因为配置了默认的localeResolver ,所以在使用this.localeResolver.resolveLocale(request)处理这个请求的时候，就会使用AcceptHeaderLocaleResolver类中的方法，而这个方法正是拿的request中的Accept-Language 123456789101112@Override public Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader("Accept-Language") == null) &#123; return defaultLocale; &#125; // 从request中拿Accept-Language这个值。 Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = getSupportedLocales(); if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123; return requestLocale; &#125; 这样的话疑惑就解开了，默认的SpringBoot构件web应用会使用当前浏览器的地区语言来进行国际化。 改变国际化语言标准的判断方式上面说了默认的SpringBoot会从request中获取地区语言信息，来判断加载哪个配置。 在自动配置的方法上标注着这样一段@ConditionalOnMissingBean,说明如果有localeResolver这个类那么这个方法是不会生效的。所以改变的方法就是自己实现localeResolver. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyLocalResolver implements LocaleResolver &#123; private Locale defaultLocale; @Override public Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = getDefaultLocale(); String language = request.getParameter("language"); // 获取请求中的 ?language=「xxx」 String[] s = new String[2]; if(language != null &amp;&amp; !"".equals(language))&#123; s = getS(language); &#125;else&#123; //如果是空则找浏览器中的属性 String header = getFirstLangInRequest(request); if(header!=null &amp;&amp; !"".equals(header))&#123; s = getS(header); &#125;else&#123; //否则给个默认的local s = getS("zh-CN"); &#125; &#125; defaultLocale = new Locale(s[0],s[1]); return defaultLocale; &#125; private String getFirstLangInRequest(HttpServletRequest request) &#123; return request.getHeader("Accept-Language").split(",")[0]; &#125; private String[] getS(String language) &#123; return language.split("-"); &#125; public Locale getDefaultLocale() &#123; return this.defaultLocale; &#125;&#125;//添加到bean中 方法名称必须是localeResolver 或者指定bean的名称为localeResolver@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocalResolver();&#125; 稍微修改一下index.html中的内容 123456&lt;body&gt;&lt;h1 th:text="#&#123;index&#125;"&gt;这里是主页&lt;/h1&gt; &lt;-- 点击按钮时变换中英文 --&gt;&lt;a th:href="@&#123;/index(language='zh-CN')&#125;"&gt;&lt;button th:text="#&#123;but1&#125;" &gt;这是切换中文的按钮&lt;/button&gt;&lt;/a&gt;&lt;a th:href="@&#123;/index(language='en-US')&#125;"&gt;&lt;button th:text="#&#123;but2&#125;" &gt;这是切换英文的按钮&lt;/button&gt; &lt;/a&gt;&lt;/body&gt; 重启程序，进行测试： 总结如何在SpringBoot中使用国际化 编写国际化相关的 ResourceBundle文件，也就是对应的语言配置文件如：index_en_US.properties,index_zh_CN.properties，注意这个文件格式是固定的xxx_语言代码_大写的国家代码，并且必须是properties文件。 编写html接收国际化变量，使用Thymeleaf引擎可以使用语法#{}来使用国际化变量。 如何改造因为SpringBoot默认实现了LocaleResolver,并且标注了ConditionalOnMissingBean注解，所以，只需要自己实现LocaleResolver类，重写相关方法，就可以达到改造的目的。需要注意的是，在注册bean的时候，方法名必须localeResolver,或者指定bean的名称为localeResolver。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的WEB开发之Hello-World]]></title>
    <url>%2F2019%2F07%2F13%2F2019-07-13-SpringBoot%E7%9A%84WEB%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[创建基本的web应用SpringBoot可以快速的创建一个restful的web应用。下面开始从零开始创建一套基本的web应用。 使用idea创建Spring initializr我这里直接使用idea中的Spring initializr 来创建SpringBoot应用。同理可以使用start.spring.io中。创建完成后直接在IDE中导入即可。 需要在idea中新建项目 填写项目的基本信息 勾选需要的依赖 最后点击finish完成创建。 文档结构说明 新建SpringBoot应用后自动创建的目录结构如如上图，其中SpringBoot启动类StartSpringBootApplication放在java/com/example/start文件夹中，用于启动整个项目。 对于资源文件，SpringBoot给出来一套目录标准。 resource文件夹中的application.properteis为整体的SpringBoot配置文件。其中有static和templates目录。 static 文件夹用于存放静态资源，如js，css templates 文件夹用于存放模版文件，如jsp,html 那么SpringBoot是如何建立这些目录文件标准的呢？ web目录相关的自动配置web目录相关的自动配置是在WebMvcAutoConfiguration自动配置类中进行配置。而对资源的加载使用的是addResourceHandler 方法 1234567891011121314151617181920212223242526272829@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; // 是否启用默认资源处理 if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; // 获取资源处理程序所服务资源的缓存周期 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // 如果映射器还未映射到/webjars/** 则进行如下操作 if (!registry.hasMappingForPattern("/webjars/**")) &#123; // 添加对/webjars/** 的资源映射 customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/") // 加载包下的 /META-INF/resources/webjars/ 下的内容 .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; // 静态路径pattern 为 "/**" String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; //如果映射器还没有映射 /** 路径的资源时 customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) // 加载所有的默认定义的位置里的资源。 .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cache Period)).setCacheControl(cacheControl)); &#125;&#125; webjarsWebJars是打包到JAR（Java Archive）文件中的客户端Web库（例如jQuery和Bootstrap）。 from webjars官网 根据以上内容举个例子来讲解如何使用webjars进行静态资源的加载： 去官网找相关资源的依赖 添加到pom.xml文件中 以粉色的竖线为分割线，左侧为下载完的webjars的jar包，右侧为在pom.xml文件中的依赖信息。 加载webjars如果SpringBoot发现有webjar的应用jar包，则加载路径classpath:/META-INF/resources/webjars/下的文件。在图中例子中就是jquery文件夹下的所有内容。这样SpringBoot就能够识别jquery包下的所有静态文件了。 映射webjarsSpringBoot会将所有已将加载jars映射到 /webjars/** 这个路径上。 比如上面我们添加了jquery.min.js。我们启动程序，可以在http://localhost:8080/webjars/jquery/3.4.1/jquery.min.js这个地址上访问，发现系统已经通过webjars将资源加载到了。在实际的使用中，使用script标签引用webjars也是引用这个地址的静态文件。 项目内静态资源使用webjars用来加载静态资源非常方便，但是如果自己写的js和css等静态资源也需要加载时，就需要放到SpringBoot默认加载的目录下。 123456789101112@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; "classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/" &#125;; private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; private boolean addMappings = true; private final Chain chain = new Chain(); private final Cache cache = new Cache(); // 获取静态资源目录 public String[] getStaticLocations() &#123; return this.staticLocations; &#125; 通过getStaticLocations获取静态资源的目录，默认的SpringBoot定义了classpath下的以下的文件，都可以放置静态文件，都可以通过url的方式访问到这个静态文件。 classpath:/META-INF/resources classpath:/resources/ classpath:/static/ classpath:/public/ 需要注意的是这个classpath就是一开始创建SpringBoot应用帮我们创建好的resource路径 这个类也是一个xxxxProperties类，所以可以通过改变相应的配置文件中的属性来改变这个路径。这里的路径使用的变量是staticLocations,所以相应的在application.properties文件中可以使用spring.resources.staticLocations=路径名称就行了。 主页的设置SpringBoot默认的使用静态资源文件夹下的index.html作为首页。 123456789private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); //遍历每个locations寻找index.html页面作为首页 return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + "index.html");&#125; 如果找到主页的index.html后，就开始做主页的映射操作 12345678910111213@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125;WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; // 如果存在，设置首页为index.html 映射路径为： /** if (welcomePage.isPresent() &amp;&amp; "/**".equals(staticPathPattern)) &#123; logger.info("Adding welcome page: " + welcomePage.get()); setRootViewName("forward:index.html"); &#125; 上面是依据SpringBoot加载静态资源的方式做的简单总结。 添加controller在上一步创建完项目后，可以紧跟着写一个SpringMVC测试的controller，看看能否启动项目。 12345678910// 起到了@Controller和@Responsebody两种作用，实际上就是// 两种注解的整合@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello()&#123; return "hello world"; &#125;&#125; 如果你也像我勾选来数据库相关的starters,在启动时，控制台会提示需要配置数据库的基本配置。 那么怎么找这些配置呢？ 去官网找配置 直接看代码 如果你没有碰到上面这个问题，那么请忽略以下部分。 因为前几篇文章中已经分析来SpringBoot是如何完成自动配置的，所以这里我想通过找代码的方式直接看它能够配置哪些属性。 首先在autoconfiguration包下面的spring.factory中搜索jdbc 点击关于DataSource的自动配置类 12345678910111213141516171819@EnableConfigurationProperties(DataSourceProperties.class)@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)public class DataSourceAutoConfiguration &#123;// 使用DataSourceProperties类作为属性类,以下为基本属性@ConfigurationProperties(prefix = "spring.datasource")public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean &#123; private ClassLoader classLoader; private String name; private boolean generateUniqueName; private Class&lt;? extends DataSource&gt; type; private String driverClassName; private String url; private String username; private String password; 根据DataSourceProperties类，可以知道如果我们像配置DataSource，那么有这几个属性可以进行配置。 12345# spring.datasource 为前缀，后面为属性名，和Properties类中的属性相对应。spring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456 测试结果]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql使用外键（8.0）]]></title>
    <url>%2F2019%2F07%2F11%2F2019-07-11-%E4%BD%BF%E7%94%A8Mysql%E7%9A%84%E5%A4%96%E9%94%AE%2F</url>
    <content type="text"><![CDATA[使用外键约束Mysql默认使用的是innoDB引擎，该引擎是支持外键的，下面来说说如何创建外键及各种外键使用的效果。 基本概念需要注意的是外键不支持虚拟构造出的列上。 MySql支持外键，允许跨表交叉引用相关数据，有助于帮助保持数据的一致性。在create和alter表中的语句如下： 123456789101112131415161718192021222324252627282930-- 中括号内是非必写的[CONSTRAINT [symbol]] FOREIGN KEY [index_name] (col_name, ...) REFERENCES tbl_name (col_name,...) [ON DELETE reference_option] [ON UPDATE reference_option]reference_option: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULTCREATE TABLE child ( id INT, parent_id INT, -- 定义索引 INDEX par_ind (parent_id), -- parent_id关联parent表中的id字段 -- 如果父表删除了，则子表也需要删除字段内容 FOREIGN KEY (parent_id) REFERENCES parent(id) ON DELETE CASCADE) ENGINE=INNODB;-- 添加外键ALTER TABLE tb1 ADD FOREIGN KEY (parent_id) REFERENCES parent(id) ON DELETE CASCADE-- 删除外键ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol; index_name 指的是外键的标识，如果子表已经显式的定义了可以支持外键的索引（上面例子中的par_ind），则忽略。否则，mysql会依照以下规则隐式的创建一个外键索引。 如果定义CONSTRAINT symbol 值，则使用这个值，否则使用外键名 index_name. 如果上面两个都没有定义，外键名使用引用外键列的名称。 更新/删除行为Mysql如何使用外键来保证参照的完整性。 对于支持外键的innoDB存储引擎来说，MYSQL拒绝在子表中插入或删除在父表中没有匹配到的外键候选值。 当父表中的外键候选值发生变化的时候，根据不同的行为策略，来影响子表中对应的外键的键值。具体的策略如下： CASCADE 【级联】如果在父表中删除和更新数据，会自动的删除和更新子表中的匹配到的所有数据。支持删除级联ON DELETE CASCADE和更新级联ON UPDATE CASCADE,两个表之间，不要定义几个这样的子句，这些子句作用域父表或子表中的同一列。 SET NULL 【置空】如果在父表中删除和更新数据，则自动的置空NULL子表中的外键对应的字段。如果在更新或删除操作中指定了ON DELETE SET NULL或者ON UPDATE SET NULL 时，必须保障*子表外键的那个字段没有设置为 NOT NULL * RESTRICT 【限制】如果在伏笔啊哦中删除和更新数据，子表拒绝删除或更新对应字段内容。 NO ACTION【无动作】NO ACTION 是标准SQL中的关键字，在mysql中NO ACTION和RESTRICT的作用相同，都是在在修改或者删除之前去检查从表中是否有对应的数据，如果有，拒绝操作。 但是有些数据库系统会有延迟检查功能，会导致NO Action 会延迟检查是否有对应数据，但是MYSQL外键的检查是立即执行的，所以RESTRICT和NO ACTION是完全相同的 SET DEFAULT需要注意的是，set default只是MySQL 解析器认可，但是InnoDB和NDB 拒绝在定义表时，出现ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT 语句。]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的日志使用]]></title>
    <url>%2F2019%2F07%2F10%2F2019-07-10-SpringBoot%E7%9A%84%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[SpringBoot的日志使用SpringBoot的日志选择SpringBoot默认使用SLF4j和logback用作日志。为什么是两个，为什么是这两个？ 日志框架的大致分类日志框架分为日志的门面框架和具体的实现框架，为什么需要门面框架，是因为不同的系统对日志的需求可能不同，系统一可能使用日志框架一，系统二还需要实现日志功能，如果还用日志框架一，则需要适配系统二进行api的调整。 门面日志框架就为了解决这一问题。让调用框架的api统一，具体的实现可以随不同的系统进行调整。类似jdbc，操作接口需要进行统一。 所以SpringBoot的日志使用分别是用来日志门面框架SLF4j和日志具体实现框架logback作为日志服务。 使用日志简易使用SLF4j参考SLF4j官网中的hello world程序： 12345678910// 导入slf4j的jar包import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 下图表示了使用slf4j和各个日志实现框架的匹配。绿色的是适配层，深蓝色的是实现框架。比如使用logback作为实现框架，则需要导入slf4j的jar包和logback的相关jar包。但是如果使用log4j作为实现框架，还需导入中间的适配层jar包（中间绿色的）。 在Springboot-logging-start中使用如下的jar包依赖： 每一个实现框架都有各自的配置文件，使用slf4j后，配置文件还是使用具体实现的配置文件。 SpringBoot中的SLF4j SpringBoot底层自动配置使用的是SLF4j和logback。 SprintBoot使用中间包将其他日志框架转化为slf4j框架。 引入其他日志框架时，需要把这个日志的jar包排除掉。否则与slf4j的jar包相冲突，上一条就是原因。 在测试文件中测试SpringBoot的日志使用 12345678910111213Logger logger = LoggerFactory.getLogger(this.getClass()); @Test public void testLogger()&#123; // 由低到高 日志的级别，日志框架可以根据配置文件调整输出的日志级别， // 只会输出相应日志级别及后面的高级别日志信息 logger.trace("这是trace日志"); logger.debug("这是debug日志"); // SpringBoot默认使用的是info级别， // 可以使用日志的配置文件调整级别 logger.info("这是info日志"); logger.warn("这是warn日志"); logger.error("这是error日志"); &#125; 日志级别有trace, debug,info,warn,error五种日志级别。并且由低到高排序。指定日志级别，则系统会输出当前日志级别和更高的日志级别的日志。 12345678910111213141516# 全局的日志记录级别#logging:# level: trace# 指定的包下的日志记录级别logging: level: com : nanyin : debug# pattern: 输出格式# file:# console:# file: -- 这里用于指定日志记录的文件名，可以指定具体的路径，未指定则生成在当前项目下# path: -- 这里用于指定日志文件的路径，springboot会默认生成路径，默认文件名# 这两个指定一个就好了，都指定则会默认使用file 使用自定义的配置文件更换log4j2作为日志框架]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中的配置文件（拓展）]]></title>
    <url>%2F2019%2F07%2F08%2F2019-07-08-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot中的配置文件(拓展)如果有多个环境，配置文件需要根据环境来变化，只有一个配置文件就显的鸡肋了，每次变更环境的时候都需要修改一遍配置文件，两个还好，多了就相当麻烦了。 SpringBoot提供了多配置文件的用法，让环境的变化尽可能少的影响到配置文件的更改。 多配置文件加载顺序Spring会按以下顺序查找地址，如果有则优先使用前面的配置文件的属性，如果后面的文件有前面文件没有的属性，则会添加，否则忽略。 file:./config/ file:./ classpath:/config/ classpath:/ 指定/添加默认加载地址使用spring.config.location来指定默认的加载地址。 如果spring.config.location 指定的值为： classpath:/custom-config/,file:./custom-config/，则系统会优先找这个文件。 如果使用spring.config.additional-location来添加配置文件的加载地址。 命名格式可以使用 application-{profile}.properties来定义一个特殊的配置文件。特殊的这个配置文件如果调用，那么他总会覆盖掉默认的application.properties文件中的内容。 比如使用application-dev.properties作为开发环境的配置文件，在其中指定了服务端口8081.而在默认的application.properties中指定的端口号为8080.那么，系统会使用哪个端口呢？ 下面我使用yml文件作为例子（同properties文件） 123456789101112# application.yml文件中的内容server: port: 8080# yaml文件格式指定使用哪个配置spring: profiles: active: dev# application-dev.properties文件中的内容server: port: 8081 通过spring.profiles.active=dev(这时properties格式)。来特殊指定启用哪些配置文件。这里启用的是application-dev.properties文件。 由控制台的输出结果可以看出，springBoot激活了名为dev的配置文件及application-dev.properties文件，并且更改端口为dev中指定的8081端口。 使用yaml文档块yaml文件提供一种特性叫做文档块。使用三个-来隔离配置信息 1234567891011121314151617181920212223# 默认的server: port: 8080spring: profiles: active: dev# 文档块1---spring: profiles: devserver: port: 8081# 文档块2---spring: profiles: prodserver: port: 8082 使用文档块能够减少多个配置文件。与多个配置文件效果是等同的。 自动配置其实在前面的文章中已经大概了解了SpringBoot如何进行自动配置，但是仅仅停留在了EnableAutoConfiguration注解的使用和浅层的解析上，这次需要更加深入的了解如何调用到自动配置类、我们如果想自己在配置文件中配置属性，该怎么去配置。 如何进行的自动配置首先还是进入到SpringBootApplication注解中 12345@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) public @interface SpringBootApplication &#123; 发现这里调用了EnableAutoConfiguration注解。再点进这个注解中。 1234@AutoConfigurationPackage// 引用了AutoConfigurationImportSelector这个类@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; 这里通过import注解使用了AutoConfigurationImportSelector类，这个类直接翻译过来叫做自动配置导入选择器。进入这个类中看。 12public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; 这里我们可以看到AutoConfigurationImportSelector继承了DeferredImportSelector这个类。这个类中需要实现的方法是void process(AnnotationMetadata metadata, DeferredImportSelector selector);方法。 所以需要看AutoConfigurationImportSelector中是如何实现父类中定义的process方法。 1234567891011121314public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123; Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format("Only %s implementations are supported, got %s", AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); // 获得自动配置的entry，点进这个方法看如何获取自动配置的配置信息的 AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry);// 循环所有configuration然后放到entries中添加到容器中。 for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123; this.entries.putIfAbsent(importClassName, annotationMetadata); &#125;&#125; 通过getAutoConfigurationEntry这个方法获取到所有的自动配置的信息。点进这个方法看是如何获取到的 12345678910protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); // 返回自动配置类的全类名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 去掉重复的 configurations = removeDuplicates(configurations); 通过getCandidateConfigurations来获取自动配置的全类名。 1234protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;// 第一个参数返回的是 EnableAutoConfiguration.class List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); 接着调用loadFactoryNames获取自动配置类的List 1234567public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // 这里的factoryClassName是EnableAutoConfiguration String factoryClassName = factoryClass.getName(); // 下面这句话的意思是需要在loadSpringFactories这个map中获取key为EnableAutoConfiguration的value return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 那么这个map的值是怎么形成的呢？ 12345678910111213141516171819202122// 在FACTORIES_RESOURCE_LOCATION中获取资源Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));//定义一个MAP，将结果都存到这个map中result = new LinkedMultiValueMap&lt;&gt;();//对每个资源循环while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url);// 转化为properties Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; // 最后添加到result中 result.add(factoryClassName, factoryName.trim()); &#125; &#125;&#125;cache.put(classLoader, result);return result; 下图是对result的debug结果，框中是所有的结果，但横线处是我们自动配置需要的。 结果在FACTORIES_RESOURCE_LOCATION（META-INF/spring.factories）中可以找到. 这里的所有类都是可以自动配置到Spring的容器中。 如何根据自动配置类配置属性进入到spring.factories中进行查看所有autoConfigure类，用CacheAutoConfiguration举例，来分析以后想要配置关于cache的属性，怎么查找到这个配置属性，怎么配置到properties文件中。 直接点进类中发现有很多注解，一个个看 123456789101112131415//表示一个配置文件@Configuration// 仅当classpath中存在特定的CacheManager类时匹配@ConditionalOnClass(CacheManager.class)// 如果Spring 容器中存在CacheAspectSupport@ConditionalOnBean(CacheAspectSupport.class)//如果Spring容器不满足bean的name为cacheResolver，value为CacheMaager@ConditionalOnMissingBean(value = CacheManager.class, name = "cacheResolver")// 开启自动配置属性，指向 CacheProperties类@EnableConfigurationProperties(CacheProperties.class)@AutoConfigureAfter(&#123; CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class, HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class &#125;)// 缓存配置的选择器@Import(CacheConfigurationImportSelector.class)public class CacheAutoConfiguration &#123; 其中EnableConfigtionProperties注解用来开启配置属性。 12345678910// spring.cache就是在配置文件中使用的前缀@ConfigurationProperties(prefix = "spring.cache")public class CacheProperties &#123;// 以下就是各属性值 private CacheType type; private List&lt;String&gt; cacheNames = new ArrayList&lt;&gt;(); private final Caffeine caffeine = new Caffeine(); private final Couchbase couchbase = new Couchbase(); private final EhCache ehcache = new EhCache(); private final Redis redis = new Redis(); 用cache中的redis对象为例子，如何去配置redis缓存。 其中指定了前缀，和中间的redis对象，所以redis的配置中的属性就应该是spring.cache.redis.xxx. 12345public static class Redis &#123; private Duration timeToLive; private boolean cacheNullValues = true; private String keyPrefix; private boolean useKeyPrefix = true; 比如需要配置不允许redis缓存空值，就需要配置cacheNullValues属性，所以可以在配置文件中写 1spring.cache.redis.chcheNullValues=false 其他类型的自动配置类同理，每个自动配置类都配备一个xxxProperties.class类进行属性的匹配,所以如果需要某个属性，则直接向对应的类中查找，找出前缀和属性名，则可直接找出完成的配置名称。 经过上面的分析，在也不用担心该如何配置配置文件了。 自定义SpringBoot Starter实现自动配置如果自行进行自动配置。主要实现的文件是： xxxxAutoConfiguration类 xxxxProperties类 resources/META-INF/ 下的 spring.factories 文件中添加：org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.example.autocinfigure.xxxxAutoConfigure 在创建自动配置包前需要在pom文件中添加自动配置的包依赖。 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 加载的基本过程： Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包 根据spring.factories配置加载AutoConfigure类 根据 @Conditional注解的条件，进行自动配置并将Bean注入Spring Context]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot深入自动配置]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-04-SpringBoot%E6%B7%B1%E5%85%A5%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot深入自动配置引入在上一篇Spring Boot与微服务基本介绍中，介绍了创建maven项目到运行springboot的基本过程。 其中使用主程序来启动SpringBoot 1234567@SpringBootApplicationpublic class DeepSpringBootApplication &#123; public static void main(String[] args) &#123; // 使用SpringApplication.run方法来启动spring boot应用 其中参数有类和args SpringApplication.run(DeepSpringBootApplication.class,args); &#125;&#125; 仅仅是添加了一个@SpringBootApplication注解，这个注解的作用是什么，原理是什么，接下来就通过源码简单看一下。 SpringBootApplication启动注解1234567891011121314151617181920//点开@SpringBootApplication源码@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; /** AliasFor注解的作用是为了声明别名 * AliasFor在下面代码中的作用就是通过别名引用在annotatin指定的类的特定方法 * 如果有兴趣可以参考AliasFor的官方文档 * https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AliasFor.html * 比如这里就会指定 EnableAutoConfiguration的exclude方法 **/ @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; // 。。。其他的省略&#125; 在上面的@SpringBootApplication源码中，其中使用到了三个比较重要的基本注解@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。下面分别来对这三个注解进行简单分析。 SpringBootConfiguration1234567891011/** * 标示是一个spring boot应用的配置类，用作 @Configuratio的替代品 * 以便自动找到配置 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 其实这时SpringBoot对Spring的@Configuration的注解的包装 Configuration12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor(annotation = Component.class) String value() default "";&#125; 简单理解为，Configuration 注解上标注了@Component原注解，所以它也是一个spring组件，会通过扫描把标志这个注解的类作为spring的配置类加载到容器中。 实际上加载Configuration的方法有三种，自动扫描配置类只是其中的一种，其他两种是 通过AnnotationConfigApplicationContext类 12345678910111213@Configuration public class AppConfig &#123; @Bean public MyBean myBean() &#123; // instantiate, configure and return bean ... &#125;&#125;AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();// 注册Beanctx.register(AppConfig.class);ctx.refresh();MyBean myBean = ctx.getBean(MyBean.class); 使用xml配置文件,将标注为@Configuration的类作为一个bean来声明在xml文件中。 1234&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;bean class="com.acme.AppConfig"/&gt; &lt;/beans&gt; 标记@Configuration注解的类表示这个类中声明了一个或多个@Bean方法，可以交由spring容器处理。可以在运行时生成bean定义和bean之间的服务请求。 更加详细的参考Spring官网Configuration注解 EnableAutoConfigurationEnableAutoConfiguration是spring boot中的注解，它的作用就是猜测并自动配置可能需要的bean,也就是自动配置功能。 1234567@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 其中重要的两个注解@AutoConfigurationPackage和@Import中的内容 AutoConfigurationPackage12345678910111213141516171819// 标注@AutoConfigurationPackage的注解可以使用Registrar进行注册// @Import的作用就是引用配置类，将多个配置类放到一个主配置中@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125;// 注册方法static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;// 注册bean定义信息 @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; // 这里的packageName是标注这个注解的类的包的路径名称，如下图 register(registry, new PackageImport(metadata).getPackageName()); &#125; @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new PackageImport(metadata)); &#125;&#125; 将主配置类的所在的包及下面的所有子包扫描到Spring容器中。 123456789101112131415161718// 以编程方式注册自动配置包名称.将给定的包【这里的是com.nanyin 】注册添加到已经注册的包名称中public static void register(BeanDefinitionRegistry registry, String... packageNames) &#123;// private static final String BEAN = AutoConfigurationPackages.class.getName(); if (registry.containsBeanDefinition(BEAN)) &#123; BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues(); constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); &#125; else &#123; // 使用标准的类定义 GenericBeanDefinition 注册bean GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 注册bean registry.registerBeanDefinition(BEAN, beanDefinition); &#125;&#125; @Import(AutoConfigurationImportSelector.class)自动导入组件的选择器。将需要导入的组件以全类名的方式返回一个数组。 12345678910111213@Overridepublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123; Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format("Only %s implementations are supported, got %s", AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); //获取自动导入的内容的全类名，在这一步进行debug见下图 AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry); for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123; this.entries.putIfAbsent(importClassName, annotationMetadata); &#125;&#125; 代码中断点得出的自动导入的包名称： 通过方法getConstructorArgumentValues得到自动配置的包的名称，调用了SpringFactoriesLoader的方法，其中 123456789101112protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you " + "are using a custom packaging, make sure that file is correct."); return configurations;&#125;// 调用loadFactoryNames获得一组包名称public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 最后通过文件中spring.factorys文件中的内容来获取最终的自动导入自动配置类包范围。 ComponentScan组件扫描指令，需要与@Configuration一起使用。与Spring提供的xml配置&lt;context:component-scan&gt;作用相同。 在SpringBootApplication注解中是这样定义ComponentScan的： 1234@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class)&#125;) excludeFilters的作用是指定哪些类型不符合组件扫描的条件，也就是排除掉指定的类。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中使用配置]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-06-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot中使用配置一、配置文件SpringBoot使用全局的配置文件，配置文件名是固定的 application.properties application.yml 使用配置文件可以更改系统自动配置的默认值，比如端口号等信息。 YAMLyaml以数据为中心，比xml，json更适合做配置文件。 YAML与properties对比YAML: 12server: port: 8080 properties: 1server.port: 8080 YAML语法 基本语法 k : v 表示一对键值对 「中间需要有空格」，以空格的缩紧来表示层级关系，使用左对其的数据都是一个层级的。 例如下面代码中的port和path是一个层级的。 123server: port: 8081 path: /hello 值的写法 字面量 key : value 字面量直接写，并且字符串不需要添加引号，类似properties。如果添加引号会有特殊的意义。 双引号： 不会转义特殊字符单引号： 会转义特殊字符，最终会转义成普通的字符串输出 对象 非行内写法 -&gt; key : value 对象一样按照key，value来写 123person: firstName: zhang lastName: san 行内写法 1person:&#123;firstName: zhang,lastName: san&#125; 数组（list，set） 使用 - 来表示数组中的一个元素 1234person - zhangsan - lisi - wangwu 使用yml配置文件进行配置编写bean对象12345678910111213141516171819202122232425262728293031import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/*** * 如果需要使用ConfigurationProperties 这个注解需要添加 * * &lt;dependency&gt; * &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; * &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; * &lt;optional&gt;true&lt;/optional&gt; * &lt;/dependency&gt; * * @Author nanyin * @Date 16:29 2019-07-07 * * 使用Lombok的data注解可以自动的配置 setter，getter，toString属性， * 但是需要IDE的Lombok插件 **/@Data@ConfigurationProperties(value = "person")@Componentpublic class Person &#123; private String name; private int age; private User user;&#125;@Datapublic class User &#123; private int id;&#125; 使用configurationPropertis配置类根据bean对象在application.yml文件中编写如下yml内容： 12345person: name: zhangsan age: 12 user: id: 1 使用SpringBoot的单元测试在测试文件夹下建立DeepSpringBootApplicationTest测试类。 123456789101112131415161718/*** * 使用spring的测试，可以使用spring的注入功能 * 这里的runWith注解说明的是让junit使用Spring的运行测试方式 * 也就是说可以使用spring的注入等特性 * @Author nanyin * @Date 16:27 2019-07-07 **/@RunWith(SpringRunner.class)@SpringBootTestpublic class DeepSpringBootApplicationTest &#123; @Autowired Person person; @Test public void testPerson()&#123; System.out.println(person.toString()); &#125;&#125; 如果需要使用上面的代码进行SpringBoot的单元测试，需要在pom.xml文件中添加如下内容： 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 最后运行刚才的测试类，得到的结果是： 通过运行结果可知道，使用application.yml文件编写配置信息成功的放到Person这个类中。 PropertySource上面使用yml文件，通过configurationPropertis对Person进行了配置。 configurationPropertis它会从全局配置文件application.yml配置文件中的配置。但如果指定某个具体配置文件中的配置呢？ 答案是PropertySource注解 使用properties文件 在classpath路径下新建要个person.properties文件,文件内容如下； 123person.age= 12person.id= 2person.name=zhangsan 在原来的基础上添加PropertySource注解 12345678910@Data// 指定使用到的配置文件，这里的value可以是数组，也就是可以加载多个配置文件@PropertySource(value="classpath:person.properties")@ConfigurationProperties(value = "person")@Componentpublic class Person &#123; private String name; private int age; private User user;&#125; 运行结果和上面测试结果的相同。 使用yml文件 使用yml文件作为配置文件时，与properties文件略有不同，是因为PropertySource实际上上默认是不支持yaml文件的。所以如果使用yml文件就需要略加改造。经过一番谷歌后。 PropertySourceFactory是spring 4.3之后出现的为PropertySource的工厂接口，注解默认使用的是DefaultPropertySourceFactory来创建ResourcePropertySource对象。 spring通过YamlPropertiesFactoryBean来加载yaml文件。这个类可以将一个或多个文件加载为java.util.Properties对象。 123456789101112131415161718192021222324252627282930313233343536package com.nanyin.config;import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.core.env.PropertiesPropertySource;import org.springframework.core.env.PropertySource;import org.springframework.core.io.support.EncodedResource;import org.springframework.core.io.support.PropertySourceFactory;import org.springframework.lang.Nullable;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;public class YamlPropertiesFactory implements PropertySourceFactory &#123; @Override public PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException &#123; Properties propertiesFromYaml = loadYamlIntoProperties(resource); String sourceName = name != null ? name : resource.getResource().getFilename(); return new PropertiesPropertySource(sourceName, propertiesFromYaml); &#125; private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException &#123; try &#123; YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean(); factory.setResources(resource.getResource()); factory.afterPropertiesSet(); return factory.getObject(); &#125; catch (IllegalStateException e) &#123; // for ignoreResourceNotFound Throwable cause = e.getCause(); if (cause instanceof FileNotFoundException) throw (FileNotFoundException) e.getCause(); throw e; &#125; &#125;&#125; 实现上述代码后，在配置类中的PropertySource中添加factory 1234567891011@PropertySource(value=&#123;"classpath:person.yml"&#125;, factory = YamlPropertiesFactory.class)@ConfigurationProperties(prefix = "person")@Component@Datapublic class Person &#123; private int id; private String name; private int age; private User user;&#125; yaml文件文件中的内容.其中使用${xxx}的结构可以调用其他属性的值，这里user的id值就是直接使用person的id值。 123456person: age: 12 id: 2 name: zhangsan user: id: $&#123;person.id&#125; 二、配置类在原来使用Spring时，繁多的xml让人头疼。而在SpringBoot中，推荐使用类的方式代替xml等配置文件，改用注解的方式。 创建一个类，类名为MyConfig 为类标注为@Configuration 将需要引入到容器中的bean作为返回值写到方法中，其中方法的名称就是容器中bean的名称。 进行测试，容器中加载到了这个配置类中配置的bean 1234567891011121314151617181920212223242526272829303132// 标注@Configuration注解，表示这个是Spring的配置类，用来代替配置文件如 xxx.xml@Configurationpublic class MyConfig &#123; @Autowired Person person; /** * 使用@bean注解向容器中添加bean，用来替代原来xml配置文件中的 *&lt;beans&gt; * &lt;context:annotation-config/&gt; * &lt;bean class="com.acme.AppConfig"/&gt; *&lt;/beans&gt; * 其中方法的返回值是添加到容器中的内容 */ @Bean public HelloService helloService()&#123; // 可以使用person的配置值 System.out.println("加载MyConfig配置文件！！！ 其中配置文件中的 name 属性：" + person.getName()); return new HelloService() ; &#125;&#125;// SpringBoot测试public class DeepSpringBootApplicationTest &#123; @Autowired ApplicationContext ctx; @Test public void testContainsBean()&#123; System.out.println(ctx.containsBean("helloService")); &#125;&#125; 将HelloService手动通过配置类的方式添加到容器中，作用和使用xml的方式一样，但是更简单，更容易看懂。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与微服务简介]]></title>
    <url>%2F2019%2F07%2F06%2F2019-07-03-SpringBoot%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[SpringBoot与微服务简介SpringBoot通过整合Spring的各个技术栈用来简化Spring应用开发，使用约定大于配置的思想。简单快速的创建一个独立的，产品级的应用。 SpringBoot优点 快速创建独立运行的Spring项目与各大主流框架的集成。 自带嵌入式的servlet容器。 springboot带有starters自动依赖与版本控制。 大量的自动配置，约定大于配置。 无需配置xml，告别大量的xml文件。 springboot的hello world创建一个maven应用 创建一个普通的maven项目 创建后的maven结构，包含pom.xml文件内容 开启idea中对maven的自动导入功能 在POM文件中添加依赖12345678910111213141516171819&lt;!-- org.springframework.boot 作用： 1. 默认使用java版本,默认编码 2. 引用管理的功能，比如version会从这里继承出去 3. 识别插件配置 4. 识别.properties 和.yml配置文件 5. 整体的版本依赖--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建应用主程序12345678910111213141516171819import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * EnableAutoConfiguration 表示告诉spring boot如何去配置spring， * 其可以帮助 SpringBoot 应用将所有符合条件的 @Configuration 配置都加载到当前 IoC 容器之中 * 自从添加spring-boot-starter-web这个starter添加了tomcat和spring MVC后，使用该注解，就说明使用spring启动一个web项目 * SpringBootApplication 等同于使用@Configuration @EnableAutoConfiguration @ComponentScan这三个注解 * @Author nanyin * @Date 21:46 2019-07-04 **/@SpringBootApplicationpublic class DeepSpringBootApplication &#123; public static void main(String[] args) &#123; // 使用SpringApplication.run方法来启动spring boot应用 其中参数有类和args SpringApplication.run(DeepSpringBootApplication.class,args); &#125;&#125; 使用SPringMvc编写controller层12345678910111213import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public @ResponseBody String home() &#123; return "Hello World!"; &#125;&#125; 运行主程序进行测试打开http://localhost:8080/hello 查看网页上的内容显示出hello world字符。测试成功 导入maven插件打jar包在pom.xml文件中添加如下内容 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 保存之后使用mvn package命令打成jar包，可以在输出信息中找出打完的jar包的位置。使用java -jar xxxxxx.jar命令运行程序。 微服务微服务其实是一种架构风格，一个应用应该是一组小型服务组成，小型服务通过http api的方式进行沟通。每一个小型服务都是一个功能元素，能够独立替换和独立升级的应用单元。 详细请参考martinfowler.com 中的这篇微服务文章：微服务]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之命令模式]]></title>
    <url>%2F2019%2F06%2F28%2F2019-06-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之命令模式命令模式是对象的行为模式，命令模式将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 应用场景 通过要执行的操作来参数化对象。可以使用回调函数在过程语言中表达此类参数化，也就是说，某个函数已注册到稍后要调用的某个位置。命令模式可以说是面向对象的回调函数。起到在特定位置被调用的目的。 在不同的时间下进行发出请求和执行请求，命令对象可以独立于请求，拥有一个独立的生命周期。命令允许请求的一方和接收请求的一方能够独立演化。 撤销操作，命令模式可以在命令执行的时候可以在命令类中存贮当前状态，可以通过遍历此列表并分别转发调用unexecute和execute来实现无限级别的撤销和重做。 可以更容易的将命令记录到日志中。 命令模式使新的命令很容易地被加入到系统里。具有很好的拓展性。 模式结构 命令模式涉及到五个角色，它们分别是： 客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。 命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。 请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法 代码抽象命令角色123public interface Command &#123; void excute();&#125; 请求者角色12345678910111213// 请求者用来请求命令public class King &#123; private Command command; public Command invoke(Command command)&#123; this.command = command; return this.command; &#125; public void action()&#123; command.excute(); &#125;&#125; 接收者角色123456789101112131415public class Soldier &#123; // 行动方法 public void prepareWeapon()&#123; System.out.println("Soldier prepare Weapon !!!"); &#125; public void attack()&#123; System.out.println("Soldier Attack!!!"); &#125; public void retreat()&#123; System.out.println("Soldier Retreat!!"); &#125;&#125; 具体命令者角色123456789101112131415public class AttackCommand implements Command&#123; Soldier soldier ; public AttackCommand(Soldier soldier) &#123; this.soldier = soldier; &#125; @Override public void excute() &#123; // 收到请求，执行操作 soldier.prepareWeapon(); soldier.attack(); &#125;&#125; 客户端代码12345678910111213public class App &#123; public static void main(String[] args) &#123; // 接受者和请求者 King king = new King(); Soldier soldier = new Soldier(); // 请求者请求命令 king.invoke(new AttackCommand(soldier)); // 请求者发起命令 king.action(); king.invoke(new RetreatCommand(soldier)); king.action(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2F2019%2F06%2F27%2F2019-06-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之迭代器模式迭代器是一种行为模式，它提供一种顺序访问聚合对象元素的方法，而不会暴露其基础表示。 应用场景 指向访问集合对象内容，而不暴露其内部实现。 可以对集合对象多次遍历 为不同集合对象提供统一的遍历接口 模式结构迭代器模式大致分为四个角色：抽象容器，具体容器，抽象迭代器，具体迭代器。结构图如下： 容器一般为一种数据结构的类，例如list、map。 迭代器是提供遍历这个数据结构的方法的类。 代码在java中提供很多Iterator的模式。例如 1234567891011public class example &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); Iterator iterator = (Iterator) list.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 这里的ArrayList类中实现类Iterator接口的内部类，并且使用iterator()方法调用new Itr();，具体内容可以查看ArrayList源码。 下面自己实现一个简单的Iterator. 第一部分：抽象迭代器1234public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next();&#125; 第二部分：抽象容器类12345public interface Task &#123; void add(int mark); void removeLast(); Iterator&lt;Object&gt; iterator();&#125; 第三部分：实现类123456789101112131415161718192021222324252627282930313233343536373839404142public class MyTask implements Task &#123; private int size = 0 ; private Object[] taskTag = new Object[16]; @Override public void add(int mark) &#123; taskTag[size] = mark; size ++; &#125; @Override public void removeLast() &#123; taskTag[--size] = null; &#125; @Override public Iterator&lt;Object&gt; iterator() &#123; // 调用内部类实现迭代器 return new MyTaskItr(); &#125; // 使用内部类实现迭代器 private class MyTaskItr implements Iterator&lt;Object&gt;&#123; private int curr; @Override public boolean hasNext() &#123; return size != curr; &#125; @Override public Object next() &#123; int i = curr; if(i &gt;= size)&#123; throw new NoSuchElementException("no element"); &#125; return taskTag[curr++]; &#125; &#125;&#125; 客户端调用1234567891011121314151617public class App &#123; public static void main(String[] args) &#123; Task task = new MyTask(); task.add(1); task.add(3); task.add(4); task.add(2); task.removeLast(); task.removeLast(); task.add(5); Iterator taskIterator = task.iterator(); while(taskIterator.hasNext())&#123; System.out.println(taskIterator.next()); &#125; // 结果依次打印出 1，3，5 &#125;&#125; 简单而强大的迭代器模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PlantUML类图使用总结]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-26-PlantUML%E7%B1%BB%E5%9B%BE%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[使用PlantUML绘制类图本文基于PlantUML官网绘制类图和相关如何正确uml类图相关文章。 为什么使用plantUml原因很简单，不用自己考虑构图，像写代码一样写出来，图出来既美观又能够符合逻辑。 基本类构成基本使用 使用class关键字构件类，同理其他关键字。如interface,enum。 在类中使用 - # + 分别对应表示类中的private,protected,public。如果在类中使用 static、abstract关键字，需要使用大括号包裹起来。 备注使用note来实现，可以使用js优化备注的样式,具体可以参考下面的代码。 123456789101112131415161718192021222324@startuml&apos; 简单定义类Aclass classA&apos;定义类Bclass classB&#123; -&#123;static&#125; STATIC:Type -a:A #b:B +c:C +hello():void -word():void&#125;&apos;抽象类Cabstract class classC &#123; + &#123;abstract&#125; method1:void&#125;&apos;备注note right: note on rightnote top of classA : note on top&apos; 复杂备注note top of objectIn java, &lt;size:18&gt;every&lt;/size&gt; &lt;u&gt;class&lt;/u&gt;&lt;b&gt;extends&lt;/b&gt;&lt;i&gt;this&lt;/i&gt; one.end note@enduml 类更多使用 更复杂一些的类的构件参考上图。 使用__内容__来表示分割线，对不同类型的进行分割。在类名后加&lt;? extends xxx&gt; 表示范型,参考下面代码： 123456789101112131415@startumlclass classC &lt;&lt;Serializable&gt;&gt; &#123;__variable__ -a:A #b:B +c:C__methods__ +hello():void -word():void&#125;class classD &lt;? extends List&gt;&#123;&#125;@enduml 关系表示继承与实现 继承指的就是泛化，如图中左表示一样，类A继承于B，由子类实现父类的行为。泛化使用带大三角箭头和实线来表示，表示一种继承关系。 实现指的是特定类实现接口，如图中右表示一样，类implement实现interface,表示实现类实现接口类的关系。同样会由子类实现接口类中的行为。实现使用带大三角的箭头和虚线来实现。 无论是继承还是实现，箭头都执行夫类，也就是被实现类。 依赖与关联 使用plantUML代码实现： 1234567891011121314151617181920212223242526@startuml&apos;依赖与关联Class X&apos; 依赖关系X ..&gt; Y :&quot;依赖关系&quot;class A&apos; 单向关联 A关联BA--&gt; B :&quot;单向关联&quot;&apos; 双向关联class CC -- D : &quot;双向关联&quot;&apos; 自关联class FF --&gt; F:&quot;自关联&quot;&apos; 聚合关系class G &#123;List&lt;H&gt; h&#125;G &quot;n&quot; o-- &quot;1&quot; H : &quot;组合关系&quot;&apos; 组合关系class K &#123;List&lt;L&gt; l&#125;K &quot;n&quot;*--&quot;1&quot; L :&quot;聚合关系&quot;@enduml 一、依赖关系依赖是一种使用的关系，代码中体现到依赖的关系的情况:局部变量、方法的参数或者对静态方法的调用,依赖是最弱的一种关联。依赖关系使用虚线和普通的小箭头来实现，箭头指向被依赖的对象。如图中的x依赖y一样，所以指向y,这个被x依赖的对象。 二、关联关系关联是拥有的关系，如玩家与游戏中的角色一样。关联可能是单向的，也可能是双向的，也同样能够自己关联自己。代码中体现到关联的关系的情况：成员变量。关联关系使用实线和小尖头来实现，箭头指向被关联的对象。 三、组合关系组合关系是整体与部分的关系，但是如果整体不存在，那部分也不能存在。就如同公司与部门一样，公司解散了，部门也就不存在了。和关联关系相同，在代码中的体现也是成员变量。组合关系使用空心的菱形和实线来表示。 四、聚合关系聚合关系是整体与部分的关系，但是和组合关系不同的是，聚合关系中的部分可以脱离整体而存在，就如同麦当劳中的套餐与汉堡一样。在代码中的体现同样是成员变量。聚合关系使用实心的菱形和实线来表示。 所以可以说聚合关系和组合关系是关系更加确定，更加紧密的关联关系。 各关系的强弱顺序 泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖 PlantUML支持更多的更复杂的情景下的图形绘制，具体可以查看PlantUML的中文网站。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之备忘录模式]]></title>
    <url>%2F2019%2F06%2F25%2F2019-06-25-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之备忘录模式📕不违反封装的情况下，捕获并外化对象的内部状态，以便稍后可以将对象恢复到此状态。 应用场景必须保存对象状态的快照，以便以后可以将其恢复到该状态 模式结构模式结构分为三种结构： 发起人 (Originator)负责创建一个有内部状态的备忘录对象。 负责人 (Caretaker)负责保存备忘录内容，但是不检查备忘录的内容。 备忘录 (Memento)保存发起人的内部的状态。 上图中的ActionGame为负责人，负责保存状态，Player为发起人负责主动记录备忘录。 实际场景在玩单机游戏的时候，在通过一个关卡的时候，系统会记录你当时的状态信息，如果下一关没通过，会自动还原到上一个记录点从新开始。这种情况下就可以使用备忘录模式记录存档状态，并在适当的时候还原状态。针对此处场景，使用下面代码还原。 代码作为发起者的Player12345678910111213141516171819202122232425262728public class Player &#123; // 游戏状态 private GameState gameState; Player(GameState gameState) &#123; this.gameState = gameState; &#125; // 设置状态 void setGameState(GameState gameState) &#123; this.gameState = gameState; &#125; //获取状态 GameState getGameState() &#123; return gameState; &#125; // 创建存档记录 Memento createMemento()&#123; return new Memento(gameState); &#125; // 回退存档记录 void retrieveMemento(Memento memento)&#123; this.gameState = memento.getGameState(); &#125;&#125; 作为负责人的ActionGame123456789101112131415161718192021222324252627282930public interface Game &#123; void storeGamePoint(Memento memento); Memento retrieveGamePoint();&#125;public class ActionGame implements Game &#123; private Memento memento; /** * 存档记录 * @Author nanyin * @Date 17:31 2019-06-26 * @param memento 1 * @return void **/ @Override public void storeGamePoint(Memento memento) &#123; this.memento = memento; &#125; /** * 还原记录点 * @Author nanyin * @Date 17:32 2019-06-26 * @return Memento **/ @Override public Memento retrieveGamePoint() &#123; return this.memento; &#125;&#125; 作为备忘录的Memento1234567891011121314public class Memento &#123; private GameState gameState; Memento(GameState gameState) &#123; this.gameState = gameState; &#125; GameState getGameState() &#123; return gameState; &#125;&#125;public enum GameState &#123; DIE,SUCCESS&#125; 客户端程序1234567891011121314151617public class App &#123; public static void main(String[] args) &#123; //创建一个动作类型的游戏 Game actionGame = new ActionGame(); //玩家通关 Player player = new Player(GameState.SUCCESS); //存档 Memento memento = player.createMemento(); actionGame.storeGamePoint(memento); //此时玩家阵亡 player.setGameState(GameState.DIE); System.out.println(player.getGameState()); //需要从上一次游戏存档中加载原来的玩家状态 player.retrieveMemento(actionGame.retrieveGamePoint()); System.out.println(player.getGameState()); &#125;&#125; 在游戏存档后死亡，再重复读存档，得到之前存档之前的状态。游戏不会主动存档和读取存档，只会记录存档中的内容，而玩家会主动从游戏中读取存档，然后恢复到存档的状态。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之状态模式]]></title>
    <url>%2F2019%2F06%2F19%2F2019-06-19-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之状态模式状态模式是对象的行为模式。状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。 应用场景 对象的行为取决于其状态，并且必须根据该状态在运行时更改其行为。 通常，几个操作将包含相同的条件结构。State模式将条件的每个分支放在一个单独的类中。可以将对象的状态视为一个对象，它可以独立于其他对象而变化 概括来说，状态模式将行为包装到具体的状态对象中。每个状态对象是抽象状态的子类。状态模式意图是在改变对象的内部状态的时候，行为随之改变。 模式结构状态模式分为三种结构：环境角色、抽象状态角色、具体状态角色 代码电灯有两种基本行为 开启、关闭。但是有两个状态，正常和坏掉的状态。将共同的行为封装到统一的状态接口中，再根据不同的状态，创建子类完成不同状态形成不同的行为。 灯再正常状态下能够正常开启，正常关闭。等在坏掉的状态下，不能开启和关闭。状态模式就是根据这个逻辑抽离行为，将具体行为包装到具体状态对象中。 抽象状态角色1234public interface State &#123; void open(); void close();&#125; 具体状态角色1234567891011121314151617181920212223public class NormalState implements State&#123; @Override public void open() &#123; System.out.println("电灯开了！"); &#125; @Override public void close() &#123; System.out.println("电灯关了！"); &#125;&#125;public class ErrorState implements State &#123; @Override public void open() &#123; System.out.println("电灯开不了！"); &#125; @Override public void close() &#123; System.out.println("电灯关不了！"); &#125;&#125; 环境角色12345678910111213141516171819public class Context &#123; //状态参数 State state; public Context(State state) &#123; this.state = state; &#125; public void requestToOpen() &#123; state.open(); &#125; public void requestToClose() &#123; state.close(); &#125; //状态变化 public void changeStageTo(State state)&#123; this.state = state; &#125;&#125; 客户端测试1234567891011public class App &#123; public static void main(String[] args) &#123; Context context = new Context(new NormalState()); context.requestToOpen(); context.requestToClose(); //将状态变更为坏的状态 context.changeStageTo(new ErrorState()); context.requestToOpen(); context.requestToClose(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2019%2F06%2F19%2F2019-06-24-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之观察者模式观察者模式是对象的行为模式，又叫“发布-订阅模式”。由名字就能够得知，观察这模式构造了一个发布者和订阅者。 观察者模式定义对象之间的一对多依赖关系，以便当一个对象更改状态时，将自动通知和更新其所有依赖项。在观察者模式中，主动发生改变的是发布者称为主题，而被动收到发布者信息的订阅者称为观察者对象，可以根据需要添加/减少具体主题的观察者，实现主题和观察者之间的松耦合。 应用场景 当设计中有两种不同方面的抽象，并且是有依赖关系的，这时将两个抽象分别封装到具体的类中，这样就能够独立的改变和重用这些对象。在观察者模式中两种抽象指的就是抽象主题和抽象观察者。 当一个对象需要更改时，涉及到更改其他类型的其他对象，并且这些对象的数量多且不确定的时候。 当一个对象改变时，其他对象能够得到这个对象已经改变的通知，而不必知道这些对象具体是什么。也就是说要达到这个改变的对象和通知的对象的松耦合。 所以综上: 当希望一个对象改变的同时，多个对象能够得到通知，一块进行变更时，可以使用观察者模式对系统设计 模式结构 上图中： Weather为抽象主题类，能够将观察者Observer构成一个list结构,从而能够达到Weather改变的时候可以循环表中的观察者，发送通知。并且作为抽象类实现了添加，移除观察者方法。 BeijingWeather为具体主题类，实现了Weather类。 Observer作为抽象观察者类，作为所有观察者的通用接口，其中定义update方法作为更新状态的接口。通过这个接口和Weather类交互来获取状态通知。 WeatherObserverA与WeatherObserverB作为具体观察者类，实现类观察者接口。统一接受通知并更新自身状态。 代码第一部分：抽象主题类123456789101112131415161718192021222324252627282930// 状态枚举类public enum WeatherState &#123; SUNNY_DAY, CLOUDY_DAY, RAINY_DAY,&#125;// 抽象主题类public abstract class Weather &#123; protected WeatherState weatherState; // 观察者集合 private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); public Weather addObserver(Observer observer)&#123; observerList.add(observer); return this; &#125; public void removeObserver(Observer observer)&#123; observerList.remove(observer); &#125; // 通过主题更改从而在该主题上注册的观察者能够同时能到通知 public void notifyObserver()&#123; for (Observer o:observerList ) &#123; o.update(this.weatherState); &#125; &#125;&#125; 第二部分：具体主题类12345678910public class BeijingWeather extends Weather &#123; BeijingWeather(WeatherState weatherState) &#123; this.weatherState = weatherState; &#125; //作为更新主题的接口 public void changeState(WeatherState we)&#123; this.weatherState = we; &#125;&#125; 第三部分：抽象观察者1234public interface Observer &#123; // 更新接口 void update(WeatherState weatherState);&#125; 第四部分： 具体观察者123456public class WeatherObserverA implements Observer &#123; @Override public void update(WeatherState weatherState) &#123; System.out.println("observer A get new weather message is " + weatherState.toString()); &#125;&#125; 最后调用12345678910public class App &#123; public static void main(String[] args) &#123; // 定义主题 Weather weather = new BeijingWeather(WeatherState.SUNNY_DAY); //添加观察者 weather.addObserver(new WeatherObserverA()).addObserver(new WeatherObserverB()); //通知所有观察者 weather.notifyObserver(); &#125;&#125; 结果：最后注册在主题上的所有观察者都收到了通知。 12observer A get new weather message is SUNNY_DAYobserver B get new weather message is SUNNY_DAY]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用idea时在dock栏一直存在java图标和控制台乱码问题]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-18-Mac%E4%B8%8Bidea%E5%9C%A8Dock%E6%A0%8F%E4%B8%80%E7%9B%B4%E5%AD%98%E5%9C%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Mac下使用Idea相关问题使用tomcat启动IDEA项目后，dock栏一直存在JAVA图标问题在mac上启动idea后，存在dock栏一直存在JAVA图标的问题，如下图： 解决方式： 打开Run/Debug configurations,在vm options中添加如下内容： 1-Dapple.awt.UIElement=true 启动IDEA后，控制台乱码 解决方式和上一个问题相同，同样在vm options中增加参数，具体参数如下： 1-Dfile.encoding=UTF-8]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模版模式]]></title>
    <url>%2F2019%2F06%2F17%2F2019-06-17-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之模版方法模式模版模式是类的行为模式，将部分逻辑以具体方法来实现，将其他方法声明为抽象方法来让子类来实现。不同的子类实现的方法逻辑不同，从而整体的逻辑有所差异。 这里涉及到两个角色： 一、抽象模板(Abstract Template)角色有如下责任： - 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作， 它们是一个顶级逻辑的组成步骤。 - 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架， 而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。二、具体模板(Concrete Template)角色又如下责任： - 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 - 每一个抽象模板角色都可以有任意多个具体模板角色与之对应， 而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现， 从而使得顶级逻辑的实现各不相同。应用场景 实现不变的部分一次，并将其他留给子类来实现可能需要变化的行为。 需要简化代码，分离出公共的部分，抽离出一个公共的模板方法来替换所有的代码。 控制子类扩展。定义在特定点调用“钩子”操作的模板方法，从而仅允许在那些点进行扩展。 模式结构这里使用到模拟servlet中的httpServlet方法（简单的模拟方法中用到的模版方法）。定义一个公共的模版方法抽象类HttpServletTemplate，其中有两个钩子方法doGet和doPost，所谓的钩子方法就是需要由子类实现的方法。还有一个具体方法service来实现模版调用的作用。 模拟两个子类实现HttpServletTemplate实现两个钩子方法。 客户端App在调用的时候，直接调用两个子类的父类中的实现方法service实现调用模版。 代码抽象模版类1234567891011121314151617public abstract class HttpServletTemplate &#123; public void service(HttpRequestMethod method)&#123; if(method.equals(HttpRequestMethod.METHOD_GET))&#123; System.out.println("so something 1"); doGet(); System.out.println("so something 2"); &#125;else if(method.equals(HttpRequestMethod.METHOD_POST))&#123; doPost(); &#125;else &#123; System.out.println("do nothing!"); &#125; &#125; protected void doGet()&#123;&#125;; protected void doPost()&#123;&#125;;&#125; 具体模版类123456789101112131415161718192021public class GetClient extends HttpServletTemplate &#123; @Override protected void doGet() &#123; System.out.println("this is my get methods!"); &#125;&#125;public class PostClient extends HttpServletTemplate &#123; @Override protected void doGet() &#123; this.doPost(); &#125; @Override protected void doPost() &#123; System.out.println("this is my post methods!"); &#125;&#125;// 请求类型枚举类public enum HttpRequestMethod &#123; METHOD_GET,METHOD_POST,METHOD_DELETE&#125; 客户端调用1234567891011public class App &#123; public static void main(String[] args) &#123; //声明post客户端 PostClient post = new PostClient(); //调用模版 post.service(HttpRequestMethod.METHOD_POST); GetClient get = new GetClient(); get.service(HttpRequestMethod.METHOD_GET); get.service(HttpRequestMethod.METHOD_POST); &#125;&#125; 其实模版方法模式是创建一个算法的骨架，具体的内容由子类去填充的这个过程。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之访问者模式]]></title>
    <url>%2F2019%2F06%2F15%2F2019-06-15-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之访问者模式访问者模式是一种复杂的行为模式。表示要对对象结构的元素执行的操作。访问者允许对对象结构中的节点定义新操作，而无需更改其操作的元素的类。 适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。 应用场景当遇到如下情况时，可以优先考虑使用访问者模式： 对象结构中包含许多具有不同接口的对象类，并且希望对依赖于其具体类的这些对象执行操作。 需要对对象结构中的对象执行许多不同且不相关的操作，并且希望避免使用这些操作“污染”它们的类。这时就可以定义多个visitor类来完成对多个对象节点的处理。 定义对象结构的类很少改变，但是你经常想要在结构上定义新的操作。 模式结构举个例子：在公司中，需要统计打卡记录和绩效，分别有行政部门和财务部门来实现。并且将来可能有质量部门监测研发和实施人员的工作质量。但是对研发和实施人员的考核标准有所不同。 一、类图 OperateStructure作为对象OperateNode的数据结构,并且实现类OperateNodeA和OperateNodeB行为方法有各自的实现。并且想基于这个相对固定的数据结构实现多种不同的操作（visitor）。这样在增加visitor的时候不必考虑数据结构会发生变更。 二、时序由于调用过程比较不容易看透，这里我先使用时序图来说明调用顺序 代码实例根据类图可以看出，访问者模式分为五部分：抽象节点角色 、具体节点角色 、抽象访问者角色 、具体访问者角色 、结构对象角色 抽象节点角色： 1234public abstract class OperateNode &#123;// 定义节点内都需要实现的方法 abstract void accept(Visitor visitor);&#125; 具体节点角色： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 具体节点A 在实例中对应研发人员class OperateNodeA extends OperateNode &#123; //绩效系数 private static final double COEFFICIENT = 1.2; private int workDate; OperateNodeA(int workDate) &#123; this.workDate = workDate; &#125; @Override void accept(Visitor visitor) &#123; visitor.visit(this); &#125; int attendance()&#123; return workDate; &#125; double performance()&#123; return workDate * COEFFICIENT; &#125;&#125;// 具体节点B，在实例中对应运维人员class OperateNodeB extends OperateNode &#123; private static final int COEFFICIENT = 1; private int workDate; OperateNodeB(int workDate) &#123; this.workDate = workDate; &#125; @Override void accept(Visitor visitor) &#123; visitor.visit(this); &#125; int attendance()&#123; return workDate; &#125; double performance()&#123; return workDate * COEFFICIENT; &#125;&#125; 抽象访问者角色 12345//针对结构中每一个节点分别进行各自的操作public interface Visitor &#123; void visit(OperateNodeA operateNodeA); void visit(OperateNodeB operateNodeB);&#125; 具体访问者角色 1234567891011121314151617181920212223242526272829303132// 行政人员结算考勤public class VisitorA implements Visitor &#123; // 需要对实施人员增加路上的考勤时间 模式为2 private static final int BASIC = 2; @Override public void visit(OperateNodeA operateNodeA) &#123; int att = operateNodeA.attendance(); System.out.println("本月该研发人员考勤为"+att + "天"); &#125; @Override public void visit(OperateNodeB operateNodeB) &#123; int att =operateNodeB.attendance() + BASIC; System.out.println("本月该实施人员考勤为"+att + "天"); &#125;&#125;//财务人员结算绩效public class VisitorB implements Visitor &#123; // 研发需要添加额外绩效 private static final int EXTRA = 2; @Override public void visit(OperateNodeA operateNodeA) &#123; double att = operateNodeA.performance() + EXTRA; System.out.println("本月该研发人员绩效为 :"+att ); &#125; @Override public void visit(OperateNodeB operateNodeB) &#123; double att =operateNodeB.performance() ; System.out.println("本月该研发人员绩效为 :"+att ); &#125;&#125; 结构对象结构 12345678910111213141516public class OperateStructure &#123; // 定义结构体 private List&lt;OperateNode&gt; list = new ArrayList&lt;&gt;(); void add(OperateNode operateNode)&#123; list.add(operateNode); &#125; //对结构体中的对象实现接收访问操作 void action(Visitor visitor)&#123; for (OperateNode operateNode : list)&#123; // 目的就是使用双重分派调用来实现 // 节点接受访问者与访问者访问节点的操作 operateNode.accept(visitor); &#125; &#125;&#125; 客户端调用 1234567891011public class App &#123; public static void main(String[] args) &#123; Visitor visitorA = new VisitorA(); Visitor visitorB = new VisitorB(); OperateStructure structure = new OperateStructure(); structure.add(new OperateNodeA(22)); structure.add(new OperateNodeB(22)); structure.action(visitorA); structure.action(visitorB); &#125;&#125; 结果 1234本月该研发人员考勤为22天本月该实施人员考勤为24天本月该研发人员绩效为 :28.4本月该研发人员绩效为 :22.0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2019%2F06%2F14%2F2019-06-14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之代理模式代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 应用场景 远程代理不同地址空间的对象，都当作本地化对象来处理 控制对象的访问权限。 当遇到一下情况是可以使用代理模式： 想控制对另一个对象的访问 懒加载 控制日志输出 计算对象引用 控制网络链接问题 代理模式模式结构浴室分为男浴室和女浴室，其中前台判断能够进入浴室的前提是没有皮肤病，如有没有，才让进入浴室。这里的前台就是一个代理，它代理来浴室，用来判断能否进入浴室的权限。这就是代理的作用。 代理模式和装饰者模式比较容易混淆。需要记住的是，两者的功能区别在于，代理模式改变的是对象的职能，控制对象的行为。而装饰者模式是对职能的增加和减少。使用场景上有所不同。 代码代理模式大致能够分为三部分：抽象职能类，代理类，被代理类 第一部分：抽象职能类 123456789101112131415161718192021222324252627282930313233343536// Person 基本信息类 和性别枚举 public class Person &#123; private String name ; private SexEnum sex; //是否有皮肤病 private int hasSkinDisease; public Person(String name, SexEnum sex, int hasSkinDisease) &#123; this.name = name; this.sex = sex; this.hasSkinDisease = hasSkinDisease; &#125; public String getName() &#123; return name; &#125; public SexEnum getSex() &#123; return sex; &#125; public int getHasSkinDisease() &#123; return hasSkinDisease; &#125;&#125;public enum SexEnum &#123; MALE,FEMALE&#125;//抽象职能abstract class BathRoom &#123; // 去澡堂泡澡 abstract BathRoom enterBathroom(Person person);&#125; 第二部分：被代理类 1234567891011public class MaleBathRoom extends BathRoom &#123; @Override public BathRoom enterBathroom(Person p) &#123; String sexName = ""; if(SexEnum.MALE.equals(p.getSex()))&#123; sexName = SexEnum.MALE.toString(); System.out.println("name : "+ p.getName() +" sex: "+ sexName +" go bath for male !"); &#125; return this; &#125;&#125; 第三部分：代理类 12345678910111213141516171819public class BathRoomProxy extends BathRoom &#123; BathRoom bathRoom; public BathRoomProxy(BathRoom bathRoom) &#123; this.bathRoom = bathRoom; &#125; @Override public BathRoom enterBathroom(Person person) &#123; if (person.getHasSkinDisease() == 0) &#123; this.bathRoom.enterBathroom(person); &#125; else &#123; System.out.println(person.getName() + " has disease."); &#125; return this; &#125;&#125; 客户端调用： 123456789public class App &#123; public static void main(String[] args) &#123; Person p1 = new Person("1",SexEnum.MALE,0); Person p2 = new Person("2",SexEnum.MALE,1); BathRoomProxy bathRoomProxy = new BathRoomProxy(new MaleBathRoom()); bathRoomProxy.enterBathroom(p1).enterBathroom(p2); &#125;&#125; 结果： 12name : 1 sex: MALE go bath for male !2 has disease.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之享元模式]]></title>
    <url>%2F2019%2F06%2F13%2F2019-06-13-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之享元模式享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。它用于通过尽可能多地与类似对象共享来最小化内存使用或计算开销。 应用场景 应用中需要大量的对象，大量的对象可能造成存储对象的开销。 对象变化的状态大多是外部状态。一旦外部状态被移除，许多对象组可被相对较少的共享对象替换。这也就是享元模式利用的点。 因为在享元模式中对象是共享的，所以在含义上的不同对象使用equels实际返回的是true。 享元模式结构享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。 内蕴状态决定对象本身的状态，不会随着环境的变化而变化，而外蕰状态是由客户端将状态传递给享元对象的，外蕴状态类似同一个对象的不同的行为，内蕴状态和外蕰状态是相互独立，互不影响的。 享元模式主要这几三个部分：抽象享元类，具体享元类和享元工厂类。具体可以参考下面代码。 代码在Java中，String类就符合享元模式，string a = &quot;aa&quot; 和 string b =&quot;aa&quot; 是相等的。 在下面例子中，构造抽象享元类“MyString” 和它的具体实现类，使用到相同的对象，因为享元模式，可以对这些对象进行共享使用。 第一部分：抽象享元类 1234567public interface MyString &#123; void create(String outerState);&#125;//枚举类public enum InstanceType &#123; INSTANCE1,INSTANCE2&#125; 第二部分：具体享元类 12345678910111213141516171819202122232425262728293031public class StringIns1 implements MyString &#123; // 内部状态，不可随时变化的 String innerState; public StringIns1(String innerState) &#123; this.innerState = innerState; &#125; @Override public void create(String outerState) &#123; System.out.println("create instance 1 -&gt; innerState:"+this.innerState); //外部状态，需要客户端传进来，这个值是可变化的 System.out.println("create instance 1 -&gt; outerState:"+outerState); &#125;&#125;public class StringIns2 implements MyString &#123; String innerState; public StringIns2(String innerState) &#123; this.innerState = innerState; &#125; @Override public void create(String outerState) &#123; System.out.println("create instance 2 -&gt; innerState:"+this.innerState); System.out.println("create instance 2 -&gt; outerState:"+outerState); &#125;&#125; 第三部分：享元工厂类 12345678910111213141516171819202122public class FlyWeight &#123; Map&lt;InstanceType,MyString&gt; store; FlyWeight() &#123; store = new HashMap&lt;&gt;(); &#125; public MyString factory(InstanceType instanceType)&#123; MyString curr = store.get(instanceType); if(curr == null)&#123; // 如果对象不存在，新建对应的对象 if(instanceType.equals(InstanceType.INSTANCE1))&#123; // 根据内部状态决定生成哪个类型的子类 curr= new StringIns1(instanceType.toString()); &#125; else if(instanceType.equals(InstanceType.INSTANCE2))&#123; curr= new StringIns2(instanceType.toString()); &#125; &#125; store.put(instanceType,curr); return curr; &#125;&#125; 第四部分：客户端调用 12345678910public class App &#123; public static void main(String[] args) &#123; FlyWeight flyWeight = new FlyWeight(); MyString ins1 = flyWeight.factory(InstanceType.INSTANCE1); MyString ins2 = flyWeight.factory(InstanceType.INSTANCE1); System.out.println(ins1.equals(ins2));//true 是同一个对象 内部状态相同 ins1.create("*****"); //针对外部状态打印不同内容 ins2.create("-----"); &#125;&#125; 结果： 12345truecreate instance 1 -&gt; innerState:INSTANCE1create instance 1 -&gt; outerState:*****create instance 1 -&gt; innerState:INSTANCE1create instance 1 -&gt; outerState:-----]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之外观模式]]></title>
    <url>%2F2019%2F06%2F12%2F2019-06-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之外观模式外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，使子系统更容易使用。 应用场景 因为子系统随着发展会变更的更复杂，客户端想更简单统一给子系统建立一个公共的调用方式。这样即使子系统的再增加可重用性而变得更加复杂，客户端也不必知道，因为客户端往往不需要针对某一个子系统进行特定的定制化。 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。 模式结构外观模式中客户端依靠Facade类来调用多个子系统，来达到简化客户端调用的目的。 例子中，每次开机的时候都要启动mysql,apache服务，两个还好，要是有更多服务岂不是很恼人，每次都要敲一大堆命令来开启服务。这时候可以使用外观模式，将所有服务加入到外观类中，每次开机只用调用外观类中的接口就行了。来达到简化客户端使用的目的。 代码第一部分：子系统接口 123456789101112131415161718192021222324252627282930313233343536373839public interface Services &#123; void start(); void stop(); void restart();&#125;// mysql 服务public class MysqlService implements Services &#123; @Override public void start() &#123; System.out.println("mysql is started"); &#125; @Override public void stop() &#123; System.out.println("mysql is stopped"); &#125; @Override public void restart() &#123; System.out.println("mysql is restart"); &#125;&#125;// apache 服务public class ApacheService implements Services &#123; @Override public void start() &#123; System.out.println("apache is started"); &#125; @Override public void stop() &#123; System.out.println("apache is stopped"); &#125; @Override public void restart() &#123; System.out.println("apache is restart"); &#125;&#125; 第二部分：外观类 1234567891011121314151617181920212223242526272829public class Facade &#123; List&lt;Services&gt; services; public Facade() &#123; services = new ArrayList&lt;&gt;(); &#125; public void addService(Services services)&#123; this.services.add(services); &#125; public void start()&#123; for (Services services : this.services)&#123; services.start(); &#125; &#125; public void stop()&#123; for (Services services : this.services)&#123; services.stop(); &#125; &#125; public void restart()&#123; for (Services services : this.services)&#123; services.restart(); &#125; &#125;&#125; 第三部分：客户端调用 123456789public class App &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.addService(new MysqlService()); facade.addService(new ApacheService()); facade.start(); facade.stop(); &#125;&#125; 结果： 1234mysql is startedapache is startedmysql is stoppedapache is stopped]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰者模式]]></title>
    <url>%2F2019%2F06%2F10%2F2019-06-10-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之装饰者模式可以动态地将附加职责附加给对象。装饰器为子类化的方式提供了灵活的替代扩展功能。比如做梦梦到了交个女朋友，她的发型，发色，穿着都是根据场景做梦梦到的时候附加上去的。这时，就应该对“女朋友”这个对象实行装饰者模式来动态的、灵活的拓展。 应用场景 动态且透明地向各个对象添加职责的同时不影响其他对象。 灵活的可撤回职责。 有时候需要很多子类来用于支持每种功能的组合，这样每次增加一种功能拓展就要增加很多子类的情况。显然这样是不符合要求的。所以遇到这种多功能拓展时，需要使用装饰者模式来解决。 装饰者模式结构装饰者模式可以大致分为四种结构（本例子中的抽象构件和抽象装饰类为一个）抽象构件，具体构件，抽象装饰类，实际装饰类。 代码第一部分：抽象构件与抽象装饰类 123456789101112// 制造一个假想的“女朋友”public abstract class AbstractGirl &#123; public void dyeHair() &#123; &#125; public abstract void wearClothes(); public void pack() &#123; &#125;&#125; 第二部分：实现组件 12345678910111213141516// 基本的功能实现public class NormalGirl extends AbstractGirl &#123; @Override public void dyeHair() &#123; System.out.println("normal hair"); &#125; @Override public void wearClothes() &#123; System.out.println("normal clothes"); &#125; @Override public void pack() &#123; &#125;&#125; 第三部分：附加装饰类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 工作中的女孩 穿正装public class WorkGirl extends AbstractGirl &#123; AbstractGirl abstractGirl; public WorkGirl(AbstractGirl abstractGirl) &#123; this.abstractGirl = abstractGirl; &#125; @Override public void wearClothes() &#123; abstractGirl.wearClothes(); System.out.println("wearClothes after : "); System.out.println("wear formal clothes"); &#125;&#125;//实际出去逛街的女孩应该是这样的public class FashionGirl extends AbstractGirl &#123; AbstractGirl abstractGirl; public FashionGirl(AbstractGirl abstractGirl) &#123; this.abstractGirl = abstractGirl; &#125; @Override public void dyeHair() &#123; abstractGirl.dyeHair(); System.out.println("dyeHair after : "); System.out.println("dye blue hair"); &#125; @Override public void wearClothes() &#123; abstractGirl.wearClothes(); System.out.println("wearClothes after : " ); System.out.println("wear rock type clothes"); &#125; @Override public void pack() &#123; abstractGirl.pack(); System.out.println("wearClothes after : " ); System.out.println("take fashion pack"); &#125;&#125; 最后客户端的调用： 1234567891011121314public class App &#123; public static void main(String[] args) &#123; //先制造一个整体组件 AbstractGirl normalGirl = new NormalGirl(); normalGirl.dyeHair(); // 为组件添加装饰，比如这里加了个时尚的包包 AbstractGirl fashionHair = new FashionGirl(normalGirl); fashionHair.pack(); //穿一套正装 AbstractGirl workClose = new WorkGirl(fashionHair); workClose.wearClothes(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之桥接模式]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之桥接模式目的在于将抽象与其实现分离，以便两者可以独立变化。独立变化的同时能够根据抽象类的对象关联从而能够将两个继承结构联动起来。就像在两个结构之间建立个桥梁一样进行通信，所以叫桥接模式。 应用场景 如果想避免抽象类与实现的永久绑定，可以在运行时间选择和切换实现类。 抽象类和接口都应该通过子类来进行拓展，在桥接模式中，可以使用子类来进行组合的同时能够独立拓展他们。 接口的实现的变化对客户端无影响。 如果想要在多个对象类中共享实现，并且避免让客户端感知到。 桥接模式结构图 代码主要分为四部分，1.抽象类 2.抽象实现类 3.接口类 4.接口实现类 123456789101112131415161718192021222324252627282930313233343536373839// 抽象类与抽象实现类public abstract class Shape &#123; Colors colors; Shape(Colors colors) &#123; this.colors = colors; &#125; public abstract void buildShape();&#125;// 圆形实现类public class ShapeCircle extends Shape &#123; public ShapeCircle(Colors colors) &#123; super(colors); &#125; @Override public void buildShape() &#123; System.out.println("\n first step : build circle\n and second step:"); colors.paint(); &#125;&#125;//方形实现类public class ShapeSquare extends Shape &#123; public ShapeSquare (Colors colors) &#123; super(colors); &#125; @Override public void buildShape() &#123; System.out.println("\n first step : build Square\n and second step:"); colors.paint(); &#125;&#125; 抽象方法中引用了Colors类变量，使用实现类中的buildShape方法实现具体功能。 1234567891011121314151617public interface Colors &#123; public void paint();&#125;public class ColorBlue implements Colors &#123; @Override public void paint() &#123; System.out.println(" print blue !!"); &#125;&#125;public class ColorRed implements Colors &#123; @Override public void paint() &#123; System.out.println(" paint inner with red !!"); &#125;&#125; 通过使用Color接口，实现类实现Colors中的paint方法实现Color 12345678public class App &#123; public static void main(String[] args) &#123; Shape circle = new ShapeCircle(new ColorBlue()); circle.buildShape(); Shape square = new ShapeSquare(new ColorRed()); square.buildShape(); &#125;&#125; 123456789结果： first step : build circle and second step: print blue !! first step : build Square and second step: paint red !! 上面的例子中，颜色和图形是两个独立不同的维度，两个可以分别变化。将两个维度设计为两个不同的继承的结构，在两个结构之间使用在抽象类中的关联来达到链接的目的，这个链接成为两个继承结构通信的桥梁。所以为桥接模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之适配器模式我们实际中会用到两个不同接口的类的通信,在不修改两个类的前提下,使用新的中间类来完成衔接的过程,这个中间件就是适配器.可以让两个完全不同的接口相互转化. 适配器模式允许在适配器中包装其他不兼容的对象，以使其与另一个类兼容。 就如同生活中买了港版的手机,但是附赠的是三脚插头，而大陆上用的是两脚的，需要一个适配器来将三角插头转换为两脚的。其中这个中间件就是适配器。 应用场景 当你想要这个类，但是类中的接口与想用的接口并不匹配 当想要去创建一个可重用的类，让它与不相关或不可预见的类合作，这个类不必要有兼容的接口 当你需要一系列的子类的时候，如果想要调整这些子类的接口方法的时候，对每一个接口子类化的这种方法是不可行的。这时就可使用适配器适配这些子类的夫类。 结构图 使用client调用适配器，适配器继承与三脚插头，依赖于二脚插头。这样就可以使用三脚插头的接口调用二脚插头的方法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 三角插头 * @Author nanyin * @Date 11:13 2019-06-02 **/public class ThreeLeggedPlug &#123; public void charge()&#123; System.out.println("use three legged plug"); &#125;&#125;/** * 二脚插头 * @Author nanyin * @Date 11:13 2019-06-02 **/public class TwoLeggedPlug &#123; public void fastCharge()&#123; System.out.println("use two legged plug for fast charge !"); &#125;&#125;//适配器 继承三角插头public class TwoLeggedPlugAdapter extends ThreeLeggedPlug &#123; TwoLeggedPlug twoLeggedPlug; // 依赖于二脚插头 public TwoLeggedPlugAdapter() &#123; twoLeggedPlug = new TwoLeggedPlug(); &#125; //使用三角插头的charge方法，调用二脚插头的fastCharge方法 @Override public void charge() &#123; twoLeggedPlug.fastCharge(); &#125;&#125;//某S9港版手机public class S9Plus extends ThreeLeggedPlug &#123; ThreeLeggedPlug threeLeggedPlug; public S9Plus(ThreeLeggedPlug threeLeggedPlug) &#123; this.threeLeggedPlug = threeLeggedPlug; &#125; @Override public void charge() &#123; threeLeggedPlug.charge(); &#125;&#125;//客户端方法public class App &#123; @Test public void testCharge() &#123; // 不使用适配器 使用类三角插头 ThreeLeggedPlug s9Plus = new S9Plus(new ThreeLeggedPlug()); s9Plus.charge(); // 使用二脚插头的适配器 ThreeLeggedPlug s9PlusUseTwoLeggedPlug = new S9Plus(new TwoLeggedPlugAdapter()); s9PlusUseTwoLeggedPlug.charge(); &#125;&#125; 123456结果：use three legged pluguse two legged plug for fast charge !Process finished with exit code 0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之原型模式使用原型实例指定要创建的对象类型，并通过复制此原型来创建新对象.实现方法:通过克隆方法,实现对现有对象的复制克隆. 应用场景 当要在运行时指定要实例化的类时，例如，通过动态加载. 避免构建与产品类层次结构相似的工厂类层次结构 当一个类的实例可以只有几个不同的状态的组合之一时.组装相应数量的原型并克隆它们可能更方便，而不是手动实例化类，每次都有适当的状态. 与对象创建相比,使用克隆成本更低 代码直接由代码看结构,其实克隆的过程就是创建对象的过程 123456789101112131415161718192021222324252627282930/** * 一个细胞 * @Author nanyin * @Date 23:49 2019-06-01 **/public class Cell implements Cloneable&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Cell()&#123; &#125; private Cell(String name) &#123; this.name = name; &#125; @Override protected Cell clone() throws CloneNotSupportedException &#123; super.clone(); return new Cell(name); &#125;&#125; 客户端程序: 1234567891011121314public class App &#123; @Test public void testPrototype()&#123; Cell cell = new Cell(); cell.setName("org"); try&#123; Cell cloneCell = cell.clone(); Assert.assertEquals("org",cloneCell.getName());//pass Assert.assertEquals(cell,cloneCell);//not pass &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之建造者模式将复杂对象的构造与其表示分开，以便相同的构造过程可以创建不同的表示。 比如在玩游戏时的捏人物的时候,创建一个游戏任务最简单的方法时计算机自己生成一个固定的游戏任务,但是想自己构建这个人物细节的时候,这种情况下,人物的生成时一步一步生成的.再当所有类型都选择完成后,才能够创建这个人物. 应用场景 对象足够复杂,创建这个对象的方法应与创建这个对象的组件和组装方式分开. 当构造对象时要求对这个对象具有不同的行为. 建造者模式结构 上图为建造者模式类图:其中CharacterBuilder 和 Characters 中的属性相同,CharacterBuilder 存在的目的就是多种构造不同行为的Characters . 具体可以看下面代码实例 代码角色实体 1234567891011121314151617181920public class Characters &#123; // 角色构造器内有多个角色属性 private String name; private int age; private String sex; private String skill; private String weapon; // 使用构造器来构造实体 其中实体属性有builder中来 public Characters(CharacterBuilder builder) &#123; this.name = builder.getName(); this.age = builder.getAge(); this.sex = builder.getSex(); this.skill = builder.getSkill(); this.weapon = builder.getWeapon(); &#125; public void showCharacterBoard()&#123; System.out.println("人物 ： " + this.name + " 年龄 ：" + this.age + " 性别：" + this.sex + " 技能：" +this.skill + " 武器：" + this.weapon); &#125; &#125; 角色构建器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class CharacterBuilder &#123; // 与角色实体保持相同的属性 private String name; private int age; private String sex; private String skill; private String weapon; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getSex() &#123; return sex; &#125; public String getSkill() &#123; return skill; &#125; public String getWeapon() &#123; return weapon; &#125; //构造基本属性的构造器 public CharacterBuilder buildBasicAttributes(String name , int age, String sex)&#123; //保证姓名不能为空 if(name == null || "".equals(name))&#123; throw new IllegalArgumentException("name can not be empty "); &#125;else &#123; this.name = name; this.age = age; this.sex = sex; &#125; return this; &#125; public CharacterBuilder buildSkill(String skill)&#123; this.skill = skill; return this; &#125; public CharacterBuilder billdWeapon(String weapon)&#123; this.weapon = weapon; return this; &#125; //生成角色实体 public Characters build()&#123; return new Characters(this); &#125;&#125; 客户端类: 12345678910111213public class App &#123; @Test public void testBuildCharacter()&#123; // 链式调用,最后使用build方法新建一个角色实体 Characters characters = new CharacterBuilder() .buildBasicAttributes("jack",18,"man") .buildSkill("Emission laser") .billdWeapon("Laser Cannon") .build(); //打印角色属性面板 characters.showCharacterBoard(); &#125;&#125; 输出结果: 123Connected to the target VM, address: &apos;127.0.0.1:57347&apos;, transport: &apos;socket&apos;人物 ： jack 年龄 ：18 性别：man 技能：Emission laser 武器：Laser CannonDisconnected from the target VM, address: &apos;127.0.0.1:57347&apos;, transport: &apos;socket&apos;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-03-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之组合模式将对象组合成树结构以表示部分整体层次结构。当使用树结构的上层和下层组件属性可能差别很大，所以说一般情况下需要对这两类对象进行分别处理， 但Composite允许客户端统一处理单个对象和对象组合。也就是说可以将叶子组件与整体进行一致性处理，实现的方法是组件和整体实现相同接口。 应用场景 想要表示对象的部分与整体之间的层次结构 想要客户端忽略组合对象和单个对象的区别，使用组合模式会统一处理最后的组合对象。 组合模式结构 最典型的情况就是多级树形菜单和文件夹结构。盗个图 - - 上图，虽然国家，地区，城市属于不同的层级，但是都需要继承同一个接口，是客户端能够统一的调用不同层级的对象。类似多级树形菜单的结构。 代码第一部分：抽象组件 12345678910111213141516171819202122232425262728293031// 这个抽象组件即完成了抽象组件的功能，又完成了“树枝”的功能，能够链接各个叶子节点public abstract class Component &#123; String name; Integer areaLevel; List&lt;Component&gt; list = new LinkedList&lt;&gt;(); public Component(String name, Integer areaLevel) &#123; this.name = name; this.areaLevel = areaLevel; &#125; public void printName()&#123; System.out.println("Name : "+name); &#125;; public void printLevel()&#123; System.out.println("Area Level :" + areaLevel); &#125;; // 这里在抽象类的方法中直接打印子组件（ps:应统一递归输出子组件的子组件） public void printAll()&#123; for (Component p:list ) &#123; System.out.println("子组件："+ p.name); p.printName(); p.printLevel(); &#125; &#125; public void add(Component component)&#123; list.add(component); &#125;;&#125; 第二部分：树叶构件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 国家级别树叶节点public class Country extends Component &#123; List&lt;Province&gt; provinceList = new LinkedList&lt;&gt;(); public Country(String name, Integer areaLevel) &#123; super(name, areaLevel); &#125; @Override public void printName() &#123; System.out.println("Country Name :" + this.name);; &#125; public void add(Province province)&#123; provinceList.add(province); &#125; public void printAll()&#123; System.out.println("当前组件:"+name + "等级："+ areaLevel); for (Province p:provinceList ) &#123; p.printAll(); &#125; &#125; @Override public void printLevel() &#123; System.out.println("Country Level :" + this.areaLevel); &#125;&#125;// 省级别树叶节点public class Province extends Component&#123; List&lt;City&gt; cityList = new ArrayList&lt;&gt;(); public Province(String name, Integer areaLevel) &#123; super(name, areaLevel); &#125; @Override public void printName() &#123; System.out.println("Province Name :" +this.name); &#125; public void add(City city)&#123; cityList.add(city); &#125; public void printAll()&#123; System.out.println("当前组件:"+name + "等级："+ areaLevel); for (City p:cityList ) &#123; p.printAll(); &#125; &#125; @Override public void printLevel() &#123; System.out.println(""); &#125;&#125;// 市级别树叶节点public class City extends Component &#123; public City(String name, Integer areaLevel) &#123; super(name, areaLevel); &#125; @Override public void printName() &#123; System.out.println("City Name :" + this.name); &#125; @Override public void printLevel() &#123; System.out.println("City Level " + this.areaLevel); &#125; public void printAll()&#123; System.out.println("组件："+ this.name); &#125;&#125; 第三部分：客户端 12345678910public class App &#123; public static void main(String[] args) &#123; Country zhongguo = new Country("china", 0); City langfang = new City("langfang", 2); Province hebei = new Province("hebei", 1); zhongguo.add(hebei); hebei.add(langfang); zhongguo.printAll(); &#125;&#125; 123当前组件:china 等级：0当前组件:hebei 等级：1组件：langfang]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F05%2F30%2F2019-05-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式意在保证一个类只有一个实例,并提供一个全局访问点. 通过将类的构造器私有化,只向外提供一个单独的创建唯一对象的方法来实现一个类只创建一个对象.主要有三种实现 1. 饿汉模式 2. 懒汉模式 3.使用枚举实现单例.下面通过具体实例来分析如何在多线程的情况下仍能满足单例模式创建对象. 饿汉模式12345678910111213public class Singleton &#123; private Singleton()&#123;&#125;; //1. 使用静态变量// private static Singleton singleton = new Singleton(); //2.使用静态代码块 未使用时造成内存空间浪费 private static Singleton singleton; static &#123; singleton = new Singleton(); &#125; public Singleton newInstance()&#123; return singleton; &#125;&#125; 这种方式不会影响到多线程的线程安全问题，因为类的装载机制在初始化对象的时候是保证不会有第二个线程进入的。但是有个很大的弊端是他不是lazy-loading的，这回产生资源的浪费，比如创建完对象后，自始至终没用过。所以不推荐使用 懒汉模式123456789101112131415161718192021public class Singleton &#123; private void Singleton()&#123;&#125; private static Singleton singleton; // 普通的线程不安全的 public Singleton newInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125; //2.静态内部类 一方面能够达到lazy-loading的效果，另一方面能够保证线程安全，因为jvm保证初始化的时候别的线程是不能进入的 private static class newSingleton&#123; private static final Singleton INSTANCE = new Singleton(); &#125; public Singleton newInstanceInnerClass()&#123; return newSingleton.INSTANCE; &#125;&#125; 上面代码的第一种是不能保证线程安全的，多线程下会导致失效。而第二种使用静态内部类的方式实现能够实现线程安全得宜于类的加载机制，类似饿汉模式。但同时具有lazy-Loading的特性。是常用的单例模式用法。 double-check双重锁双重锁结构只是为了满足多线程安全而建立的,是一种特殊的懒汉模式,思想同懒汉模式相同. 1234567891011121314151617public class DoubleCheck &#123; private void DoubleCheck()&#123;&#125; private volatile DoubleCheck doubleCheck; //使用volatile保证原子性，防止重排序 public DoubleCheck newInstance()&#123; if(doubleCheck == null)&#123; // 当两个线程同时到这步 a先进同步块，在a进入后获得instance后，b获得锁，进入同步块， // 这时候下一个判断就起到作用了，这时候的doubleCheck不为空， // 直接return，否则又️新建了一个对象 synchronized (DoubleCheck.class)&#123; if(doubleCheck == null)&#123; doubleCheck = new DoubleCheck(); &#125; &#125; &#125; return doubleCheck; &#125;&#125; 实际上double-check也是懒汉模式的一种，能够保证线程安全。很完美。。 使用枚举创建单例在stackoverflow中有一个问题What is an efficient way to implement a singleton pattern in Java? 这里的回答引用到了Effective Java 作者 Joshua Bloch对于单例的处理方式:使用枚举 12345678public enum SingletonEnum &#123; INSTANCE; private final String[] favoriteSongs = &#123; "Hound Dog", "Heartbreak Hotel" &#125;; public void printFavorites() &#123; System.out.println(Arrays.toString(favoriteSongs)); &#125;&#125; 这种方法等同与使用public的构造方法,并且比上面的更加简洁,并且即使面对复杂的反射与序列化也能够保证单一的实例.虽然现实代码中应用的较少,但是这种使用枚举类型是创建单例的最佳方法. 12345public void testEnum() &#123; SingletonEnum singletonEnum = SingletonEnum.INSTANCE; SingletonEnum singletonEnumCopy = SingletonEnum.INSTANCE; Assert.assertEquals(singletonEnum, singletonEnumCopy); //通过&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用idea对spring boot应用进行热部署]]></title>
    <url>%2F2019%2F05%2F29%2F2019-02-17-%E4%BD%BF%E7%94%A8IDEA%E8%AE%BE%E7%BD%AEspringboot%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[使用idea对spring boot应用进行热部署POM在pom.xml中添加maven依赖123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这行必填 --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 并且在后面的插件配置中配置dev123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--如果没有该项配置，devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; IDEA在IDEA中添加配置如下 打开 setting ,搜索 compiler 后，把 Build Project automaticial 选项勾上 使用 ctrl+shift+A 快捷键打开窗口，并搜索 Registry... 。勾选 compiler.automake.allow.when.app.running]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用springboot构建jpa+springdata+rest应用的基本配置过程]]></title>
    <url>%2F2019%2F05%2F29%2F2019-01-30-%E5%88%A9%E7%94%A8springboot%E6%9E%84%E5%BB%BASpringData%2BJAP%2BRestFul%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[利用springboot构建jpa+springdata+rest应用的基本配置过程前述利用SpringBoot整合springData+JPA应用非常方便，所以本着学习的目的来构建一个基本的web应用，配置起来非常简单。下面来说说配置过程和踩过的坑。 过程后端配置因为我使用的是IDEA的spring initalizer，勾选如下： Rest Repositories Thymeleaf JPA H2 Lombok 需要ide下载插件使用 以前在配置spring MVC接口时，往往会浪费很长时间配置rest地址，springdata解决了这个一遍又一遍麻烦的过程。 首先配置实体类任何基于Spring Data REST的应用程序的基石都是域对象。其中的@Id等都是JPA语法，具体用法可以看上一篇文章。 12345678910111213141516171819@Entity@Getter@Setter@Table(name = &quot;user&quot;)public class User &#123; @Id private Long id; @Column(name = &quot;username&quot;,nullable = true,length = 255) private String username; @Column(name = &quot;password&quot;,nullable = true,length = 255) private String password; @OneToOne() @JoinColumn(name = &quot;person_id&quot;,nullable = false) private Person person;&#125; 定义一个存储库Spring Data REST应用程序的另一个关键部分是创建相应的存储库定义 12public interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123;&#125; 配置service和controller123456789public class UserServiceImpl implements UserService &#123; @Autowired UserRepository userRepository; @Override public void save(User user) &#123; user.setPassword(...); //定义代码 userRepository.save(user); &#125;&#125; 配置数据库和application.properties1234567891011121314151617# 驱动配置信息spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url = jdbc:mysql://127.0.0.1:3306/jreact?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = 123456spring.datasource.driverClassName = com.mysql.jdbc.Driver#非严格的html解析spring.thymeleaf.mode =LEGACYHTML5# 彩色输出spring.output.ansi.enabled=DETECT# 设置默认引擎spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect#配置自动建表：updata:没有表新建，有表更新操作,控制台显示建表语句spring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true#配置spring data rest的基地址spring.data.rest.base-path=/api 启动应用访问 localhost:8080/api/users 可以查看到如下信息,说明配置成功了。只是表中还没有数据，另外表已经由自动建好，以后如果更新，直接更新程序就好了。 1234567891011121314151617181920&#123; &quot;_embedded&quot; : &#123; &quot;users&quot; : [ ] &#125;, &quot;_links&quot; : &#123; &quot;self&quot; : &#123; &quot;href&quot; : &quot;http://localhost:8080/api/users&#123;?page,size,sort&#125;&quot;, &quot;templated&quot; : true &#125;, &quot;profile&quot; : &#123; &quot;href&quot; : &quot;http://localhost:8080/api/profile/users&quot; &#125; &#125;, &quot;page&quot; : &#123; &quot;size&quot; : 20, &quot;totalElements&quot; : 0, &quot;totalPages&quot; : 0, &quot;number&quot; : 0 &#125;&#125; 前端配置使用react框架作为前端框架，首先下载create-react-app作为开发的脚手架。这里我选用的是meterial-UI的create-react-app，按照文档中的说明来下载并安装。 配置proxy在src目录下新建名称为setupProxy.js的文件，并在文件中写入如下内容： 123456const proxy = require(&apos;http-proxy-middleware&apos;);module.exports = function(app) &#123; app.use(proxy(&apos;/api/&apos;, &#123; target: &apos;http://localhost:8080/&apos; &#125; ));&#125; 其中/api/为访问后端的基地址，target为访问后端的主机地址和端口号 配置router使用npm下载 react-router-dom后，在src目录下新建router文件夹，并创建baseRouter.js文件，引入刚下载的包，基本的文件内容如： 12345678910111213141516171819202122import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Link,Switch &#125; from &quot;react-router-dom&quot;;import Index from &quot;../pages/index&quot;import SignIn from &quot;../pages/login/signIn&quot;import Error404 from &quot;../pages/error/404&quot;const About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;const Users = () =&gt; &lt;h2&gt;Users&lt;/h2&gt;;const AppRouter = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/SignIn&quot; component=&#123;SignIn&#125; /&gt; &lt;Route path=&quot;/About&quot; component=&#123;About&#125; /&gt; &#123;/* when none of the above match, &lt;NoMatch&gt; will be rendered */&#125; &lt;Route component=&#123;Error404&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;);export default AppRouter; 并最后在index.js入口文件中写入 1ReactDOM.render(&lt;AppRouter /&gt;, document.getElementById(&apos;root&apos;)); 这样可以访问localhost:3000的时候可以访问到Index文件内容。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之工厂模式工厂模式分为简单工厂模式,工厂方法模式,抽象工厂方法模式三种,但是其中简单工厂方法其实不在23中设计模式之中,都属于创建型的设计模式. 简单工厂模式简单工厂方法其实不属于工厂模式的,他只是一种设计思路,是一种对接口的编程的习惯而已.简单工厂抽象出一个公共的接口,不同的对象实现这个公共的接口.定义一个工厂类,根据不同的条件来返回不同类型的实例. 简单工厂结构简单工厂的简单类图如下: 代码接口与实现类 1234567891011121314151617public interface Shoes &#123; void getColor();&#125;public class RedShoes implements Shoes &#123; @Override public void getColor() &#123; System.out.println(" is red color shoes"); &#125;&#125; public class WhiteShoes implements Shoes &#123; @Override public void getColor() &#123; System.out.println("is white color shoes"); &#125;&#125; 工厂类 123456789101112public class ShoesFactory &#123; public Shoes getShoes(String color)&#123; if("red".equals(color))&#123; return new RedShoes(); &#125;else if("white".equals(color))&#123; return new WhiteShoes(); &#125;else &#123; return new OtherShoes(); &#125; &#125;&#125; 工厂方法模式创建一个公共的工厂接口类,其中在接口类中定义工厂方法.但是通过实现类去实现结构,在调用的时候通过使用实现类来实例化特定的工厂.也就是说,工厂方法类需要通过子类去实例化建造对象. 工厂方法结构工厂方法的类图如下: 和上面简单工厂类的例子类似,这里同样通过实现鞋子这个接口来创建红鞋子和白鞋子,简单工厂无论白鞋子、红鞋子还是其他颜色的鞋子都是同一个工厂来创建出来的,而 工厂方法是通过具体的白鞋子工厂和红鞋子工厂来分别生产对应的白鞋子和红鞋子. 所以如类图中所展示的一样,RedShoesFactory和WhiteShoesFactroy都实现来接口ShoesFactory,并且在getshoes方法里分别创建对应的RedShoes和WhiteShoes. 工厂方法模式使用场景: 客户端不必要知道它需要创建对象的类,只需要创建完工厂后,从工厂中直接取对应的对象即可. 客户端可以使用指定实现子类来创建对应对象. 代码12345678910111213141516171819202122232425// 鞋子接口与实现同简单工厂中的相同,所以这里省略....public interface ShoesFactory &#123; Shoes getShoes();&#125;public class RedShoesFactory implements ShoesFactory&#123; public Shoes getShoes()&#123; return new RedShoes(); &#125;&#125;public class WhiteShoesFactory implements ShoesFactory&#123; public Shoes getShoes()&#123; return new WhiteShoes(); &#125;&#125;// 客户端调用public class App &#123; public static void main(String[] args) &#123; ShoesFactory redFactory = new RedShoesFactory(); // 只需要创建一个工厂,每次获取红鞋子,只需调用工厂的getShoes方法即可 Shoes redshoes = redFactory.getShoes(); redshoes.getColor(); ShoesFactory whiteFactory = new WhiteShoesFactory(); Shoes whiteshoes = whiteFactory.getShoes(); &#125;&#125; 抽象工厂模式提供用于创建相关或从属的对象族(多个组件,并且组件之间是由必要联系的)的接口，而无需指定其具体类.是对工厂方法的再次延展. 抽象方法结构 代码12345678910111213141516// 鞋底public interface Sole &#123; // 材料 void getMaterial();&#125;// 鞋带public interface Shoelace &#123; // 长度 void length();&#125;public interface ShoesFactory &#123; public Sole createSole(); public Shoelace createShoelace();&#125; Nike工厂需要生产鞋带和鞋底 123456789101112131415public class NikeBrandSole implements Sole&#123; @Override public void getMaterial() &#123; // 橡胶鞋底 System.out.println("rubber"); &#125;&#125;public class NikeBrandShoelace implements Shoelace&#123; @Override public void length() &#123; System.out.println("1 m "); &#125;&#125; 同样的LiNing工厂需要生产鞋带和鞋底 1234567891011121314public class LiNingBrandSole implements Sole &#123; @Override public void getMaterial() &#123; System.out.println("air cushion"); &#125;&#125;public class LiNingBrandShoelace implements Shoelace &#123; @Override public void length() &#123; System.out.println("1.5 m"); &#125;&#125; LiNing和Nike工厂都需要生产各自的鞋带和鞋底 12345678910111213141516171819202122232425public class NikeShoeFactory implements ShoesFactory &#123; @Override public Sole createSole() &#123; return new NikeBrandSole(); &#125; @Override public Shoelace createShoelace() &#123; return createShoelace(); &#125;&#125;public class LiNingShoeFactory implements ShoesFactory &#123; @Override public Sole createSole() &#123; return new LiNingBrandSole(); &#125; @Override public Shoelace createShoelace() &#123; return new LiNingBrandShoelace(); &#125;&#125; 客户端代码,创建工厂,生产各自组件 12345678910public class App &#123; public static void main(String[] args) &#123; ShoesFactory shoesFactory = new NikeShoeFactory(); Shoelace nikeLace = shoesFactory.createShoelace(); Sole nikeSole = shoesFactory.createSole(); nikeLace.length(); nikeSole.getMaterial(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之责任链模式]]></title>
    <url>%2F2019%2F05%2F27%2F2019-05-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之责任链模式责任链模式是一种对象的行为模式.通过为多个对象处理客户端请求的方式,实现降低发送者与接收者之间的耦合性.对象链由一个对象对下一个对象的引用组成一条链,请求在这个链上传递,知道这个链上的某一个对象处理它.下面引用https://java-design-patterns.com/patterns/chain/ 来说明 King只需要下达命令,具体谁来做并不关心,然而这个命令会通过commander, officer,soldier,这三类人只需要来执行各自负责的部分,完成后传递给下一个职责的人就行了.这就是责任链模式.下面根据例子类图来分析责任链中的结构关系. 责任链的结构 抽象处理者 RequestHandler,定义接口方法,使用handlerRequest方法规定实现类通过该方法来规范子类的实现. 具体处理者 OrcCommander和OrcOfficer,通过继承RequestHandler实现其中的handleRequest方法 请求Request,King通过方法将request放入处理者链中,处理者一次执行这个request. 责任链模式的使用环境 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。3、可动态指定一组对象处理请求 示例代码:java-design-patterns RequestHandler 123456789101112131415161718192021public abstract class RequestHandler &#123; private RequestHandler next; public RequestHandler(RequestHandler next) &#123; this.next = next; &#125; public void handleRequest(Request req) &#123; if (next != null) &#123; next.handleRequest(req); &#125; &#125; protected void printHandling(Request req) &#123; System.out.println(&quot;1.&quot;+req.getRequestType() + &quot; 2.&quot;+req.getRequestDescription()); &#125; @Override public abstract String toString(); &#125; ` 具体处理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class OrcCommander extends RequestHandler &#123; public OrcCommander(RequestHandler handler) &#123; super(handler); &#125; @Override public void handleRequest(Request req) &#123; if (req.getRequestType().equals(RequestType.DEFEND_CASTLE)) &#123; printHandling(req); req.markHandled(); &#125; else &#123; super.handleRequest(req); &#125; &#125; @Override public String toString() &#123; return &quot;Orc commander&quot;; &#125;&#125;public class OrcOfficer extends RequestHandler &#123; public OrcOfficer(RequestHandler next) &#123; super(next); &#125; @Override public void handleRequest(Request req) &#123; if (req.getRequestType().equals(RequestType.TORTURE_PRISONER)) &#123; printHandling(req); req.markHandled(); &#125; else &#123; super.handleRequest(req); &#125; &#125; @Override public String toString() &#123; return &quot;Orc officer&quot;; &#125;&#125;```text- Request请求 public class Request { private final RequestType requestType; private final String requestDescription; private boolean handled; public Request(final RequestType requestType, final String requestDescription) { this.requestType = Objects.requireNonNull(requestType); this.requestDescription = Objects.requireNonNull(requestDescription); } public String getRequestDescription() { return requestDescription; } public RequestType getRequestType() { return requestType; } public void markHandled() { this.handled = true; } public boolean isHandled() { return this.handled; } @Override public String toString() { return getRequestDescription(); }} 12- 客户端发起命令者 public class King { private static RequestHandler chain; private void buildChain() { chain = new OrcCommander(new OrcOfficer(null)); } private void makeRequest(Request req) { chain.handleRequest(req); } public static void main(String[] args) { King king = new King(); king.buildChain(); king.makeRequest(new Request(RequestType.DEFEND_CASTLE, “defend castle”)); king.makeRequest(new Request(RequestType.TORTURE_PRISONER, “torture prisoner”)); }} 12]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2019%2F05%2F27%2F2019-05-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java设计模式之策略模式如果存在一种行为在多种情况下的实现，一般情况下可能会使用if...else if...else..来实现。但是每增加一种情况就要增加一种if判断，这样不符合java设计的规范，这时，就可以使用策略模式来替换这种繁琐的if..else 策略设计模式是行为设计模式的一种.当使用多种算法解决一个特殊的任务的时候,客户端决定使用哪种具体算法进行特定的实现. 哪种情况会使用策略模式以下情况可以使用策略模式: 许多相关类只有行为上有所不同,策略模式可以通过相同的行为方法来配置这些类. 当需要使用到算法的变种的时候,当定义不同的行为参数,如果使用类的层次结构实现的时候,可以使用策略模式(当使用方法层次结构的时候就是多态) 客户端不用清楚算法的细节实现,只需关注接口.避免暴露具体的类的实现、特殊算法的数据结构. 一个类定义了多种不同的行为,并且使用杂乱的条件进行判断具体使用哪一个条件,这时候就可以使用策略模式来代替,对不同的策略形成不同的类.可以清晰的表达出类的作用与实现的行为方式. 策略模式结构 如上图定义一个总的Traffic接口,里面有一个go()方法.使用car和walk分别来实现接口,并且实现接口中的go方法. Context类是环境类,持有一个TrafficStrategy的引用,隐藏具体的策略接口的实现,让客户端专注于方法的调用. 代码实现12345678910111213141516public interface TrafficStrategy &#123; void go();&#125;public class WalkStrategy implements TrafficStrategy&#123; @Override public void go() &#123; System.out.println("i am walking"); &#125;&#125;public class CarStrategy implements TrafficStrategy &#123; @Override public void go() &#123; System.out.println("i am driving"); &#125;&#125; context类 12345678910111213141516171819public class Context &#123; private TrafficStrategy trafficStrategy; public Context(TrafficStrategy trafficStrategy) &#123; this.trafficStrategy = trafficStrategy; &#125; public TrafficStrategy getTrafficStrategy() &#123; return trafficStrategy; &#125; public void setTrafficStrategy(TrafficStrategy trafficStrategy) &#123; this.trafficStrategy = trafficStrategy; &#125; public void doStrategy()&#123; trafficStrategy.go(); &#125;&#125; App客户端类 123456public class App &#123; public static void main(String[] args) &#123; Context context = new Context(new CarStrategy()); context.doStrategy(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring重点知识学习]]></title>
    <url>%2F2019%2F05%2F05%2F2019-05-05-Spring_Framework%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring Framework使用spring可以轻易的创建一个企业级应用,它使用Java语言所有的企业级环境中的所有东西,spring是开源的,拥有庞大而活跃的社区来提供持续的支持. Spring Corespring分为多个模块,其中core为其中的一个,里面包含spring的核心技术点 IOC容器(控制反转)IOC也被成为依赖注入,这是由一个对象定义他所依赖的关系的过程.当创建这个bean的时候也同时创建这些依赖供其使用.这样的整个过程就是反转控制的过程,比如说建房子,以前需要砖,瓦,水泥才能建造房子,如果不实用ioc时,就是自己去造砖,造瓦,然后使用.现在使用ioc容器,只需要把砖,瓦,水泥写到清单上,ioc容器自动把这些准备好供使用,省去来自己制造的过程. org.springframework.beans 和 org.springframework.context 是spring实现IOC容器的基础.BeanFactory接口是能够管理任何对象的高级的配置接口,ApplicationContext是BeanFactory的子接口.因为: 更容易和Spring 的AOP特性相结合 消息资源处理,用于国际化问题 事件发布 用于特定的上下文比如web应用程序的WebApplicationContext 简单来说就是BeanFactory提供了基本的功能,而ApplicationContext提供了更多的企业定制化的功能. ApplicationContext代表了IOC容器,提供了初始化、配置、组装beans.通过配置元数据来获取有关初始化..等的指令.这里所指的配置元数据可以通过配置文件,注解或者java代码来实现.通过配置元数据来体现对象和其依赖. 下图为官网提供的spring工作的简化图: SpringBean的生命周期生命周期大概包含这几个阶段: 实例化Bean对象,这时还未进行依赖注入,最后将bean加入到beanwapper中. 设置对象属性.Spring根据BeanDefinition中的信息进行依赖注入.并且通过BeanWrapper提供的设置属性的接口完成依赖注入。 注入Aware接口,检测是否是想相关Aware接口,并装配相关接口的方法. BeanPostProcessor 此时bean已经成功被构造,通过实现这个接口来自定义前置和后置的处理规则. 调用initialzingBean和int-methods,这时对象成功被初始化 最后调用disposableBean的afterpropertiesSet方法和destroy-methods来实现指定对象销毁. Spring AOPAOP的意思是面向切面编程,在理解面向切面前,不得不说面向对象.什么是面向对象,面向对象编程就是将事务对象化,依据对象进行层级化,面向对象通过封装继承多态的方式实现了对象层次结构,但是实际应用时可能会遇到需要横向的进行业务处理,典型的就如日志,因为在实际代码编写时,不能每次在写方法前后都加入相同的代码,这样即浪费时间,又导致代码冗余.所以面向切面编程必不可少. AOP将多个相同的业务代码整合,形成一个通用的“切面”,通过切面可以分割出“核心关注点”和“横切关注点”,核心关注点就是实际的核心业务关注的代码逻辑部分,横切关注点就是公共的代码的实现. 其中AOP中有几个比较关键的概念: 横切关注点:对哪些方法进行拦截,拦截后如何处理.这些关注点叫做横切关注点 切面:切面就是对横切关注点的抽象,就如同类对事物的抽象类似 连接点(joinpoint):被拦截到的点,可以通过连接点获取被拦截的参数等信息 切入点:连接点进行拦截的定义 织入:横切的过程叫做织入 简单的代码实现(注解)下面代码使用注解的方式实现的Spring AOP,配置文件同理,需要配置切面(主要是切点和通知方法) 1234567891011121314151617181920212223242526272829@Component// 标志为AOP @Aspectpublic class ServiceLog &#123; private Logger logger = LoggerFactory.getLogger(ServiceLog.class); @Autowired HttpSession httpSession; // 前置通知 切入点前执行 @Before("execution(* com.nanyin.jreact.service.serviceImpl..*.*(..))") public void handelServiceMethodBefore(JoinPoint joinpoint)&#123; //JoinPoint 为连接点,通过连接点可获取参数等 try&#123; String username = (String) httpSession.getAttribute("user"); BaseUtil.setUser(Optional.ofNullable(username).orElse("空 ")); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; // 后置通知 切入点后执行 @After("execution(* com.nanyin.jreact.service.serviceImpl..*.*(..))") public void handelServiceMethodAfter(JoinPoint joinpoint)&#123; try&#123; String username = (String) httpSession.getAttribute("user"); BaseUtil.setUser(Optional.ofNullable(username).orElse("空 ")); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; JDK动态代理和CGLIB代理两者都可以实现AOP代理功能,但是jdk代理需要代理类和委托类都实现系统的接口,但是实际应用的时候这种情况非常少,这时候会自动使用CGLIB实现动态代理 Spring事务管理事务包含四个基本特性,也就是常说的ACID,分别为原子性,一致性,隔离性,持久性 事务的接口 PlatformTransactionManager： （平台）事务管理器 spring 不直接管理事务,而是实现不同的事务管理器,将事务交给框架处理,如为ibaits 和 hibernate 有不同的实现. 123456&lt;!-- 事务管理器 xml 配置 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则) 123456789101112public interface TransactionDefinition &#123; // 返回事务的传播行为 int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getIsolationLevel(); //返回事务的名字 String getName()； // 返回事务必须在多少秒内完成 int getTimeout(); // 返回是否优化为只读事务。 boolean isReadOnly();&#125; TransactionStatus： 用来记录事务运行状态 1234567public interface TransactionStatus&#123; boolean isNewTransaction(); // 是否是新的事物 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成&#125; 自定义注解构造注解注解使用@interface来标识为一个注解,具体使用可以参考如下: 1234567891011// @Target原注解的意义是表明作用域，比如type就是表示要标注到类接口上@Target(&#123;ElementType.TYPE&#125;)// 表示作用域@Retention(RetentionPolicy.RUNTIME)// 表明其他注解能够继承该注解@Inherited// javadoc会包含@Documentedpublic @interface TableDescription &#123; String description();&#125; 其中该注解的作用就是1.标注在类接口上2.作用在运行时,能够通过反射得到接口中的内容3.能够让其他注解继承该注解4.能够生成javaddoc文档 下面来重点关注第一个和第二个元注解: @Target是这个注解的作用域，ElementType.METHOD是这个注解的作用域的列表，METHOD是方法声明，除此之外，还有：CONSTRUCTOR（构造方法声明）,FIELD（字段声明）,LOCAL VARIABLE（局部变量声明）,METHOD（方法声明）,PACKAGE（包声明）,PARAMETER（参数声明）,TYPE（类接口） @Retention是它的生命周期，前面不是说注解按照运行机制有一个分类嘛，RUNTIME就是在运行时存在，可以通过反射读取。除此之外，还有: SOURCE（只在源码显示，编译时丢弃）,CLASS（编译时记录到class中，运行时忽略）,RUNTIME（运行时存在，可以通过反射读取） 如何使用自定义注解 添加注解 1234567891011121314@Entity@Data@Table(name = "person")// 这里使用到了上面的自定义注解TableDescription@TableDescription(description = "this is person table")public class Person &#123; @Id private long id; @Column(name = "name",length = 128) private String name; @Column(name = "age",length = 3) private short age;&#125; 获得注解内容 123456789101112131415public void testAnn()&#123; try&#123; // 反射获取类 Class clazz = Class.forName("com.nanyin.jreact.entry.Person"); Boolean exist = clazz.isAnnotationPresent(TableDescription.class); if(exist)&#123; //如果注解在类中存在 TableDescription tableDescription = (TableDescription) clazz.getAnnotation(TableDescription.class); // 获得注解内容 System.out.println(tableDescription.description()); &#125; &#125;catch (ClassNotFoundException c)&#123; &#125;&#125; 上面只是简单的掩饰注解的用法,但实际上业务会比这难上许多. springMVC 工作流程先上一张图:来自https://www.cnblogs.com/xiaoxi/p/6164383.html 由图中可以看到SpringMvc中最重要的起到中枢的是DispatcherServlet(前端控制器). 在DispatcherServlet接受到客户端请求后,使用 handlerMapping 进行映射处理.在生成处理器映射器之后, 返回一个handler,如果有拦截器的化还生成拦截器.交给 DispatcherServlet 进行下一步处理. 第二步交给 handlerAdatper (处理器适器) HandlerAdapter 经过适配调用具体的处理器( Controller ，也叫后端控制器)。Controller执行完成返回ModelAndView。 第三步,DispatcherServlet将最终的结果交给 viewResolver 试图解析器进行视图解析 DispatcherServlet 根据返回的view进行视图渲染,最终返回给客户端用户.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring重点知识学习]]></title>
    <url>%2F2019%2F05%2F05%2F2019-05-05-Spring_Framework%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%202%2F</url>
    <content type="text"><![CDATA[Spring Framework使用spring可以轻易的创建一个企业级应用,它使用Java语言所有的企业级环境中的所有东西,spring是开源的,拥有庞大而活跃的社区来提供持续的支持. Spring Corespring分为多个模块,其中core为其中的一个,里面包含spring的核心技术点 IOC容器(控制反转)IOC也被成为依赖注入,这是由一个对象定义他所依赖的关系的过程.当创建这个bean的时候也同时创建这些依赖供其使用.这样的整个过程就是反转控制的过程,比如说建房子,以前需要砖,瓦,水泥才能建造房子,如果不实用ioc时,就是自己去造砖,造瓦,然后使用.现在使用ioc容器,只需要把砖,瓦,水泥写到清单上,ioc容器自动把这些准备好供使用,省去来自己制造的过程. org.springframework.beans 和 org.springframework.context 是spring实现IOC容器的基础.BeanFactory接口是能够管理任何对象的高级的配置接口,ApplicationContext是BeanFactory的子接口.因为: 更容易和Spring 的AOP特性相结合 消息资源处理,用于国际化问题 事件发布 用于特定的上下文比如web应用程序的WebApplicationContext 简单来说就是BeanFactory提供了基本的功能,而ApplicationContext提供了更多的企业定制化的功能. ApplicationContext代表了IOC容器,提供了初始化、配置、组装beans.通过配置元数据来获取有关初始化..等的指令.这里所指的配置元数据可以通过配置文件,注解或者java代码来实现.通过配置元数据来体现对象和其依赖. 下图为官网提供的spring工作的简化图: SpringBean的生命周期生命周期大概包含这几个阶段: 实例化Bean对象,这时还未进行依赖注入,最后将bean加入到beanwapper中. 设置对象属性.Spring根据BeanDefinition中的信息进行依赖注入.并且通过BeanWrapper提供的设置属性的接口完成依赖注入。 注入Aware接口,检测是否是想相关Aware接口,并装配相关接口的方法. BeanPostProcessor 此时bean已经成功被构造,通过实现这个接口来自定义前置和后置的处理规则. 调用initialzingBean和int-methods,这时对象成功被初始化 最后调用disposableBean的afterpropertiesSet方法和destroy-methods来实现指定对象销毁. Spring AOPAOP的意思是面向切面编程,在理解面向切面前,不得不说面向对象.什么是面向对象,面向对象编程就是将事务对象化,依据对象进行层级化,面向对象通过封装继承多态的方式实现了对象层次结构,但是实际应用时可能会遇到需要横向的进行业务处理,典型的就如日志,因为在实际代码编写时,不能每次在写方法前后都加入相同的代码,这样即浪费时间,又导致代码冗余.所以面向切面编程必不可少. AOP将多个相同的业务代码整合,形成一个通用的“切面”,通过切面可以分割出“核心关注点”和“横切关注点”,核心关注点就是实际的核心业务关注的代码逻辑部分,横切关注点就是公共的代码的实现. 其中AOP中有几个比较关键的概念: 横切关注点:对哪些方法进行拦截,拦截后如何处理.这些关注点叫做横切关注点 切面:切面就是对横切关注点的抽象,就如同类对事物的抽象类似 连接点(joinpoint):被拦截到的点,可以通过连接点获取被拦截的参数等信息 切入点:连接点进行拦截的定义 织入:横切的过程叫做织入 简单的代码实现(注解)下面代码使用注解的方式实现的Spring AOP,配置文件同理,需要配置切面(主要是切点和通知方法) 1234567891011121314151617181920212223242526272829@Component// 标志为AOP @Aspectpublic class ServiceLog &#123; private Logger logger = LoggerFactory.getLogger(ServiceLog.class); @Autowired HttpSession httpSession; // 前置通知 切入点前执行 @Before("execution(* com.nanyin.jreact.service.serviceImpl..*.*(..))") public void handelServiceMethodBefore(JoinPoint joinpoint)&#123; //JoinPoint 为连接点,通过连接点可获取参数等 try&#123; String username = (String) httpSession.getAttribute("user"); BaseUtil.setUser(Optional.ofNullable(username).orElse("空 ")); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; // 后置通知 切入点后执行 @After("execution(* com.nanyin.jreact.service.serviceImpl..*.*(..))") public void handelServiceMethodAfter(JoinPoint joinpoint)&#123; try&#123; String username = (String) httpSession.getAttribute("user"); BaseUtil.setUser(Optional.ofNullable(username).orElse("空 ")); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; JDK动态代理和CGLIB代理两者都可以实现AOP代理功能,但是jdk代理需要代理类和委托类都实现系统的接口,但是实际应用的时候这种情况非常少,这时候会自动使用CGLIB实现动态代理 Spring事务管理事务包含四个基本特性,也就是常说的ACID,分别为原子性,一致性,隔离性,持久性 事务的接口 PlatformTransactionManager： （平台）事务管理器 spring 不直接管理事务,而是实现不同的事务管理器,将事务交给框架处理,如为ibaits 和 hibernate 有不同的实现. 123456&lt;!-- 事务管理器 xml 配置 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则) 123456789101112public interface TransactionDefinition &#123; // 返回事务的传播行为 int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getIsolationLevel(); //返回事务的名字 String getName()； // 返回事务必须在多少秒内完成 int getTimeout(); // 返回是否优化为只读事务。 boolean isReadOnly();&#125; TransactionStatus： 用来记录事务运行状态 1234567public interface TransactionStatus&#123; boolean isNewTransaction(); // 是否是新的事物 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成&#125; 自定义注解构造注解注解使用@interface来标识为一个注解,具体使用可以参考如下: 1234567891011// @Target原注解的意义是表明作用域，比如type就是表示要标注到类接口上@Target(&#123;ElementType.TYPE&#125;)// 表示作用域@Retention(RetentionPolicy.RUNTIME)// 表明其他注解能够继承该注解@Inherited// javadoc会包含@Documentedpublic @interface TableDescription &#123; String description();&#125; 其中该注解的作用就是1.标注在类接口上2.作用在运行时,能够通过反射得到接口中的内容3.能够让其他注解继承该注解4.能够生成javaddoc文档 下面来重点关注第一个和第二个元注解: @Target是这个注解的作用域，ElementType.METHOD是这个注解的作用域的列表，METHOD是方法声明，除此之外，还有：CONSTRUCTOR（构造方法声明）,FIELD（字段声明）,LOCAL VARIABLE（局部变量声明）,METHOD（方法声明）,PACKAGE（包声明）,PARAMETER（参数声明）,TYPE（类接口） @Retention是它的生命周期，前面不是说注解按照运行机制有一个分类嘛，RUNTIME就是在运行时存在，可以通过反射读取。除此之外，还有: SOURCE（只在源码显示，编译时丢弃）,CLASS（编译时记录到class中，运行时忽略）,RUNTIME（运行时存在，可以通过反射读取） 如何使用自定义注解 添加注解 1234567891011121314@Entity@Data@Table(name = "person")// 这里使用到了上面的自定义注解TableDescription@TableDescription(description = "this is person table")public class Person &#123; @Id private long id; @Column(name = "name",length = 128) private String name; @Column(name = "age",length = 3) private short age;&#125; 获得注解内容 123456789101112131415public void testAnn()&#123; try&#123; // 反射获取类 Class clazz = Class.forName("com.nanyin.jreact.entry.Person"); Boolean exist = clazz.isAnnotationPresent(TableDescription.class); if(exist)&#123; //如果注解在类中存在 TableDescription tableDescription = (TableDescription) clazz.getAnnotation(TableDescription.class); // 获得注解内容 System.out.println(tableDescription.description()); &#125; &#125;catch (ClassNotFoundException c)&#123; &#125;&#125; 上面只是简单的掩饰注解的用法,但实际上业务会比这难上许多. springMVC 工作流程先上一张图:来自https://www.cnblogs.com/xiaoxi/p/6164383.html 由图中可以看到SpringMvc中最重要的起到中枢的是DispatcherServlet(前端控制器). 在DispatcherServlet接受到客户端请求后,使用 handlerMapping 进行映射处理.在生成处理器映射器之后, 返回一个handler,如果有拦截器的化还生成拦截器.交给 DispatcherServlet 进行下一步处理. 第二步交给 handlerAdatper (处理器适器) HandlerAdapter 经过适配调用具体的处理器( Controller ，也叫后端控制器)。Controller执行完成返回ModelAndView。 第三步,DispatcherServlet将最终的结果交给 viewResolver 试图解析器进行视图解析 DispatcherServlet 根据返回的view进行视图渲染,最终返回给客户端用户.]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate重点知识总结]]></title>
    <url>%2F2019%2F04%2F29%2F2019-04-29-Hibernate%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Hibernate重点知识总结Hibernate的三种状态 瞬时态(transient):当实体还未和session关联,如new Person(“1”); 持久态(persistent): 通过get或者load得到的实体类,这时的状态都是持久态. 游离态(detached): 当通过get或者load得到持久态的对象后,执行删除delete时,这时已经脱离session.因delete而变为游离态可有save或者saveOrUpate转化为持久态.或则当session关闭后,session中的对象就变为游离态. hibernate中update和saveOrUpdate的区别update只能是对象有主键时起作用,而saveOrUpdate则在对象没有主键时执行插入操作.对应的update操作只能操作游离态的对象,而不能对瞬时态的对象操作.而saveOrUpdate则两种状态的对象都可以操作. hibernate中的update和merge方法的区别当执行update方法的时候,一个session中具有与当前update相同的持久化标识(identifier)的实例,使用upate操作后会报错,而使用merge后把处理自由态的po对象A的属性copy到session当中处于持久态的po的属性中，执行完成后原来是持久状态还是持久态，而我们提供的A还是自由态。 hibernate中get和load的区别一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方法，hibernate一定要获取到真实的数据，否则返回null。 hibernate中list和iterator的区别(1)、List方式是1次性把所有的数据全部取到内存中，构造一个超大的结果集，主要的时间开销是这一步，这一步的时间开销要远远超过JDBC和 Iterator方式下构造结果集的时间开销，并且内存开销也很惊人；而对结果集的遍历操作，速度则是非常的惊人（经过测试，30万记录的内 存遍历不到100ms，由于这一步不受JDBC影响，因此结果可信）。因此，List方式适合于对结果集进行反复多次操作的情况，例如分页显示，往后往前 遍历，跳到第一行，跳到最后一行等等。 (2)、Iterator方式只取记录id到内存中，并没有把所有数据取到内存中，因此构造结果集的时间开销很小，比JDBC和List方式都要少，并且内 存开销也小很多。而对结果集的遍历的操作的时候，Iterator仍然要访问数据库，所有主要的时间开销都花在这里。因此，Iterator方式适合于只 对结果集进行1次遍历操作的情况，并且Iterator方式特别适合于从超大结果集中取少量数据，这种情况Iterator性能非常好。 总结: list把数据一次加载到内存,再进行遍历操作就非常快了.而Iterator方式只会把id放到内存中,但是再次遍历时仍然要访问数据库查询数据,适合一次遍历的情况. hibernate中的inverse属性设置inverse=“false”为主控方,由主控方类维护对象间的关系.比如再many-to-one的关系中,再one的一方设置inverse=&quot;true&quot;这样能够提高效率,比如班级里一个老师多个学生,老师记住多个学生比较困难,而学生记住一个老师很容易.同理one-to-many.再多对多的关系中,再任意一方设置inverse=&#39;true&#39;即可. hibernate中的cascade属性级联操作：指当主控方执行某项操作时，是否要对被关联方也执行相同的操作。 什么情况下懒加载能够有效的提高效率懒加载是当用到对象的时候再从数据库加载数据,持久化来使用.从这句话中就可以理解为,因为及联的关系,一个表的数据可能会带出多张表的数据,这时候使用懒加载就能够实现效率的提高,没必要一次性把所有数据都加载出来,而是用时加载.hibernate默认是使用懒加载的,当然可以使用lazy=false来禁用懒加载. 什么是hibernate的二级缓存缓存就是将以前的数据存放到内存中,当查询数据的时候,现在内存中查询,是否有这个对象,如果没有再从数据库中查询对象,这样大大的提高了查询的效率. Hibenate的session就是一级缓存,当查询数据的时候都会先从session中查询对象是否存在,不存在才从数据库查询.但是session是非线程安全的,多线程共享的情况下会出现问题.并且session是表示的是一段会话,表示的是一次事务,基于以上两点,所以在一次事务完成后,session就应立即关闭.所以这里说的一级缓存意义不大. Hibernate的二级缓存其实就是使用外部缓存,如Echache或者redis等,使用配置文件配置缓存策略等. Hibernate中使用hibernateTemplate的好处有哪些? HibernateTemplate简化了与Hibernate Session的交互 常见的函数简化为单个方法调用。 异常会自动捕获并转换为运行时异常 session 自动关闭]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的各种IO操作]]></title>
    <url>%2F2019%2F04%2F28%2F2019-04-28-Java_IO%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Java中的IO操作Java总的来说有三类IO,效率不高,操作简单的BIO(blocking IO),非阻塞的NIO(New IO),和异步非阻塞IO,也就是升级版的NIO(Asynchronous I/O). 在学习这三类IO前,需要了解什么是阻塞.什么是异步.两个的含义有什么区别. 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个调用时，在没有得到结果之前，该 调用 就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 BIOBIO过程就如同名字一样,是一个阻塞的IO,服务端通常为每一个客户端都建立一个独立的线程来通过调用accept()来监听客户端消息.如果想处理多个客户端请求则服务端需要建立等同数量的线程来处理这些消息,这就是普遍的一请求一应答的模型.处理完成后返回应答给客户端后销毁线程,因为线程是一个昂贵的资源,这样重复的新建线程,销毁线程,很浪费处理器资源,所以使用BIO同时能够尽可能的少创建线程,就可以用到线程池的方式实现,来达到服务端创建线程数远远小于客户端数的目的,但这种方法只是伪异步IO. 在处理链接数量少的情况下,BIO的效率还不错,并且主要逻辑模型清晰明了,代码简单.但是在上万的链接的情况下,BIO处理起来就非常吃紧了. NIONIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。 NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。 NIO特性和NIO与传统IO的区别 传统IO(BIO)是一种阻塞IO模型,而NIO是非阻塞的IO模型,区别为当线程读取数据的时候,非阻塞IO可以不用等,而阻塞IO需要一直等待IO完成后才能继续. IO面向流,而NIO面向缓冲区. 通道(channel) NIO通过通道进行数据读写.通道是双向的,而传统的IO是单向的.通道链接的都是Buffer,所以通道可以异步的读写. 选择器(Selectors) NIO拥有选择器,而IO没有.选择器的作用就是用来使用单个线程来处理多个通道(NIO面向buffer,通道只与buffer交互).AIO AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM基本知识整理]]></title>
    <url>%2F2019%2F04%2F24%2F2019-04-24-JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[java内存空间 其中如图中所展示的，按功能分了大致分为两类，一类为线程共享的JAVA堆和元数据区和直接内存，另一类是线程私有的虚拟机栈，方法区栈和程序计数器。 下面针对这几种区域来详细将这几个区域分别的作用是什么。 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程执行程序的字节码的的行号的指示器。字节码解释器工作时通过改变程序计数器的值来改变将要选取的下一个指令。并且由于每个线程执行的运行的指令不同，每个线程有个字的程序计数器，并且互不干扰。所以程序计数器被称作是线程私有的。这种线程私有的区域有着很明显的特征就是生命周期和当前线程的周期保持一致。并且需要注意的是程序计数器是内存中唯一一个不会出现outOfMemory的区域。 程序计数器有两个作用： A: 字节码解释器通过读取程序计数器的值来选取下一条将要执行的语句。 B:在多线程切换的情况下，记录当前线程执行的位置，方便于切换回时进程运行的位置。 虚拟机栈Java内存可以粗糙的分为堆内存和栈内存，所谓的堆就是图中的java堆（Heap），而所谓的栈就是指的虚拟机栈（VM Stack）的局部变量表。虚拟机栈是由一个个栈针构成的，可以想为一个方法为一个栈针，随着方法的被调用完成（完成的条件有两个，一个是return，另外一个是发生异常），对应着方法的栈针出栈。栈针中都包含：局部变量表，操作数栈，动态链接和方法出口。局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置） 本地方法栈本地方法栈同样是线程私有的,区别是java虚拟机栈是用于java字节码的,而本地方法栈是用来执行Native方法的.结构都和虚拟机栈的结构相同. Java堆Java堆是整个虚拟机中最大的一块区域,是线程共享的区域,再虚拟机启动时创建,该块存在的唯一目的就是存放类的事例和数组. 方法区和Java堆一样都是线程共享的区域,主要用于存放已经被虚拟机加载的类信息,常量,静态变量和已经被编译后的代码等数据.方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。 运行时常量池原来的运行时常量池是方法区的一部分,而在1.7之后,讲运行时常量池放到堆(Heap)中开辟了一个区域专门用来放运行时常量池.运行时常量池中遥遥包括两部分,一部分是实际存在的字面量,所谓字面量包括[1.文本字符串,2.被声明为final的常量,基本数据类型…..],另一部分是符号引用,包含[类和结构的名称,字段的名称,方法的名称] 元数据区替代了永久代,使用的是直接内存,什么是直接内存,它有能够干什么? 首先直接内存区域不是虚拟机运行时数据区的一部分,也不是虚拟机定义的一部分,但是经常会使用到. JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 对象的创建过程 对象的创建过程分为上图中的5步 类加载检查:当虚拟机遇到new的时候,会检查这个类是否存在,是否被加载,解释和初始化过,如果没有则进行类的初始化过程. 分配内存:再进行类加载检查后,会在堆内存中为新的对象分配内存,分配的规则有两种,一种是指针碰撞,另一种是空闲列表,针对不同的垃圾回收器会使用不同的方法.第一种方法指针碰撞的原理大致为它会将分配过的内存和未分配的内存间建立一个指针,当分配内存的时候,向为分配内存的地方移动新的对象的大小的位置,适用于比较规整的内存空间.第二种方法是维护一个分配内存的列表,每次分配内存都想列表中添加相关记录,表明这些对象在哪. 初始化零值:保证在分配完内存后,为分配的内存区域初始化为零值 设置对象头:虚拟机对对象的各种设置信息,保存在对象头中. 执行init方法:在执行init方法前,从虚拟机的角度来看其实对象已经生成了,但是在程序员的角度对象并没有生成,只有在init方法执行过后,对象才算生成. 对象的定位方式Java虚拟机定位对象的方式主要有两种,一是使用句柄,二是直接使用指针.]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悲观锁和乐观锁]]></title>
    <url>%2F2019%2F04%2F23%2F2019-04-08-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[悲观锁和乐观锁悲观锁悲观锁是总会先去想最坏的情况，每次线程拿数据的时候都会认为他会进行修改，适用于的场景是多写少读，这时使用悲观锁效率会高。程序中典型的悲观锁时synchronized和ReentrantLock 乐观锁乐观锁是总会先去想好的情况，每次线程拿数据只会看一眼，并不会做修改操作，这时没有必要加锁，程序中的atom原子类使用cas+volatile+native方法实现乐观锁。 两种锁的机制，有各自的好处，不能说谁好谁坏，各有优点： 悲观锁适用于多写少读的情况，而乐观锁适用于多读少写的情况，如果在多写的情况下使用乐观锁，会经常产生冲突，反而会降低性能。 乐观锁常用的两种方式版本号的控制每次读取数据的时候都会连同版本号一同读取，在当更新数据的时候，会比较读取到的版本号和数据库中的版本号是否一致，如果一致则更新，如果不一致则继续读取，更新数据。 CAS操作（compareAndSwap）举个例子,在atomInteger类中涉及了CAS 1234567891011121314public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x)//这里是native方法 offset是偏移量先暂且不提，o是需要比较的值，expected是预期值，x是新值// 如果使用程序写出来就是大概这样： int value; public boolean fakeCAS(int expect,int newValue)&#123; if(value == expect)&#123; value = newValue; return true; &#125;else&#123; return false; &#125; &#125; 比较替换(compareAndSwap)是一个原子操作，也是一个自旋操作，等待一个周期再次尝试。 CAS操作的缺点 ABA问题，何谓ABA：当两个线程读取到当前值为A，其中一个线程把值改为B后再把B改为A，这是另外一个线程使用cas操作读取到的值仍然是A，CAS会认为这个值从来没有变过，这就是ABA问题。也就是说遗失掉中间的过程，在链式的操作总更能体会到ABA问题的严重性。 自旋时间过长，消耗CPU资源。 只能对单个共享变量的原子性操作]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池和AQS知识整理]]></title>
    <url>%2F2019%2F04%2F23%2F2019-04-23-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[线程池和AQS代码解析使用线程池是为了将线程得以复用,线程创建后在线程池中被循环利用,防止了线程得多次创建和销毁.下面就通过代码来看线程池的工作原理. 线程池配置比较繁琐,所以java提供了一个线程池的工具类Executors 来使用静态的方法来创建拥有特定属性的线程池.下面先总体的看一下都有哪些创建线程池的方法,和各自的实现. newFixedThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool 创建一个可缓存的线程池,此时线程池对线程得多少没有限制,如果多了就定时回收,如果少了,就会只能添加 newScheduledThreadPool 创建一个无限大小的线程池,此线程池可执行定时的任务 newSingleThreadExecutor 线程池中有且只有一个线程执行任务,如果因异常结束,则会生成一个线程来替换原来的线程.此种连接池会按照任务的提交顺序依次执行.因为池中只有一个线程在工作. 在Excutors中有上面四种方式来创建线程池,那么这几种线程池具体是如何工作的呢?通过源码来一探究竟. ThreadPoolExecutor除了newScheduledThreadPool连接池没有使用ThreadPoolExcutor来实现,其他三种都使用到了ThreadPoolExcutor来进行连接池的实现和定制.下图是ThreadPoolExcutor的结构关系.它是ExecutorService的直接实现类. ThreadPoolExcutor提供了三种构造函数,不同的构造函数含有不同的参数.下面先了解一下各参数的含义 参数名称 参数类型 含义 corePoolSize Int 池中的线程数量,即使他们是空闲的,除非设置allowCoreThreadTimeOut参数 maximumPoolSize int 池中允许的最大的线程数量 keepAliveTime long 如果池中的线程超过核心数,如果超过这个时间线程仍是空闲的则结束这个线程 unit TimeUnit keepAilveTime的时间的单位 workQueue BlockingQueue 一个阻塞队列,用来存储未进行的任务.未执行的任务会一直在队列里,知道使用Excute方法执行. threadFactory ThreadFactory 线程工厂,用于生产线程 handle RejectedExecutionHandler 执行阻塞的处理策略,造成阻塞的原因可能是达到了线程边界或者队列容量 其中线程池使用ctl变量控制状态信息,ctl是一个AtomInteger,其中高28位表示线程得数量,也就是workerCount,低位的4位表示线程池的状态. 名称 承担的任务 RUNNING 接受新的任务,并且处理队列中的任务 SHUTDOWN 不接受新的任务,但是会处理队列中的任务 STOP 不接受新任务,不处理排队的人物,并且终止正在进行的任务 TIDYING 所有任务已经终止,worker为空,通过terminate方法来转换为TIDYING TERMINATED 当terminate方法执行过后的状态 方法源码解析提交的方法submit实在ExcutorService的实现类AbstarctExecutorService中所定义的,可以看出submit是excute方法的外壳,其实核心还是执行excute方法,但是会返回Future结果. 123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;//返回Future结果 &#125; 因为执行的核心方法是excute,所以进到ThreadPoolExecutor类中看excute方法是如何执行的.其实最通俗的解释excute的过程就是,将新的worker加入到worker的队列中,并执行当前的command线程.执行过程可以参考官方注释: 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /** * 执行总共分为三步 * 1. 如果当前线程池中的工作线程数小于核心线程数,则添加一个worker来执行当前这个任务 * 2. 为了防止进入方法后线程池关闭或者线程挂掉需要重新获取ctl,并且进行判断,是否进行 * 回退或者是空池后添加一个空线程. * 3.如果不能将任务放到队列中,则执行rollback,回退任务 */ int c = ctl.get();//获得ctl变量,从而获得workercount和状态信息 if (workerCountOf(c) &lt; corePoolSize) &#123; //如果线程数小于核心线程数 if (addWorker(command, true)) //添加一个新的worker来执行任务 return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //如果当前池的状态为运行状态并且接受了这个任务,也就是说任务成功进入了执行队列 int recheck = ctl.get(); //重新获取ctl,因为有可能在进入这个if语句的时候一个线程挂了,或者整个池被关闭了 if (! isRunning(recheck) &amp;&amp; remove(command)) //如果线程池的状态为非运行状态 // 从队列中移除任务,并且reject任务 相当于第一步操作的rollback reject(command); else if (workerCountOf(recheck) == 0) //如果池是空的 addWorker(null, false);//新建一个线程 &#125; else if (!addWorker(command, false)) //如果放到队列中失败,则将任务rollback reject(command); &#125; 线程池中拥有的状态有以下几种: 12345private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 在excute方法中需要用到addWorker在当前状态和给定的边界条件下(核心线程数core或者最大线程数maximum)能否添加一个worker线程执行任务.如果当前线程池为空或者有资格关闭线程池.这是调用该方法会返回false.如果线程池工厂the thread factory不能再产出更多的线程也会返回false. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private boolean addWorker(Runnable firstTask, boolean core) &#123; /** * firstTask 理解为初始化时给的第一个任务,可以绕过排队的过程,直接使用新的线程执行 * core 如果是true则使用corePoolSize作为边界,否则使用maximumPoolSize作为边界 */ retry://flag标记 for (;;) &#123; int c = ctl.get(); //获取ctl变量 int rs = runStateOf(c);// 获取状态参数 // Check if queue empty only if necessary. 检查队列是否为空 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) //如果大于最大的CAPACITY或者wc大于核心线程数 return false; if (compareAndIncrementWorkerCount(c)) //使用CAS添加worker后,操作成功后跳出循环 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);//以后单说这个worker final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); // 使用ReentrantLock上锁保持原子性 try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize)// 当前worker的数量大于largestPoolSize时 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start();//线程开始执行 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) //如果到这里线程还是没有开始,rollback添加worker的过程 addWorkerFailed(w); &#125; return workerStarted; &#125; 其中涉及到了woker线程创建的rollback过程,调用了addWorkerFailed方法: 123456789101112private void addWorkerFailed(Worker w) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (w != null) workers.remove(w);//如果存在在队列中移除w decrementWorkerCount();//减少workerCount变量的值 tryTerminate();//重新检查终止过程,以防止因为这个worker的存在导致终止失败 &#125; finally &#123; mainLock.unlock(); &#125; &#125; 在当运行的线程数到达核心线程数后,就会将任务插入到workQueue里面,让池中的工作线程完成任务,上面的源码中使用addWoker方法来执行当前指定的任务,而未涉及到加入到workQueue中的任务是如何执行的,下面通过查看Woker中的run方法来查看池中的线程如何获取任务来执行的过程. 因为Worker实现AQS「AbstractQueuedSynchronizer」,并继承来Runnable,所以Worker其实本质上还是一个线程.在执行start后,同样会执行run方法. Worker中的全局变量: 123456/** Thread this worker is running in. Null if factory fails. 执行当前工作线程*/final Thread thread;/** 初始化的任务,可能是空*/Runnable firstTask;/** 每个线程的任务计数器(统计完成的任务数) */volatile long completedTasks; Worker的构造器,默认是需要传入Runnable的任务的. 12345Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);//保存从ThreadFactory中获取到的Thread&#125; worker中的方法 123456789101112131415161718192021222324252627282930313233//查看是否是独占的protected boolean isHeldExclusively() &#123; return getState() != 0; //AQS中的state保存这个状态&#125;//尝试获得锁protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; //通过改变state来实现 如果state&gt;0说明获取到了锁 setExclusiveOwnerThread(Thread.currentThread()); //设置独占访问的线程 return true; &#125; return false;&#125;//尝试释放锁protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null);//清空独占访问的线程 setState(0);//状态置为「释放锁」 return true;&#125;public void lock() &#123; acquire(1); &#125;public boolean tryLock() &#123; return tryAcquire(1); &#125;public void unlock() &#123; release(1); &#125;public boolean isLocked() &#123; return isHeldExclusively(); &#125;void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125;&#125; 在addWorke中调用run方法执行任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** Delegates main run loop to outer runWorker */public void run() &#123; runWorker(this); //委托runWorker执行&#125;final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread();//获得当前线程 Runnable task = w.firstTask;//获得任务 w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; //如果存在任务 w.lock(); //将当前工作线程上锁 // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt //如果线程池正在被停止,需要确保线程已经被中断 //如果线程池没有被停止,需要确保线程不能被中断 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); //执行任务 &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; //清空任务 w.completedTasks++; //当前线程处理任务数加一 w.unlock();//解锁 &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; AQS「AbstractQueuedSynchronizer」 队列同步器AQS的使用方式是继承,之类通过继承AQS,实现抽象方法来实现管理同步器. 其中上文中的ThreadPoolExcutor中的Worker就是继承AQS来实现的. AQS使用一个全局变量state来表示当前的锁的状态,如果state&gt;0,说明已经获取到了锁,如果state=0,说明释放了锁. AQS依靠CLH队列完成对状态的管理.当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 其中CLH的一个节点包括了:当前的状态,前驱,后继,当前节点保存的线程. 具体的AQS过程可以参考QAS原理 补充的countDownLatch和cyclicBarrier的区别]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解和使用synchronized关键字]]></title>
    <url>%2F2019%2F04%2F22%2F2019-04-22-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[synchronized为什么要用synchronized多线程有三大特性：原子性，有序性（重排序问题？）和可见性；其中原子性在程序上的体现就是使用synchronized,为了保证可见性是使用需要使用volatile.使用synchronized来保证程序的原子性首先在讨论三大特性前需要知道java的内存模型和happen-before原则。内存模型与happen-before原则 牵扯出的问题： 什么是线程安全：我的理解就是如果保证多线程执行的结果和预期结果相同，就是线程安全的，否则就是线程不安全的 什么是JAVA内存模型？ 在java内容中程序计数器，虚拟机栈，本地方法栈都是线程私有的区域，而方法区和java堆是线程共享的区域 因为cpu的处理速度与内存的读写速度之间有着着巨大的差距，所以在cpu和内存间添加一层缓存，每次现在cpu的缓存中，这个缓存区域的读写速度往往比内存的读写速度快很多，这样就能够缓解cpu和主存之间的速度差距。 所以每次cpu读写数据前，会先读取共享变量到本地内容，cpu再从本地内存中读取数据。这就是java的内存模型 这样也会产生数据不一致的情况，这是就要需要保证共享变量的数据可见性，即线程1修改了变量，则线程2再修改变量前已经得知变量已经被修改了。 应用synchronized为了保证程序的原子性：我们在程序中使用synchronized关键字对程序进行锁定，表示在锁住的区域内只能有一个线程访问。 如何使用synchronized 使用synchronized修饰静态方法，针对类变量进行加锁。进入方法的前提是获得类的锁。 修饰实例方法，针对实例对象，在进入方法前要获得实例变量的锁。 修饰代码块。指定加锁的对象，在进入代码块钱要先获得指定对象的锁。 1234567891011121314151617181920public class SynchronizedTest &#123; //synchronized的三种用法 //1.修饰实例方法 需要拥有实例对象的锁 public synchronized void hello()&#123; System.out.println(&quot;hello&quot;); &#125; //2.修饰静态方法 需要拥有类对象的锁 public synchronized static void staticHello()&#123; System.out.println(&quot;staticHello&quot;); &#125; public void blockHello()&#123; //3.修饰代码块 需要拥有【this】的锁 synchronized(this)&#123; System.out.println(&quot;code block hello&quot;); &#125; &#125; &#125; 典型的使用synchronized的场景–单例模式的双重锁结构在讨论双重锁的前，需要聊聊单例模式，单例模式通俗的来说一个类只能构造一个实例。针对的实现又两种：1.饿汉模式，2.懒汉模式 饿汉模式12345678910111213public class Singleton &#123; private Singleton()&#123;&#125;; //1. 使用静态变量// private static Singleton singleton = new Singleton(); //2.使用静态代码块 未使用时造成内存空间浪费 private static Singleton singleton; static &#123; singleton = new Singleton(); &#125; public Singleton newInstance()&#123; return singleton; &#125;&#125; 这种方式不会影响到多线程的线程安全问题，因为类的装载机制在初始化对象的时候是保证不会有第二个线程进入的。但是有个很大的弊端是他不是lazy-loading的，这回产生资源的浪费，比如创建完对象后，自始至终没用过。所以不推荐使用 懒汉模式123456789101112131415161718192021public class Singleton &#123; private void Singleton()&#123;&#125; private static Singleton singleton; // 普通的线程不安全的 public Singleton newInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125; //2.静态内部类 一方面能够达到lazy-loading的效果，另一方面能够保证线程安全，因为jvm保证初始化的时候别的线程是不能进入的 private static class newSingleton&#123; private static final Singleton INSTANCE = new Singleton(); &#125; public Singleton newInstanceInnerClass()&#123; return newSingleton.INSTANCE; &#125;&#125; 上面代码的第一种是不能保证线程安全的，多线程下会导致失效。而第二种使用静态内部类的方式实现能够实现线程安全得宜于类的加载机制，类似饿汉模式。但同时具有lazy-Loading的特性。是常用的单例模式用法。 double-check双重锁1234567891011121314151617public class DoubleCheck &#123; private void DoubleCheck()&#123;&#125; private volatile DoubleCheck doubleCheck; //使用volatile保证原子性，防止重排序 public DoubleCheck newInstance()&#123; if(doubleCheck == null)&#123; // 当两个线程同时到这步 a先进同步块，在a进入后获得instance后，b获得锁，进入同步块， // 这时候下一个判断就起到作用了，这时候的doubleCheck不为空， // 直接return，否则又️新建了一个对象 synchronized (DoubleCheck.class)&#123; if(doubleCheck == null)&#123; doubleCheck = new DoubleCheck(); &#125; &#125; &#125; return doubleCheck; &#125;&#125; 实际上double-check也是懒汉模式的一种，能够保证线程安全。很完美。。 synchronzied底层实现synchronized 同步语句块的实现使用的是monitorenter 和monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 volatile和synachronized的区别 volatile是线程同步的轻量级实现，所以说使用volatile的性能肯定要强于synchronized。 volatile作用于变量，而synachronzied作用于方法和代码块。 多线程间使用volatile不会发生阻塞，而使用synachronized可能发生阻塞 volatile保证变量在多线程间的可见性，向虚拟机声明这个变量不稳定，需要每次都从主存中获取，而synchronized既能够保证可见性，又能保证原子性。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中常用关键字总结]]></title>
    <url>%2F2019%2F04%2F22%2F2019-04-12-Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java中关键字总结final关键字final主要用于三个地方：变量、方法、类 变量： 如果final修饰变量，如果变量是基本数据类型，则表示如果该基本数据类型一旦初始化则不能再改变，如果修饰引用变量，则表示初始化之后不能执行另外一个变量。 方法： 如果final作用域方法上，说明该方法是不能改变的，也就是说继承累无法改变方法。所有private方法默认是final的 类：如果final作用与类上，说明该类是无法被继承的。并且他的类中的方法默认都是private的。 static关键字static关键字在以下四种情况下用到。 用来修饰成员变量或方法，通过static修饰的变量或者方法被称作为静态变量和静态方法。可以通过类名.变量或方法()调用，静态变量和方法属于整个类对象，而不属于实例变量。静态变量存放在java内存中的方法区。 用来修饰静态代码块。使用static修饰的静态代码块，会先于代码块和构造方法。并且只会执行一次。 用来修饰静态内部类。使用static修饰静态内部类，有两个特性，其一是他的创建不依赖于外部类，其二是他只能调用外部类的静态变量或方法。 用来静态导入包，这个不太常用。使用 import static导入静态资源。 this 关键字this用于执行当前对象，也就是说不能在static方法或者代码块中使用this来指向对象。 super 关键字this关键字指向本身对象，而super关键字则指向父类对象。 java中二进制运算操作与运算 &amp;转换为二进制，都为一时则为一 或运算 |转换为二进制后，只要有一个为一，则结果为一 异或操作 ^转换为二进制后，不同则为一 取反操作 ～按位取反的操作（由正数变为负数） 1234567891011121314151617181920212223242526@Test public void testBitOperating()&#123; System.out.println(5&amp;6); // 0101 // 0110 // ----- // 0100 结果是4 System.out.println(5 | 6); // 0101 // 0110 // ----- // 0111 结果是7 System.out.println(5 ^ 6); // 0101 // 0110 // ----- // 0011 结果是 3 System.out.println(~5); // 0.... 0101 //----------- // 0.... 0101 补码 = 正数的补码和源码相同 负数的补码等于源码取反后+1 // 1.... 0110 源码 = 取反 后加一 -6 System.out.println(~-6); // 1.....0110 // 1.....1010 补码：负数的补码为反码+1 // 0.....0101 源]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令整理]]></title>
    <url>%2F2019%2F01%2F29%2F2019-01-29-%E5%9F%BA%E6%9C%ACLlinux%E5%91%BD%E4%BB%A4(%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1)%202%2F</url>
    <content type="text"><![CDATA[linux中必须掌握的基本命令在开始前，我推荐安装 trdr（too long dont read）工具，用来简化man命令，来实现查看命令含义和用法的作用。 一 、系统工作命令 echo echo命令一般用于shell中打印变量或者字符串的作用，主要用来显示和提醒。 输出一段信息 如：echo &quot;hello world&quot; 其中&quot;不是必须的 输出一段带环境变量的信息 如：echo &quot;My Path is $PATH&quot; 输出并不带换行符号 如：echo -n &quot;Hello World&quot; 输出一段激活转依字符 如： echo -e &quot;Column 1 \t Column 2&quot; date date 命令主要用来设置和打印系统时间。 输出默认时区格式的事件 date +&quot;%c&quot; 输出当前事件按照UTC和iso格式输出 date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; 输出事件戳 date +&quot;%s&quot; reboot 命令主要用来重启系统 重启系统 reboot 强制重启 reboot -f poweroff 命令用户关机 wget 命令 用于从web中下载文件，支持 http,https,ftp 获取URL中的内容到foo中 wget https://example.com/foo 获取URL中的内容到bar中 wget -O bar https://example.com/foo 继续未完成的下载 wget -c https://example.com 后台下载 wget -q https://example.com ps命令主要用于查看正在运行的进程的信息 打印全部正在执行的进程 ps aux 打印全部正在执行的进程并且伴有完整的命令串 ps auxww 通过 grep 管道过滤 ps aux | grep &quot;tomcat&quot; 得到进程的父进程pid :ps -o ppid= -p pid top命令 主要用户动态的实时的显示正在运行的程序 top -i 不显示空闲或者是僵尸进程 top -u $user 显示指定用户的进程 top -p PID 只显示指定进程PID top -p $(pgrep -d &#39;,&#39; process_name) 通过进程名来查询 pidof 命令主要用于查找指定进程的id号 pidof -s 进返回一个进程号 pidof -c 仅显示具有相同root目录下的进程 二、系统状态 ifconfig 命令主要用于网络接口的查看和配置 Ifconfig eth0 查看etho0接口网络设置 ifconfig -a 查看所有接口的详细信息 ifconfig eth0 down 关闭接口eth0 ifconfig eth0 ipaddr 设置端口ip地址 uname 打印出现当前机器和系统的相关信息 uname -n 打印当前的hostname uname -a 打印当前可用的系统的信息，包括硬件软件。 who 打印哪些用户登录再这台机器上 who 显示username等比较全的信息 who am i 打印出当前用户 last 用于查看当前用户最近的登录信息 三、文件和目录 pwd 用于打印当前目录 cd 用于切换目录 ls 用于罗列目录下的文件或者文件夹 ls -l按行罗列文件或文件夹 ls -a 显示所有文件，包括隐藏的文件。 ls -lh 按照大小排泄排列 touch 命令主要用于改变文件的访问时间和修改时间。 touch filename 以当前时间创建文件 touch -t yyyy-mm-dd filename 以某一时间来改变文件时间 mkdir 命令主要用于创建文件 mkdir dir 创建文件夹 mkdir -p /path/dir 创建指定路径下的文件 cp 命令主要用于文件的复制 cp path/to/file.ext path/to/copy.ext 复制文件到另一个地址 cp path/to/file.ext path/to/target_parent_directory 复制文件到指定地址，并且保持文件名不变 cp -r path/to/directory path/to/copy 递归的复制整个文件夹及其中的内容到指定目录 cp -i *.txt path/to/target_directory 以交互的模式复制文件到指定文件夹中 mv 命令主要用于移动文件 mv source target 移动文件 mv -f 强制移动，覆盖现有文件时不要提示 rm命令主要用于删除文件 rm path/to/file path/to/another/file 删除特定文件夹中的文件 rm -r path/to/directory 递归删除文件夹及文件夹中的文件 rm -rf 递归删除，并且不要提示信息 dd 命令主要用于转化和复制文件,制作usb镜像 Clone a drive to another drive with 4MB block and ignore error dd if=/dev/source_drive of=/dev/dest_drive bs=4m conv=noerror file命令主要用于确定文件类型 file filename 输出文件类型 file -s filename 用于特殊的文件或者设备文件。 四、文本编辑命令 cat 打印和串联文件 cat file 打印文件内容到标准输出 cat file1 file2 &gt; targetFile 将多个文件内容串联到目标文件中 cat -n file 打印出行数到标准输出 more 用于互动的阅读文件内容，可以上下滚动 more file 打开文件，&lt;space&gt;用于移动到下一页，/用于搜索文件内容， q用于退出当前界面 head 输出文件开始的部分 head -n count_of_line filename 查看文件的前n行 head -c number_of_byte filename 查看文件的前n个字节 tail 输出文件最后的部分 tail -n num file打印出文件最后num行 tail -n +num file 打印出文件从num开始的几行 tail -f file 保持阅读状态直到 Ctrl + c wc命令用于统计文件的单词，字节，行数 wc -l filename 统计文件的行数 wc -w filename 统计文件的字数 wc -c filename 统计文件的字节数 显示文件的状态 stat filename 显示文件的属性比如大小，权限等。 stat -x filename格式化显示文件的详细属性信息。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令整理]]></title>
    <url>%2F2019%2F01%2F29%2F2019-01-29-%E5%9F%BA%E6%9C%ACLlinux%E5%91%BD%E4%BB%A4(%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1)%2F</url>
    <content type="text"><![CDATA[linux中必须掌握的基本命令在开始前，我推荐安装 trdr（too long dont read）工具，用来简化man命令，来实现查看命令含义和用法的作用。 一 、系统工作命令 echo echo命令一般用于shell中打印变量或者字符串的作用，主要用来显示和提醒。 输出一段信息 如：echo &quot;hello world&quot; 其中&quot;不是必须的 输出一段带环境变量的信息 如：echo &quot;My Path is $PATH&quot; 输出并不带换行符号 如：echo -n &quot;Hello World&quot; 输出一段激活转依字符 如： echo -e &quot;Column 1 \t Column 2&quot; date date 命令主要用来设置和打印系统时间。 输出默认时区格式的事件 date +&quot;%c&quot; 输出当前事件按照UTC和iso格式输出 date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; 输出事件戳 date +&quot;%s&quot; reboot 命令主要用来重启系统 重启系统 reboot 强制重启 reboot -f poweroff 命令用户关机 wget 命令 用于从web中下载文件，支持 http,https,ftp 获取URL中的内容到foo中 wget https://example.com/foo 获取URL中的内容到bar中 wget -O bar https://example.com/foo 继续未完成的下载 wget -c https://example.com 后台下载 wget -q https://example.com ps命令主要用于查看正在运行的进程的信息 打印全部正在执行的进程 ps aux 打印全部正在执行的进程并且伴有完整的命令串 ps auxww 通过 grep 管道过滤 ps aux | grep &quot;tomcat&quot; 得到进程的父进程pid :ps -o ppid= -p pid top命令 主要用户动态的实时的显示正在运行的程序 top -i 不显示空闲或者是僵尸进程 top -u $user 显示指定用户的进程 top -p PID 只显示指定进程PID top -p $(pgrep -d &#39;,&#39; process_name) 通过进程名来查询 pidof 命令主要用于查找指定进程的id号 pidof -s 进返回一个进程号 pidof -c 仅显示具有相同root目录下的进程 二、系统状态 ifconfig 命令主要用于网络接口的查看和配置 Ifconfig eth0 查看etho0接口网络设置 ifconfig -a 查看所有接口的详细信息 ifconfig eth0 down 关闭接口eth0 ifconfig eth0 ipaddr 设置端口ip地址 uname 打印出现当前机器和系统的相关信息 uname -n 打印当前的hostname uname -a 打印当前可用的系统的信息，包括硬件软件。 who 打印哪些用户登录再这台机器上 who 显示username等比较全的信息 who am i 打印出当前用户 last 用于查看当前用户最近的登录信息 三、文件和目录 pwd 用于打印当前目录 cd 用于切换目录 ls 用于罗列目录下的文件或者文件夹 ls -l按行罗列文件或文件夹 ls -a 显示所有文件，包括隐藏的文件。 ls -lh 按照大小排泄排列 touch 命令主要用于改变文件的访问时间和修改时间。 touch filename 以当前时间创建文件 touch -t yyyy-mm-dd filename 以某一时间来改变文件时间 mkdir 命令主要用于创建文件 mkdir dir 创建文件夹 mkdir -p /path/dir 创建指定路径下的文件 cp 命令主要用于文件的复制 cp path/to/file.ext path/to/copy.ext 复制文件到另一个地址 cp path/to/file.ext path/to/target_parent_directory 复制文件到指定地址，并且保持文件名不变 cp -r path/to/directory path/to/copy 递归的复制整个文件夹及其中的内容到指定目录 cp -i *.txt path/to/target_directory 以交互的模式复制文件到指定文件夹中 mv 命令主要用于移动文件 mv source target 移动文件 mv -f 强制移动，覆盖现有文件时不要提示 rm命令主要用于删除文件 rm path/to/file path/to/another/file 删除特定文件夹中的文件 rm -r path/to/directory 递归删除文件夹及文件夹中的文件 rm -rf 递归删除，并且不要提示信息 dd 命令主要用于转化和复制文件,制作usb镜像 Clone a drive to another drive with 4MB block and ignore error dd if=/dev/source_drive of=/dev/dest_drive bs=4m conv=noerror file命令主要用于确定文件类型 file filename 输出文件类型 file -s filename 用于特殊的文件或者设备文件。 四、文本编辑命令 cat 打印和串联文件 cat file 打印文件内容到标准输出 cat file1 file2 &gt; targetFile 将多个文件内容串联到目标文件中 cat -n file 打印出行数到标准输出 more 用于互动的阅读文件内容，可以上下滚动 more file 打开文件，&lt;space&gt;用于移动到下一页，/用于搜索文件内容， q用于退出当前界面 head 输出文件开始的部分 head -n count_of_line filename 查看文件的前n行 head -c number_of_byte filename 查看文件的前n个字节 tail 输出文件最后的部分 tail -n num file打印出文件最后num行 tail -n +num file 打印出文件从num开始的几行 tail -f file 保持阅读状态直到 Ctrl + c wc命令用于统计文件的单词，字节，行数 wc -l filename 统计文件的行数 wc -w filename 统计文件的字数 wc -c filename 统计文件的字节数 显示文件的状态 stat filename 显示文件的属性比如大小，权限等。 stat -x filename格式化显示文件的详细属性信息。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 配置全过程]]></title>
    <url>%2F2019%2F01%2F04%2F2019-01-04-Ubuntu%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B%202%2F</url>
    <content type="text"><![CDATA[Ubuntu18.04 配置全过程因为最近在弄win10双系统，又因为PopOs在装机的时候设置grub比较麻烦，所以换成最新的Ubuntu稳定版来做成win/ubunut双系统。 安装问题在装机的需要使用grub做启动引导。所以设置保留BIOS启动区域而不是挂载/boot。亲身经历，UEFI启动模式下，Ubuntu的引导挂载应该是biosgrub，否则出错。导致无法家在grub。 界面配置安装gnome-tweak-tool1sudo apt install gnome-tweak-tool 如果需要更改shell则需要安装： 1sudo apt install gnome-shell-extensions 这样就能轻松愉快的使用gnome-tewak-tool了。 主题方案主界面因为前一阵使用Pop!_OS发现它默认的主题非常好看，所以下载Popos默认的主题，然后在gnome-tweak-tool中设置好就ok了，这里是PopOs的gtk主题地址。但是发现PopOs默认的输入法输入框是默认米黄色的，打字的时候不太显眼，所以在基础上添加了如下代码。添加方法： 根据说明下载Pop-theme 123sudo add-apt-repository ppa:system76/popsudo apt updatesudo apt install pop-theme 定位到 /usr/share/themes/Pop/gnome-shell/ 的gnome-shell.css和Pop.css 将IBus的界面代码替换成如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.candidate-popup-content &#123; padding: 8px; spacing: 0;&#125;.candidate-index &#123; padding: 0 4px 0 0; color: rgba(255, 255, 255, 0.5);&#125;.candidate-box:selected .candidate-index &#123; color: rgba(255, 255, 255, 0.5);&#125;.candidate-box &#123; transition-duration: 0ms; min-height: 28px; padding: 0 8px; border-radius: 8px;&#125;.candidate-box:hover &#123; background-color: rgba(255, 255, 255, 0.06); color: rgba(255, 255, 255, 0.9);&#125;.candidate-box:active &#123;background-color: rgba(255, 255, 255, 0.1); color: rgba(255, 255, 255, 0.9);&#125;.candidate-box:selected &#123; background-color: #0046DB; color: rgba(255, 255, 255, 0.85);&#125;.candidate-page-button-box &#123; height: 28px;&#125;.vertical .candidate-page-button-box &#123; padding-top: 0;&#125;.horizontal .candidate-page-button-box &#123; padding-left: 0;&#125;.candidate-page-button &#123; min-width: 28px; min-height: 28px; padding: 0;&#125;.candidate-page-button-previous &#123; border-radius: 8px; border-right-width: 0;&#125;.candidate-page-button-next &#123; border-radius: 8px;&#125;.candidate-page-button-icon &#123; icon-size: 1.23077em;&#125; 最后成品： 应用程序窗口用的是 macOS High Sierra 主题，仿照MAC的窗口。比较漂亮。macOS High Sierra 主题，下载下来后解压后放到 /usr/share/themes 下，之后就能在gnome-tweak-tool中看到了，设置完成后可以看到如下效果。 gdm主题gdm主题选用类似MAC登陆的主题，界面美观，而且还有毛玻璃效果。High Ubunterra下载后解压之后，直接命令行执行./install.sh。之后直接右键设置后，直接将锁屏界面直接设置好。其实主要目的的就是将 /usr/share/gnome-shell/theme 中的ubuntu.css替换掉。 grub主题grub的主题比较少，推荐的就是Breeze GRUB2 theme 是一款比较漂亮美观的主题。具体成果界面可以点击链接地址查看。 普通主题需要作如下顺序的操作，但是 Breeze Grub2 theme 有脚本，直接执行解压后的脚本程序，就ok了。 创建grub的主题文件夹 1sudo mkdir /boot/grub/themes 将主题包移动到这个目录下 1sudo cp 主题包名 /boot/grub/themes/ 修改主题的配置文件 1sudo vim /etc/grub.d/00_header 在配置文件中添加 12GRUB_THEME=&quot;/boot/grub/themes/主题包名/theme.txt&quot;GRUB_GFXMODE=&quot;1920x1080x32&quot; 最后执行 update-grub 命令 gnome拓展推荐我没有什么特殊的拓展安装，在Ubuntu系统下，一般安装如下拓展。 User themes 可以使用用户目录下的主题 removeable Drive Menu 当插入移除设备的时候在上方有状态图标提醒。 Caffeine 可以关闭屏保和自动挂起，很好用。 Dash To Dock 如果你不喜欢ubuntu的侧边dock可以尝试这个dock，比较美观的dock，可以设置在侧边或者在底下。 openWeather 可以在顶部栏中查看天气，点击可以查看最近天气，需要手动添加地址。 ClipBord Indicator 是可以记录粘贴板的内容，有时可以避免重复复制的操作。 推荐的有这几个，但是gnome-shell拓展可谓非常的多，并且大多数都非常好用，可以去 gnome extensions 官网 看一看，看有没有更适合自己的。 配置Vim和终端配置vim我vim使用的是vundle插件管理器，首先要安装vundle. 首先要下载git 1sudo apt-get install git 然后安装vundle 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vi 将如下配置替换到.vimrc 中，首先要进行备份哦！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768set nocompatible &quot; be iMproved, requiredfiletype off &quot; requiredset numberlet mapleader=&quot;,&quot;set rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;VundleVim/Vundle.vim&apos;Plugin &apos;scrooloose/nerdtree&apos;Plugin &apos;kien/ctrlp.vim&apos;Plugin &apos;junegunn/fzf&apos;Plugin &apos;Shougo/neocomplete.vim&apos;Plugin &apos;vim-airline/vim-airline&apos;Plugin &apos;vim-airline/vim-airline-themes&apos;Plugin &apos;terryma/vim-smooth-scroll&apos;Plugin &apos;terryma/vim-expand-region&apos;Plugin &apos;tpope/vim-commentary&apos;Plugin &apos;tpope/vim-surround&apos;Plugin &apos;godlygeek/tabular&apos;Plugin &apos;plasticboy/vim-markdown&apos;Plugin &apos;tpope/vim-fugitive&apos;Plugin &apos;airblade/vim-gitgutter&apos;Plugin &apos;justinmk/vim-sneak&apos;Plugin &apos;powerline/fonts&apos;Plugin &apos;scrooloose/nerdcommenter&apos; Plugin &apos;suan/vim-instant-markdown&apos;Plugin &apos;mzlogin/vim-markdown-toc&apos;call vundle#end() &quot; requiredfiletype plugin indent on&quot; let g:airline_powerline_fonts = 1map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;&quot; smooth-scrollfunction SmoothScroll(up) if a:up let scrollaction=&quot;^Y&quot; else let scrollaction=&quot;^E&quot; endif exec &quot;normal &quot; . scrollaction redraw let counter=1 while counter&lt;&amp;scroll let counter+=1 sleep 10m redraw exec &quot;normal &quot; . scrollaction endwhileendfunctionnoremap &lt;silent&gt; &lt;c-u&gt; :call smooth_scroll#up(&amp;scroll, 15, 2)&lt;CR&gt;noremap &lt;silent&gt; &lt;c-d&gt; :call smooth_scroll#down(&amp;scroll, 15, 2)&lt;CR&gt;noremap &lt;silent&gt; &lt;c-b&gt; :call smooth_scroll#up(&amp;scroll*2, 10, 4)&lt;CR&gt;noremap &lt;silent&gt; &lt;c-f&gt; :call smooth_scroll#down(&amp;scroll*2, 10, 4)&lt;CR&gt;set mouse= map &lt;ScrollWheelUp&gt; &lt;C-Y&gt;map &lt;ScrollWheelDown&gt; &lt;C-E&gt;&quot;高亮错误&quot; let g:syntastic_enable_highlighting=1&quot; 快速选中&quot; let g:expand_region_use_select_mode = 1&quot; map w &lt;Plug&gt;(expand_region_expand)&quot; map W &lt;Plug&gt;(expand_region_shrink)&quot; markdown settinglet g:vim_markdown_toc_autofit = 1let g:vim_markdown_autowrite = 1let g:vim_markdown_folding_disabled = 1set updatetime=100let g:gitgutter_grep=&apos;&apos;let g:gitgutter_terminal_reports_focus=0 最后在vim中使用:PluginInstall 安装插件。具体的插件的作用以后会专门写一篇来介绍。也可自行百度。 配置终端我使用的是zsh，首先安装zsh 1sudo apt-get install zsh 然后配置将zsh为默认 1sudo chsh -s /bin/zsh 最后使用著名的oh-my-zsh 来装点B吧。 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 配置git环境和github连接安装好git后，配置git 12git config --global user.name &quot;你的github用户名&quot;git config --global user.email &quot;你的github邮箱地址&quot; 生成密钥，一路enter就可以 1ssh-keygen -t rsa -C &quot;你自己的github对应的邮箱地址&quot; 将文件中生成的密钥复制到github上的配置中去 1vim ~/.ssh/id_rsa.pub 检查是否配置成功 1ssh -T git@github.com 配置Java开发环境JDK 在官网下载jdk源码,并在解压前创建 /usr/local/java 文件夹 1mkdir /usr/local/java 将文件解压到刚创建的文件夹中，也可以解压到当前文件夹下，然后移动到刚才创建的文件夹下。 123tar -xzvf jdk1.8.0_191.tar.gz mv jdk1.8.0_191 /usr/local/java/ 使用vim编辑/etc/profile 文件,在结尾处添加如下内容 123export JAVA_HOME=/usr/local/java/jdk1.8.0_191 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 执行 source /etc/profile 刷新配置文件，然后使用 java -version来查看是否成功。 Maven 在官网 下载源码包，同样解压前创建 /usr/local/maven文件夹 将文件解压到/usr/local/maven中。 使用vim编辑 /etc/profile文件，在末尾添加如下内容 12export MAVEN_HOME=/usr/local/maven/apache-maven-3.6.0export PATH=$MAVEN_HOME/bin:$PATH 同样使用source /etc/profile 命令刷新配置文件，使用mvn -v 命令查看是否安装成功。 配置阿里maven镜像 编辑 /usr/local/maven/apache-maven-3.6.0/conf/setting.xml，在&lt;mirrors&gt;&lt;/mirrors&gt;标签内添加如下内容 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; Mysql安装和数据库管理软件推荐 进入官网下载ubuntu的deb包，直接使用命令安装 1sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb 刷新源列表 1sudo apt-get update 安装mysql 1sudo apt-get install mysql-server mysql-client 其中会让你输入密码，输入就行了。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 配置全过程]]></title>
    <url>%2F2019%2F01%2F04%2F2019-01-04-Ubuntu%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Ubuntu18.04 配置全过程因为最近在弄win10双系统，又因为PopOs在装机的时候设置grub比较麻烦，所以换成最新的Ubuntu稳定版来做成win/ubunut双系统。 安装问题在装机的需要使用grub做启动引导。所以设置保留BIOS启动区域而不是挂载/boot。亲身经历，UEFI启动模式下，Ubuntu的引导挂载应该是biosgrub，否则出错。导致无法家在grub。 界面配置安装gnome-tweak-tool1sudo apt install gnome-tweak-tool 如果需要更改shell则需要安装： 1sudo apt install gnome-shell-extensions 这样就能轻松愉快的使用gnome-tewak-tool了。 主题方案主界面因为前一阵使用Pop!_OS发现它默认的主题非常好看，所以下载Popos默认的主题，然后在gnome-tweak-tool中设置好就ok了，这里是PopOs的gtk主题地址。但是发现PopOs默认的输入法输入框是默认米黄色的，打字的时候不太显眼，所以在基础上添加了如下代码。添加方法： 根据说明下载Pop-theme 123sudo add-apt-repository ppa:system76/popsudo apt updatesudo apt install pop-theme 定位到 /usr/share/themes/Pop/gnome-shell/ 的gnome-shell.css和Pop.css 将IBus的界面代码替换成如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.candidate-popup-content &#123; padding: 8px; spacing: 0;&#125;.candidate-index &#123; padding: 0 4px 0 0; color: rgba(255, 255, 255, 0.5);&#125;.candidate-box:selected .candidate-index &#123; color: rgba(255, 255, 255, 0.5);&#125;.candidate-box &#123; transition-duration: 0ms; min-height: 28px; padding: 0 8px; border-radius: 8px;&#125;.candidate-box:hover &#123; background-color: rgba(255, 255, 255, 0.06); color: rgba(255, 255, 255, 0.9);&#125;.candidate-box:active &#123;background-color: rgba(255, 255, 255, 0.1); color: rgba(255, 255, 255, 0.9);&#125;.candidate-box:selected &#123; background-color: #0046DB; color: rgba(255, 255, 255, 0.85);&#125;.candidate-page-button-box &#123; height: 28px;&#125;.vertical .candidate-page-button-box &#123; padding-top: 0;&#125;.horizontal .candidate-page-button-box &#123; padding-left: 0;&#125;.candidate-page-button &#123; min-width: 28px; min-height: 28px; padding: 0;&#125;.candidate-page-button-previous &#123; border-radius: 8px; border-right-width: 0;&#125;.candidate-page-button-next &#123; border-radius: 8px;&#125;.candidate-page-button-icon &#123; icon-size: 1.23077em;&#125; 最后成品： 应用程序窗口用的是 macOS High Sierra 主题，仿照MAC的窗口。比较漂亮。macOS High Sierra 主题，下载下来后解压后放到 /usr/share/themes 下，之后就能在gnome-tweak-tool中看到了，设置完成后可以看到如下效果。 gdm主题gdm主题选用类似MAC登陆的主题，界面美观，而且还有毛玻璃效果。High Ubunterra下载后解压之后，直接命令行执行./install.sh。之后直接右键设置后，直接将锁屏界面直接设置好。其实主要目的的就是将 /usr/share/gnome-shell/theme 中的ubuntu.css替换掉。 grub主题grub的主题比较少，推荐的就是Breeze GRUB2 theme 是一款比较漂亮美观的主题。具体成果界面可以点击链接地址查看。 普通主题需要作如下顺序的操作，但是 Breeze Grub2 theme 有脚本，直接执行解压后的脚本程序，就ok了。 创建grub的主题文件夹 1sudo mkdir /boot/grub/themes 将主题包移动到这个目录下 1sudo cp 主题包名 /boot/grub/themes/ 修改主题的配置文件 1sudo vim /etc/grub.d/00_header 在配置文件中添加 12GRUB_THEME=&quot;/boot/grub/themes/主题包名/theme.txt&quot;GRUB_GFXMODE=&quot;1920x1080x32&quot; 最后执行 update-grub 命令 gnome拓展推荐我没有什么特殊的拓展安装，在Ubuntu系统下，一般安装如下拓展。 User themes 可以使用用户目录下的主题 removeable Drive Menu 当插入移除设备的时候在上方有状态图标提醒。 Caffeine 可以关闭屏保和自动挂起，很好用。 Dash To Dock 如果你不喜欢ubuntu的侧边dock可以尝试这个dock，比较美观的dock，可以设置在侧边或者在底下。 openWeather 可以在顶部栏中查看天气，点击可以查看最近天气，需要手动添加地址。 ClipBord Indicator 是可以记录粘贴板的内容，有时可以避免重复复制的操作。 推荐的有这几个，但是gnome-shell拓展可谓非常的多，并且大多数都非常好用，可以去 gnome extensions 官网 看一看，看有没有更适合自己的。 配置Vim和终端配置vim我vim使用的是vundle插件管理器，首先要安装vundle. 首先要下载git 1sudo apt-get install git 然后安装vundle 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vi 将如下配置替换到.vimrc 中，首先要进行备份哦！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768set nocompatible &quot; be iMproved, requiredfiletype off &quot; requiredset numberlet mapleader=&quot;,&quot;set rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;VundleVim/Vundle.vim&apos;Plugin &apos;scrooloose/nerdtree&apos;Plugin &apos;kien/ctrlp.vim&apos;Plugin &apos;junegunn/fzf&apos;Plugin &apos;Shougo/neocomplete.vim&apos;Plugin &apos;vim-airline/vim-airline&apos;Plugin &apos;vim-airline/vim-airline-themes&apos;Plugin &apos;terryma/vim-smooth-scroll&apos;Plugin &apos;terryma/vim-expand-region&apos;Plugin &apos;tpope/vim-commentary&apos;Plugin &apos;tpope/vim-surround&apos;Plugin &apos;godlygeek/tabular&apos;Plugin &apos;plasticboy/vim-markdown&apos;Plugin &apos;tpope/vim-fugitive&apos;Plugin &apos;airblade/vim-gitgutter&apos;Plugin &apos;justinmk/vim-sneak&apos;Plugin &apos;powerline/fonts&apos;Plugin &apos;scrooloose/nerdcommenter&apos; Plugin &apos;suan/vim-instant-markdown&apos;Plugin &apos;mzlogin/vim-markdown-toc&apos;call vundle#end() &quot; requiredfiletype plugin indent on&quot; let g:airline_powerline_fonts = 1map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;&quot; smooth-scrollfunction SmoothScroll(up) if a:up let scrollaction=&quot;^Y&quot; else let scrollaction=&quot;^E&quot; endif exec &quot;normal &quot; . scrollaction redraw let counter=1 while counter&lt;&amp;scroll let counter+=1 sleep 10m redraw exec &quot;normal &quot; . scrollaction endwhileendfunctionnoremap &lt;silent&gt; &lt;c-u&gt; :call smooth_scroll#up(&amp;scroll, 15, 2)&lt;CR&gt;noremap &lt;silent&gt; &lt;c-d&gt; :call smooth_scroll#down(&amp;scroll, 15, 2)&lt;CR&gt;noremap &lt;silent&gt; &lt;c-b&gt; :call smooth_scroll#up(&amp;scroll*2, 10, 4)&lt;CR&gt;noremap &lt;silent&gt; &lt;c-f&gt; :call smooth_scroll#down(&amp;scroll*2, 10, 4)&lt;CR&gt;set mouse= map &lt;ScrollWheelUp&gt; &lt;C-Y&gt;map &lt;ScrollWheelDown&gt; &lt;C-E&gt;&quot;高亮错误&quot; let g:syntastic_enable_highlighting=1&quot; 快速选中&quot; let g:expand_region_use_select_mode = 1&quot; map w &lt;Plug&gt;(expand_region_expand)&quot; map W &lt;Plug&gt;(expand_region_shrink)&quot; markdown settinglet g:vim_markdown_toc_autofit = 1let g:vim_markdown_autowrite = 1let g:vim_markdown_folding_disabled = 1set updatetime=100let g:gitgutter_grep=&apos;&apos;let g:gitgutter_terminal_reports_focus=0 最后在vim中使用:PluginInstall 安装插件。具体的插件的作用以后会专门写一篇来介绍。也可自行百度。 配置终端我使用的是zsh，首先安装zsh 1sudo apt-get install zsh 然后配置将zsh为默认 1sudo chsh -s /bin/zsh 最后使用著名的oh-my-zsh 来装点B吧。 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 配置git环境和github连接安装好git后，配置git 12git config --global user.name &quot;你的github用户名&quot;git config --global user.email &quot;你的github邮箱地址&quot; 生成密钥，一路enter就可以 1ssh-keygen -t rsa -C &quot;你自己的github对应的邮箱地址&quot; 将文件中生成的密钥复制到github上的配置中去 1vim ~/.ssh/id_rsa.pub 检查是否配置成功 1ssh -T git@github.com 配置Java开发环境JDK 在官网下载jdk源码,并在解压前创建 /usr/local/java 文件夹 1mkdir /usr/local/java 将文件解压到刚创建的文件夹中，也可以解压到当前文件夹下，然后移动到刚才创建的文件夹下。 123tar -xzvf jdk1.8.0_191.tar.gz mv jdk1.8.0_191 /usr/local/java/ 使用vim编辑/etc/profile 文件,在结尾处添加如下内容 123export JAVA_HOME=/usr/local/java/jdk1.8.0_191 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 执行 source /etc/profile 刷新配置文件，然后使用 java -version来查看是否成功。 Maven 在官网 下载源码包，同样解压前创建 /usr/local/maven文件夹 将文件解压到/usr/local/maven中。 使用vim编辑 /etc/profile文件，在末尾添加如下内容 12export MAVEN_HOME=/usr/local/maven/apache-maven-3.6.0export PATH=$MAVEN_HOME/bin:$PATH 同样使用source /etc/profile 命令刷新配置文件，使用mvn -v 命令查看是否安装成功。 配置阿里maven镜像 编辑 /usr/local/maven/apache-maven-3.6.0/conf/setting.xml，在&lt;mirrors&gt;&lt;/mirrors&gt;标签内添加如下内容 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; Mysql安装和数据库管理软件推荐 进入官网下载ubuntu的deb包，直接使用命令安装 1sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb 刷新源列表 1sudo apt-get update 安装mysql 1sudo apt-get install mysql-server mysql-client 其中会让你输入密码，输入就行了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot过程问题]]></title>
    <url>%2F2019%2F01%2F04%2F2019-01-25-%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SpringBoot过程问题spring注解相关@RestController​ @RestController 是spring 4.0来引入的简化的RESTful WEB应用的创建，是一个结合@Constroller和@ResponseBody的注解，不用每个类都使用ResponseBody注解来达到处理请求的目的。 ​ 控制器使用@RestController注释进行注释，因此不需要@ResponseBody。 @RequestMapping@RequestMapping的注解中的参数： name ： 在4.0后引入的，开始我错把name当value用，结果出现 [java.lang.IllegalStateException: Ambiguous mapping found. Cannot map &#39;appController&#39; bean method] 类似这种错误。其实name就是一个名字而已,没有什么特殊含义，但是官方文档中指出 在类型级别和方法级别支持！在两个级别上使用时，组合名称通过串联以“＃”作为分隔符派生 。使用上，官方说明是主要可以通过使用Spring jsp tag包里面的mvcUrl，来生成jsp到controller的链接。 1234567@RequestMapping(&quot;/people&quot;) class PersonController &#123; @RequestMapping(&quot;/&#123;id&#125;&quot;) public HttpEntity getPerson(@PathVariable String id) &#123; ... &#125; &#125; 123&lt;%@ taglib uri=&quot;http://www.springframework.org/tags&quot; prefix=&quot;s&quot; %&gt; &lt;a href=&quot;$&#123;s:mvcUrl(&apos;PC#getPerson&apos;).arg(0,&quot;123&quot;).build()&#125;&quot;&gt;Get Person&lt;/a&gt; value:用来表示主要映射,是常用的 12345@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET,produces = &quot;application/json&quot;) public @ResponseBody List&lt;User&gt; findUsers() &#123; return userService.findUsers(); &#125; path: 指定访问的uri地址 12345@RequestMapping(path = &quot;/user&quot;,method = RequestMethod.POST,name = &quot;this is user`s post methods&quot;) public String insertUser()&#123; userService.saveUser(); return null; &#125; method:映射的HTTP的访问方法，有GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params： 指定request中必须包含某些参数值时，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 Jpa常用注解@Entity标注在类外侧，标注着这个类是一个实体类。 @Table​ 标注在类外侧，标注实体的主表，其中有 catalog,indexes, name, schema，分别注明为：指定database的目录，索引，名称，和表的结构描述 ​ 注意：schema定义了表、每个表的字段，还有表和字段之间的关系。 @Id表示是实体类的主键 @GeneratedValue​ 提供主键的值得生成策略规范。GeneratedValue注释可以与Id注释一起应用于实体或映射超类的主键属性或字段，派生主键不支持该注解。提供两个可选值：1. generator ：要在SequenceGenerator或TableGenerator注解中指定的主键生成器的名称。2. strategy 生成策略，有四个可选值AUTO,INDENTITY,SEQUENCE 和 TABLE ，默认为AUTO @Column指定持久属性或字段的映射列。如果未指定Column注释，则应用默认值。 updatable：是否包含在框架自动生成的update语句中。 其他可以通过例子一看便知： 12@Column(name=&quot;description&quot;, nullable=false, length=512)public String getDescription() &#123; return description; &#125; @Transient@Transient表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic. @ManyToOne表示一个多对一的映射,该注解标注的属性通常是数据库表的外键 1234567//订单Order和用户User是一个ManyToOne的关系//在Order类中定义@ManyToOne()@JoinColumn(name=”USER”)public User getUser() &#123; return user;&#125; @JoinColumn​ 指定用于连接实体关联或元素集合的列。如果JoinColumn注解本身是默认的，则假定使用单个连接列并应用默认值。其默认的名称为实体User的名称+下划线+实体User的主键名称。也就是USER_ID. @OneToMany@OneToMany描述一个一对多的关联,该属性应该为集体类型,在数据库中并没有实际字段.例如:实体User和Order是OneToMany的关系,则实体User被删除时,其关联的实体Order也应该被全部删除 1234@OneTyMany(cascade=ALL)public List getOrders() &#123; return orders;&#125; @OneToOne描述一对一的关系 如User表和person表，一个是基本信息一个是详细信息 1234@OneToOne(fetch=FetchType.LAZY) // Fetch是抓取策略，如果不写，自动的策略是LAZYpublic Person getPerson() &#123; return person;&#125; @ManyToMany@ManyToMany 描述一个多对多的关联.多对多关联上是两个一对多关联,但是在ManyToMany描述中,中间表是由ORM框架自动处理 @Embedded@Embedded将几个字段组合成一个类,并作为整个Entity的一个属性. 123456789@Embeddablepublic class Address &#123;city,street,zip&#125; @Entitypublic class User &#123; @Embedded public Address getAddress() &#123; &#125;&#125; 注解 说明 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值,同理@Max(value) @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值，同理@DecimalMax(value) @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Past 被注释的元素必须是一个过去的日期，同理@Future @Pattern(regex=,flag=) 符合正则 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0，message表示提示信息 @Email 邮箱验证 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 spring boot 配置问题spring2.0后静态资源访问不到的问题需要手动写配置类进行静态资源配置 123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; /** * 添加静态资源文件，外部可以直接访问地址 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); registry.addResourceHandler(&quot;/templates/**&quot;).addResourceLocations(&quot;classpath:/templates/&quot;); &#125;&#125; 配置SpringBoot Jpa默认mysql生成表引擎为InnoDB在配置文件appliction.properties中加入 1spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系的IBUS输入法上方panel的输入法图标消失问题]]></title>
    <url>%2F2018%2F12%2F29%2F2018-12-18-Pop!_Os%E7%9A%84Ibus%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8A%E6%96%B9panel%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ubuntu系的IBUS输入法上方panel的输入法图标消失问题最近迷上了Pop!_Os，基于Ubuntu的发行版，非常简洁，开箱即用。和ubuntu相同，ibus的输入法图标有时消失，在这里总结以下，方便后面再出现问题的时候查阅。 打开终端输入： 1ibus-daemon -drx 解决！！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别和关系]]></title>
    <url>%2F2018%2F11%2F09%2F2018-11-08-String%E5%92%8CStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[String、StringBuffer、StringBuilder的区别和关系String声明后是一个常量，而Stringbuffer和StringBuilder是数据结构是变量，所以比String在连接字符时效率高。 并且StringBuffer和StringBuilder的区别是StringBuffer是线程安全的(synchronized) ，而StringBuilder是非线程安全的，所以速度大致排行为：StringBuilder&gt;StringBuffer&gt;String 以上只是基于印象或者说是死记硬背的东西，没有看源码是否真的是这样的。下面就来看看String,StringBuilder,StringBuffer的源码来真正的记住。 StringString中的concat方法实现了字符串的拼接。 实例变量String类中有两个实例变量，分别为value和hash 12345/** The value is used for character storage. */private final char value[];/** Cache the hash code for the string */private int hash; // Default to 0 构造方法String的构造方法很多，但是都比较简单，下面来说比较常用的几种。 12345678910111213// 当新建一个String对象的时候，会默认付一个空的字符序列,请注意，由于字符串是不可变的，因此不必使用此构造函数public String() &#123; this.value = "".value; &#125;// 这个构造方法,会默认新建一个值为original的字符串。同上，如果字符串不可变的，就没必要这样声明。public String(String original) &#123; this.value = original.value; this.hash = original.hash; &#125;// 使用copyof方法用来复制一个新的字符数组，后续修改字符数组，不会影响到新建的字符串public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; concat方法为什么说String的效率低，就体现在concat拼接字符串的时候每次都要返回一个新的String对象。 1234567891011 public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len);// 返回一个新建的String对象 return new String(buf, true); &#125; StringBuilderStringBuilder继承了AbstractStringBuilder，其中的实例变量和String中的基本相同， 构造方法1234567public StringBuilder(int capacity) &#123; super(capacity); &#125;// 调用父类的构造方法AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; append方法可以看到，并没有新建对象，只是在改变对象中的内容。 123456789101112131415public StringBuilder append(String str) &#123; super.append(str); return this; &#125;// append调用的还是父类的append方法public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count);// 把value扩容后再把str加进去 count += len; return this; &#125; StringBuffer和StringBuilder一样，也是继承了AbstractStringBuilder类，但是看一个append这个方法的源码就能够知道有什么区别了 append方法添加了synchronized关键字，使得变为线程安全的，但是代价就是效率不如StringBuilder高。 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于SpringMvc实现restFul时DELETE和PUT出现错误]]></title>
    <url>%2F2018%2F11%2F09%2F2018-12-18-%E5%85%B3%E4%BA%8ESpringMvc%E4%BD%BF%E7%94%A8DELETE%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E6%97%B6405%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[关于RESTful我理解的restful是一种风格，每一个url表示一个资源，一个资源不同的操作享用同一个接口，但是传输的状态是不同的，比如http中的POST,DELETE,PUT,GET。 再springMVC中实现RESTful web.xml中配置 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;HttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; springmvc control层使用相应状态码来标识。 1@RequestMapping(value = &quot;/navbarCategory/&#123;id&#125;&quot;, method = RequestMethod.DELETE)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息中间件，RPC框架，数据库中间件的概念认知]]></title>
    <url>%2F2018%2F10%2F30%2F2018-10-29-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8CRPC%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[消息中间件，RPC框架，数据库中间件的概念认知消息中间件什么是消息中间件对中间件的理解大概就是具体业务和底层逻辑解耦的组件。相当于前端业务和底层逻辑的中间桥梁。 消息中间件是在分布式系统中发送和接受消息的基础服务设施。 能够做什么？ 业务解耦：交易系统不需要知道短信通知服务的存在，只需要发布消息 削峰填谷：比如上游系统的吞吐能力高于下游系统，在流量洪峰时可能会冲垮下游系统，消息中间件可以在峰值时堆积消息，而在峰值过去后下游系统慢慢消费消息解决流量洪峰的问题 事件驱动：系统与系统之间可以通过消息传递的形式驱动业务，以流式的模型处理 RPC框架什么是RPC框架远程过程调用协议RPC（Remote Procedure Call Protocol) 两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。 能够做什么？ 建立客户端和服务器之间的TCP链接，不同的RPC协议，有不同的连接寻址方式。 在发起远程调用时，由于网络协议是二进制的，所以在传输前要进行对传输实体进行转换二进制的过程，也是就序列化过程（Serialize），通过寻址和二进制的数据传输到服务器端 在接受到数据后，需要进行反序列化过程解析二进制数据。 其实就是解决在分布式下，横向拓展的前提下，不同服务器相互调用方法的问题。 数据库中间件什么是数据库中间件同样在分布式的架构中，数据库也放到不同的服务器上，需要通过中间的路由进行调用。这个路由实际上就是数据库中间件。 能够做什么？ 实现读写分离，但是每个服务器上都需要有一份完整的数据库 实现分库分表，通过消息中间件进行查询分派到某一个特定的服务器上，通过这个服务器查询出内容返回到消息中间件，再通过中间件返回到客户端。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit的使用和源码分析]]></title>
    <url>%2F2018%2F10%2F29%2F2018-10-28-Junit4%202%2F</url>
    <content type="text"><![CDATA[Junit的使用和源码分析Junit是一个编写可重复测试的Java测试框架，代码编写非常有技巧性，值得反复阅读。 跟着官方文档学习Junit官方文档往往是学习最好的资料。 简单测试例子1234567891011121314151617181920212223public class FirstTest &#123; public int add(int a, int b) &#123; return a + b; &#125; @Test public void testAdd()&#123; FirstTest firstTest = new FirstTest(); int result = firstTest.add(1,2); // assertEquals(4,result); assertEquals(3,result); &#125; &lt;!-- - 如果判断不相等的时候，后台报错信息 - java.lang.AssertionError: - Expected :4 - Actual :3 - &lt;Click to see difference&gt; --&gt;&#125; 这只是简单的例子，实际上的单元测试要比这个复杂的多，在实际应用上单元测试十分有必要，编写后台代码时能够尽快检验代码的正确性。 Assertions 断言Junit提供了所有基本数据类型，Object类和数组的断言，参数是 预期值后面是实际值，可选项，第一个参数可以是断言失败时输出的内容，与其他断言稍有不同的是，AssertThat的参数是 失败输出的内容，实际值和一个MatcherObject。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class AssertTests &#123; @Test public void testAssertArrayEquals() &#123; byte[] expected = "trial".getBytes(); byte[] actual = "trial".getBytes(); assertArrayEquals("failure - byte arrays not same", expected, actual); &#125; @Test public void testAssertEquals() &#123; assertEquals("failure - strings are not equal", "text", "text"); &#125; @Test public void testAssertFalse() &#123; assertFalse("failure - should be false", false); &#125; @Test public void testAssertNotNull() &#123; assertNotNull("should not be null", new Object()); &#125; @Test public void testAssertNotSame() &#123; assertNotSame("should not be same Object", new Object(), new Object()); &#125; @Test public void testAssertNull() &#123; assertNull("should be null", null); &#125; @Test public void testAssertSame() &#123; Integer aNumber = Integer.valueOf(768); assertSame("should be same", aNumber, aNumber); &#125; // JUnit Matchers assertThat @Test public void testAssertThatBothContainsString() &#123; assertThat("albumen", both(containsString("a")).and(containsString("b"))); &#125; @Test public void testAssertThatHasItems() &#123; assertThat(Arrays.asList("one", "two", "three"), hasItems("one", "three")); &#125; @Test public void testAssertThatEveryItemContainsString() &#123; assertThat(Arrays.asList(new String[] &#123; "fun", "ban", "net" &#125;), everyItem(containsString("n"))); &#125; // Core Hamcrest Matchers with assertThat @Test public void testAssertThatHamcrestCoreMatchers() &#123; assertThat("good", allOf(equalTo("good"), startsWith("good"))); assertThat("good", not(allOf(equalTo("bad"), equalTo("good")))); assertThat("good", anyOf(equalTo("bad"), equalTo("good"))); assertThat(7, not(CombinableMatcher.&lt;Integer&gt; either(equalTo(3)).or(equalTo(4)))); assertThat(new Object(), not(sameInstance(new Object()))); &#125; @Test public void testAssertTrue() &#123; assertTrue("failure - should be true", true); &#125;&#125; 异常测试下面分为两种方式来完成对异常的测试 期待的异常如何检测程序是否如期的抛出异常，junit可以使用注解的参数来实现。 1234@Test(expected = IndexOutOfBoundsException.class)public void testException()&#123; new ArrayList&lt;Integer&gt;().get(0);&#125; 深入的异常上述方法对于简单的情况很有用，但它有其局限性。例如，您无法在异常中测试消息的值，也无法在抛出异常后测试域对象的状态 try/catch 语句 123456789@Testpublic void testTryCatch()&#123; try &#123; new ArrayList&lt;Integer&gt;().get(0); fail("失败信息"); &#125;catch (IndexOutOfBoundsException indexOutOfBoundsExecption)&#123; assertThat(indexOutOfBoundsExecption.getMessage(), is("Index: 0, Size: 0")); &#125;&#125; rule 规则 12345678910@Rulepublic ExpectedException thrown = ExpectedException.none();@Testpublic void testExpectException()&#123; List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); thrown.expect(IndexOutOfBoundsException.class); thrown.expectMessage("Index: 0, Size: 0"); list.get(0); // execution will never get past this line&#125; Matchers and assertThat [ 匹配器和assertThat ]新加入了assertThat断言机制 assertThat([value], [matcher statement]); 1234assertThat(x, is(3));assertThat(x, is(not(4)));assertThat(responseString, either(containsString("color")).or(containsString("colour")));assertThat(myList, hasItem("3")); assertThat 更具有可读性和可输入性，并且有组合性，就像 is(not(4)) 任何Machers都可以组合起来使用 以前的assertEquals等也是可以用的，assertThat 在使用Matchers的时候需要使用 import static org.hamcrest.CoreMatchers.*;来引用。里面的方法非常多。。 junit源码跟读使用junit流程使用继承自TestCase类下面通过运行junit的自带的test，源程序为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Some simple tests. */public class SimpleTest extends TestCase &#123; protected int fValue1; protected int fValue2; @Override protected void setUp() &#123; fValue1 = 2; fValue2 = 3; &#125; public static Test suite() &#123; /* * the type safe way * TestSuite suite= new TestSuite(); suite.addTest( new SimpleTest("add") &#123; protected void runTest() &#123; testAdd(); &#125; &#125; ); suite.addTest( new SimpleTest("testDivideByZero") &#123; protected void runTest() &#123; testDivideByZero(); &#125; &#125; ); return suite; */ /* * the dynamic way */ return new TestSuite(SimpleTest.class); &#125; public void testAdd() &#123; double result = fValue1 + fValue2; // forced failure result == 5 assertTrue(result == 6); &#125; public int unused; public void testDivideByZero() &#123; int zero = 0; int result = 8 / zero; unused = result; // avoid warning for not using result &#125; public void testEquals() &#123; assertEquals(12, 12); assertEquals(12L, 12L); assertEquals(new Long(12), new Long(12)); assertEquals("Size", 12, 13); assertEquals("Capacity", 12.0, 11.99, 0.0); &#125; public static void main(String[] args) &#123; junit.textui.TestRunner.run(suite()); &#125;&#125; 来看main方法，使用 junit.textui.TestRunner.run(suite()); 使用TestRunner运行test。首先先来看suite方法，有两种方法 静态的,需要手动在testSuite中添加test。 动态的，静态需要实现TestCase的runTest方法。而动态的只需要返回 TestSuite(SimpleTest.class);，下面来看这个TestSuite类 testSuite实际上就是运行test的集合，使用vector来存储test,其中这里使用到的TestSuite构造方法是： 123456789101112131415161718192021222324252627282930313233public TestSuite(final Class&lt;?&gt; theClass) &#123; addTestsFromTestCase(theClass); &#125;private void addTestsFromTestCase(final Class&lt;?&gt; theClass) &#123; fName = theClass.getName(); try &#123; getTestConstructor(theClass); // Avoid generating multiple error messages &#125; catch (NoSuchMethodException e) &#123; addTest(warning("Class " + theClass.getName() + " has no public constructor TestCase(String name) or TestCase()")); return; &#125;// 这个类是否是public的 如果不是 发出warning ，并且fail(message) if (!Modifier.isPublic(theClass.getModifiers())) &#123; addTest(warning("Class " + theClass.getName() + " is not public")); return; &#125; Class&lt;?&gt; superClass = theClass; List&lt;String&gt; names = new ArrayList&lt;String&gt;();// 这句话说明的是如果这个类是superClass的超类，或者接口就返回true，否则返回false while (Test.class.isAssignableFrom(superClass)) &#123;// 如果是true 有顺序的返回声明的方法 for (Method each : MethodSorter.getDeclaredMethods(superClass)) &#123; addTestMethod(each, names, theClass); &#125;// 获得superclass类，递归的查找test方法 superClass = superClass.getSuperclass(); &#125; if (fTests.size() == 0) &#123; addTest(warning("No tests found in " + theClass.getName())); &#125; &#125; 最后提到的 fTests.size() == 0 这里会发生warning 然后fail。这个fTests 已经再前面声明了，声明方法是：private Vector&lt;Test&gt; fTests = new Vector&lt;Test&gt;(10); 在对每个声明的方法循环的时候，使用到 addTestMethod 方法，来对每个方法进行处理。 1234567891011121314151617181920private void addTestMethod(Method m, List&lt;String&gt; names, Class&lt;?&gt; theClass) &#123;// 获得方法名如果list数组中已经包含这个方法名，就直接退出 String name = m.getName(); if (names.contains(name)) &#123; return; &#125; if (!isPublicTestMethod(m)) &#123; if (isTestMethod(m)) &#123; addTest(warning("Test method isn't public: " + m.getName() + "(" + theClass.getCanonicalName() + ")")); &#125; return; &#125;// 把这个方法名加入到names List中 names.add(name); addTest(createTest(theClass, name)); &#125;//再来看外层的addTest方法 把拥有的test方法放到fTests中。public void addTest(Test test) &#123; fTests.add(test); &#125; 使用createTest来针对test方法创建一个Test类 123456789101112131415161718192021222324252627static public Test createTest(Class&lt;?&gt; theClass, String name) &#123; Constructor&lt;?&gt; constructor; try &#123; constructor = getTestConstructor(theClass); &#125; catch (NoSuchMethodException e) &#123; return warning("Class " + theClass.getName() + " has no public constructor TestCase(String name) or TestCase()"); &#125; Object test; // 通过反射方式获得方法的test实例 try &#123; if (constructor.getParameterTypes().length == 0) &#123; test = constructor.newInstance(new Object[0]); if (test instanceof TestCase) &#123; ((TestCase) test).setName(name);//如果继承TestCase &#125; &#125; else &#123; test = constructor.newInstance(new Object[]&#123;name&#125;); &#125; &#125; catch (InstantiationException e) &#123; return (warning("Cannot instantiate test case: " + name + " (" + Throwables.getStacktrace(e) + ")")); &#125; catch (InvocationTargetException e) &#123; return (warning("Exception in constructor: " + name + " (" + Throwables.getStacktrace(e.getTargetException()) + ")")); &#125; catch (IllegalAccessException e) &#123; return (warning("Cannot access test case: " + name + " (" + Throwables.getStacktrace(e) + ")")); &#125; return (Test) test; &#125; 经过以上的步骤获得了这个类中及其父类中的所有方法的Test。 使用testRunner.run运行test 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; junit.textui.TestRunner.run(suite()); &#125;// 使用TestRunner的run的静态方法 返回一个TestResult用来返回结果。 static public TestResult run(Test test) &#123; TestRunner runner = new TestRunner(); return runner.doRun(test); &#125;// 调用runner的doRun方法public TestResult doRun(Test test) &#123; return doRun(test, false); &#125;public TestResult doRun(Test suite, boolean wait) &#123;// 用来返回结果的TestResult TestResult result = createTestResult(); // 注册一个TestListener result.addListener(fPrinter); long startTime = System.currentTimeMillis();// test.run方法 suite.run(result); long endTime = System.currentTimeMillis(); long runTime = endTime - startTime; fPrinter.print(result, runTime); pause(wait); return result; &#125; 运行Test的核心方法 返回TestResult返回结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Creates the TestResult to be used for the test run. */protected TestResult createTestResult() &#123; return new TestResult();&#125;public synchronized void addListener(TestListener listener) &#123; // protected List&lt;TestListener&gt; fListeners; fListeners.add(listener); &#125;// suite.run() fTests中的每一个test public void run(TestResult result) &#123; for (Test each : fTests) &#123; if (result.shouldStop()) &#123; break; &#125; runTest(each, result); &#125; &#125;/** * Runs the test case and collects the results in TestResult. * 调用testResult的run方法 */public void run(TestResult result) &#123; result.run(this);&#125;// 运行testprotected void run(final TestCase test) &#123; startTest(test); Protectable p = new Protectable() &#123; public void protect() throws Throwable &#123; test.runBare();//执行runBare方法执行test用例 &#125; &#125;; runProtected(test, p); endTest(test); &#125;public void startTest(Test test) &#123; final int count = test.countTestCases(); synchronized (this) &#123; fRunTests += count; &#125; for (TestListener each : cloneListeners()) &#123; each.startTest(test); &#125; &#125; 在resultPriter中使用继承TestListener中的startTest方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void startTest(Test test) &#123; getWriter().print(".");//运行一个则加一个点 if (fColumn++ &gt;= 40) &#123; getWriter().println(); fColumn = 0; &#125; &#125;// 运行一个空的测试序列public void runBare() throws Throwable &#123; Throwable exception = null; // 设置装置。比如打开网络连接等，在执行测试之前调用方法。 setUp(); try &#123; // 看下面的runTest方法 runTest();//执行test &#125; catch (Throwable running) &#123; exception = running; &#125; finally &#123; try &#123; tearDown(); &#125; catch (Throwable tearingDown) &#123; if (exception == null) exception = tearingDown; &#125; &#125; if (exception != null) throw exception; &#125;protected void runTest() throws Throwable &#123; assertNotNull("TestCase.fName cannot be null", fName); // Some VMs crash when calling getMethod(null,null); Method runMethod = null; try &#123; runMethod = getClass().getMethod(fName, (Class[]) null); &#125; catch (NoSuchMethodException e) &#123; fail("Method \"" + fName + "\" not found"); &#125; // .......... runMethod.invoke(this); 执行方法 try &#123; runMethod.invoke(this); &#125; catch (InvocationTargetException e) &#123; // 如果方法执行错误，会触发这个异常 会连续被上层捕捉到 e.fillInStackTrace(); throw e.getTargetException(); &#125; catch (IllegalAccessException e) &#123; e.fillInStackTrace(); throw e; &#125; &#125; 如果测试失败，则最终将被runProtected中的try/catch捕捉到后输出错误信息。 123456789101112public void runProtected(final Test test, Protectable p) &#123; try &#123; p.protect(); &#125; catch (AssertionFailedError e) &#123; // 验证失败，添加一条失败信息 addFailure(test, e); &#125; catch (ThreadDeath e) &#123; // don't catch ThreadDeath by accident throw e; &#125; catch (Throwable e) &#123; addError(test, e); &#125;&#125; 经过以上的步骤执行完一个test。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit的使用和源码分析]]></title>
    <url>%2F2018%2F10%2F29%2F2018-10-28-Junit4%2F</url>
    <content type="text"><![CDATA[Junit的使用和源码分析Junit是一个编写可重复测试的Java测试框架，代码编写非常有技巧性，值得反复阅读。 跟着官方文档学习Junit官方文档往往是学习最好的资料。 简单测试例子1234567891011121314151617181920212223public class FirstTest &#123; public int add(int a, int b) &#123; return a + b; &#125; @Test public void testAdd()&#123; FirstTest firstTest = new FirstTest(); int result = firstTest.add(1,2); // assertEquals(4,result); assertEquals(3,result); &#125; &lt;!-- - 如果判断不相等的时候，后台报错信息 - java.lang.AssertionError: - Expected :4 - Actual :3 - &lt;Click to see difference&gt; --&gt;&#125; 这只是简单的例子，实际上的单元测试要比这个复杂的多，在实际应用上单元测试十分有必要，编写后台代码时能够尽快检验代码的正确性。 Assertions 断言Junit提供了所有基本数据类型，Object类和数组的断言，参数是 预期值后面是实际值，可选项，第一个参数可以是断言失败时输出的内容，与其他断言稍有不同的是，AssertThat的参数是 失败输出的内容，实际值和一个MatcherObject。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class AssertTests &#123; @Test public void testAssertArrayEquals() &#123; byte[] expected = "trial".getBytes(); byte[] actual = "trial".getBytes(); assertArrayEquals("failure - byte arrays not same", expected, actual); &#125; @Test public void testAssertEquals() &#123; assertEquals("failure - strings are not equal", "text", "text"); &#125; @Test public void testAssertFalse() &#123; assertFalse("failure - should be false", false); &#125; @Test public void testAssertNotNull() &#123; assertNotNull("should not be null", new Object()); &#125; @Test public void testAssertNotSame() &#123; assertNotSame("should not be same Object", new Object(), new Object()); &#125; @Test public void testAssertNull() &#123; assertNull("should be null", null); &#125; @Test public void testAssertSame() &#123; Integer aNumber = Integer.valueOf(768); assertSame("should be same", aNumber, aNumber); &#125; // JUnit Matchers assertThat @Test public void testAssertThatBothContainsString() &#123; assertThat("albumen", both(containsString("a")).and(containsString("b"))); &#125; @Test public void testAssertThatHasItems() &#123; assertThat(Arrays.asList("one", "two", "three"), hasItems("one", "three")); &#125; @Test public void testAssertThatEveryItemContainsString() &#123; assertThat(Arrays.asList(new String[] &#123; "fun", "ban", "net" &#125;), everyItem(containsString("n"))); &#125; // Core Hamcrest Matchers with assertThat @Test public void testAssertThatHamcrestCoreMatchers() &#123; assertThat("good", allOf(equalTo("good"), startsWith("good"))); assertThat("good", not(allOf(equalTo("bad"), equalTo("good")))); assertThat("good", anyOf(equalTo("bad"), equalTo("good"))); assertThat(7, not(CombinableMatcher.&lt;Integer&gt; either(equalTo(3)).or(equalTo(4)))); assertThat(new Object(), not(sameInstance(new Object()))); &#125; @Test public void testAssertTrue() &#123; assertTrue("failure - should be true", true); &#125;&#125; 异常测试下面分为两种方式来完成对异常的测试 期待的异常如何检测程序是否如期的抛出异常，junit可以使用注解的参数来实现。 1234@Test(expected = IndexOutOfBoundsException.class)public void testException()&#123; new ArrayList&lt;Integer&gt;().get(0);&#125; 深入的异常上述方法对于简单的情况很有用，但它有其局限性。例如，您无法在异常中测试消息的值，也无法在抛出异常后测试域对象的状态 try/catch 语句 123456789@Testpublic void testTryCatch()&#123; try &#123; new ArrayList&lt;Integer&gt;().get(0); fail("失败信息"); &#125;catch (IndexOutOfBoundsException indexOutOfBoundsExecption)&#123; assertThat(indexOutOfBoundsExecption.getMessage(), is("Index: 0, Size: 0")); &#125;&#125; rule 规则 12345678910@Rulepublic ExpectedException thrown = ExpectedException.none();@Testpublic void testExpectException()&#123; List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); thrown.expect(IndexOutOfBoundsException.class); thrown.expectMessage("Index: 0, Size: 0"); list.get(0); // execution will never get past this line&#125; Matchers and assertThat [ 匹配器和assertThat ]新加入了assertThat断言机制 assertThat([value], [matcher statement]); 1234assertThat(x, is(3));assertThat(x, is(not(4)));assertThat(responseString, either(containsString("color")).or(containsString("colour")));assertThat(myList, hasItem("3")); assertThat 更具有可读性和可输入性，并且有组合性，就像 is(not(4)) 任何Machers都可以组合起来使用 以前的assertEquals等也是可以用的，assertThat 在使用Matchers的时候需要使用 import static org.hamcrest.CoreMatchers.*;来引用。里面的方法非常多。。 junit源码跟读使用junit流程使用继承自TestCase类下面通过运行junit的自带的test，源程序为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Some simple tests. */public class SimpleTest extends TestCase &#123; protected int fValue1; protected int fValue2; @Override protected void setUp() &#123; fValue1 = 2; fValue2 = 3; &#125; public static Test suite() &#123; /* * the type safe way * TestSuite suite= new TestSuite(); suite.addTest( new SimpleTest("add") &#123; protected void runTest() &#123; testAdd(); &#125; &#125; ); suite.addTest( new SimpleTest("testDivideByZero") &#123; protected void runTest() &#123; testDivideByZero(); &#125; &#125; ); return suite; */ /* * the dynamic way */ return new TestSuite(SimpleTest.class); &#125; public void testAdd() &#123; double result = fValue1 + fValue2; // forced failure result == 5 assertTrue(result == 6); &#125; public int unused; public void testDivideByZero() &#123; int zero = 0; int result = 8 / zero; unused = result; // avoid warning for not using result &#125; public void testEquals() &#123; assertEquals(12, 12); assertEquals(12L, 12L); assertEquals(new Long(12), new Long(12)); assertEquals("Size", 12, 13); assertEquals("Capacity", 12.0, 11.99, 0.0); &#125; public static void main(String[] args) &#123; junit.textui.TestRunner.run(suite()); &#125;&#125; 来看main方法，使用 junit.textui.TestRunner.run(suite()); 使用TestRunner运行test。首先先来看suite方法，有两种方法 静态的,需要手动在testSuite中添加test。 动态的，静态需要实现TestCase的runTest方法。而动态的只需要返回 TestSuite(SimpleTest.class);，下面来看这个TestSuite类 testSuite实际上就是运行test的集合，使用vector来存储test,其中这里使用到的TestSuite构造方法是： 123456789101112131415161718192021222324252627282930313233public TestSuite(final Class&lt;?&gt; theClass) &#123; addTestsFromTestCase(theClass); &#125;private void addTestsFromTestCase(final Class&lt;?&gt; theClass) &#123; fName = theClass.getName(); try &#123; getTestConstructor(theClass); // Avoid generating multiple error messages &#125; catch (NoSuchMethodException e) &#123; addTest(warning("Class " + theClass.getName() + " has no public constructor TestCase(String name) or TestCase()")); return; &#125;// 这个类是否是public的 如果不是 发出warning ，并且fail(message) if (!Modifier.isPublic(theClass.getModifiers())) &#123; addTest(warning("Class " + theClass.getName() + " is not public")); return; &#125; Class&lt;?&gt; superClass = theClass; List&lt;String&gt; names = new ArrayList&lt;String&gt;();// 这句话说明的是如果这个类是superClass的超类，或者接口就返回true，否则返回false while (Test.class.isAssignableFrom(superClass)) &#123;// 如果是true 有顺序的返回声明的方法 for (Method each : MethodSorter.getDeclaredMethods(superClass)) &#123; addTestMethod(each, names, theClass); &#125;// 获得superclass类，递归的查找test方法 superClass = superClass.getSuperclass(); &#125; if (fTests.size() == 0) &#123; addTest(warning("No tests found in " + theClass.getName())); &#125; &#125; 最后提到的 fTests.size() == 0 这里会发生warning 然后fail。这个fTests 已经再前面声明了，声明方法是：private Vector&lt;Test&gt; fTests = new Vector&lt;Test&gt;(10); 在对每个声明的方法循环的时候，使用到 addTestMethod 方法，来对每个方法进行处理。 1234567891011121314151617181920private void addTestMethod(Method m, List&lt;String&gt; names, Class&lt;?&gt; theClass) &#123;// 获得方法名如果list数组中已经包含这个方法名，就直接退出 String name = m.getName(); if (names.contains(name)) &#123; return; &#125; if (!isPublicTestMethod(m)) &#123; if (isTestMethod(m)) &#123; addTest(warning("Test method isn't public: " + m.getName() + "(" + theClass.getCanonicalName() + ")")); &#125; return; &#125;// 把这个方法名加入到names List中 names.add(name); addTest(createTest(theClass, name)); &#125;//再来看外层的addTest方法 把拥有的test方法放到fTests中。public void addTest(Test test) &#123; fTests.add(test); &#125; 使用createTest来针对test方法创建一个Test类 123456789101112131415161718192021222324252627static public Test createTest(Class&lt;?&gt; theClass, String name) &#123; Constructor&lt;?&gt; constructor; try &#123; constructor = getTestConstructor(theClass); &#125; catch (NoSuchMethodException e) &#123; return warning("Class " + theClass.getName() + " has no public constructor TestCase(String name) or TestCase()"); &#125; Object test; // 通过反射方式获得方法的test实例 try &#123; if (constructor.getParameterTypes().length == 0) &#123; test = constructor.newInstance(new Object[0]); if (test instanceof TestCase) &#123; ((TestCase) test).setName(name);//如果继承TestCase &#125; &#125; else &#123; test = constructor.newInstance(new Object[]&#123;name&#125;); &#125; &#125; catch (InstantiationException e) &#123; return (warning("Cannot instantiate test case: " + name + " (" + Throwables.getStacktrace(e) + ")")); &#125; catch (InvocationTargetException e) &#123; return (warning("Exception in constructor: " + name + " (" + Throwables.getStacktrace(e.getTargetException()) + ")")); &#125; catch (IllegalAccessException e) &#123; return (warning("Cannot access test case: " + name + " (" + Throwables.getStacktrace(e) + ")")); &#125; return (Test) test; &#125; 经过以上的步骤获得了这个类中及其父类中的所有方法的Test。 使用testRunner.run运行test 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; junit.textui.TestRunner.run(suite()); &#125;// 使用TestRunner的run的静态方法 返回一个TestResult用来返回结果。 static public TestResult run(Test test) &#123; TestRunner runner = new TestRunner(); return runner.doRun(test); &#125;// 调用runner的doRun方法public TestResult doRun(Test test) &#123; return doRun(test, false); &#125;public TestResult doRun(Test suite, boolean wait) &#123;// 用来返回结果的TestResult TestResult result = createTestResult(); // 注册一个TestListener result.addListener(fPrinter); long startTime = System.currentTimeMillis();// test.run方法 suite.run(result); long endTime = System.currentTimeMillis(); long runTime = endTime - startTime; fPrinter.print(result, runTime); pause(wait); return result; &#125; 运行Test的核心方法 返回TestResult返回结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Creates the TestResult to be used for the test run. */protected TestResult createTestResult() &#123; return new TestResult();&#125;public synchronized void addListener(TestListener listener) &#123; // protected List&lt;TestListener&gt; fListeners; fListeners.add(listener); &#125;// suite.run() fTests中的每一个test public void run(TestResult result) &#123; for (Test each : fTests) &#123; if (result.shouldStop()) &#123; break; &#125; runTest(each, result); &#125; &#125;/** * Runs the test case and collects the results in TestResult. * 调用testResult的run方法 */public void run(TestResult result) &#123; result.run(this);&#125;// 运行testprotected void run(final TestCase test) &#123; startTest(test); Protectable p = new Protectable() &#123; public void protect() throws Throwable &#123; test.runBare();//执行runBare方法执行test用例 &#125; &#125;; runProtected(test, p); endTest(test); &#125;public void startTest(Test test) &#123; final int count = test.countTestCases(); synchronized (this) &#123; fRunTests += count; &#125; for (TestListener each : cloneListeners()) &#123; each.startTest(test); &#125; &#125; 在resultPriter中使用继承TestListener中的startTest方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void startTest(Test test) &#123; getWriter().print(".");//运行一个则加一个点 if (fColumn++ &gt;= 40) &#123; getWriter().println(); fColumn = 0; &#125; &#125;// 运行一个空的测试序列public void runBare() throws Throwable &#123; Throwable exception = null; // 设置装置。比如打开网络连接等，在执行测试之前调用方法。 setUp(); try &#123; // 看下面的runTest方法 runTest();//执行test &#125; catch (Throwable running) &#123; exception = running; &#125; finally &#123; try &#123; tearDown(); &#125; catch (Throwable tearingDown) &#123; if (exception == null) exception = tearingDown; &#125; &#125; if (exception != null) throw exception; &#125;protected void runTest() throws Throwable &#123; assertNotNull("TestCase.fName cannot be null", fName); // Some VMs crash when calling getMethod(null,null); Method runMethod = null; try &#123; runMethod = getClass().getMethod(fName, (Class[]) null); &#125; catch (NoSuchMethodException e) &#123; fail("Method \"" + fName + "\" not found"); &#125; // .......... runMethod.invoke(this); 执行方法 try &#123; runMethod.invoke(this); &#125; catch (InvocationTargetException e) &#123; // 如果方法执行错误，会触发这个异常 会连续被上层捕捉到 e.fillInStackTrace(); throw e.getTargetException(); &#125; catch (IllegalAccessException e) &#123; e.fillInStackTrace(); throw e; &#125; &#125; 如果测试失败，则最终将被runProtected中的try/catch捕捉到后输出错误信息。 123456789101112public void runProtected(final Test test, Protectable p) &#123; try &#123; p.protect(); &#125; catch (AssertionFailedError e) &#123; // 验证失败，添加一条失败信息 addFailure(test, e); &#125; catch (ThreadDeath e) &#123; // don't catch ThreadDeath by accident throw e; &#125; catch (Throwable e) &#123; addError(test, e); &#125;&#125; 经过以上的步骤执行完一个test。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中Deque和ArrayDeque]]></title>
    <url>%2F2018%2F10%2F26%2F2018-10-24-Java%E4%B8%ADDeque%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java中Deque和ArrayDequeDeque类一个线性的可在双端插入、删除节点的结构。他名字时Deque，实际上时“double ended queue”的简写； ArrayDeque类对于ArrayDeque中的数组，它是一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始，数组的长度、第一个和最后一个元素都与head和tail这两个变量有关 构造方法ArrayDeque就像他的名字一样，使用Array数组来实现Deque结构。构造方法和以前提到的ArrayList相似。 1234567891011121314public ArrayDeque() &#123;// 初始化的数组大小是16 elements = new Object[16]; &#125;public ArrayDeque(int numElements) &#123; allocateElements(numElements); &#125;public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); // addAll方法就是为c 进行for循环添加 addAll(c); &#125; 添加和移除方法 add方法 1234567891011121314151617181920212223// 在前面添加元素，也就是在数组的第一个位置上加元素public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); // 在前面添加的时候，head-1 的位置上插入 e elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); &#125;public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); 添加到下一个位置 elements[tail] = e; /* * 如果当前添加位置的下一个位置 与上 长度-1 *（因为长度都是2的倍数，所以-1之后，2进制后几位都是1，保证负数的时候也能够找到正确的索引） * 如果tail和head相等说明数组满了，需要扩容 */ if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; 有了这两种方法，队列或者栈的方法都可以轻松实现了。 在进行增加元素的时候涉及到 doubleCapacity 这个方法，这个方法主要用来扩充数组的容量。 123456789101112131415private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素的个数 int newCapacity = n &lt;&lt; 1; // 扩充为原来的2倍 if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; //创建新数组 Systkkem.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p);// 两部copy数组相当于从 head -&gt; tail 重新排序了 elements = a; head = 0; tail = n; &#125; remove方法 1234567891011121314151617181920212223public E remove() &#123; return removeFirst(); &#125;public E removeFirst() &#123; E x = pollFirst(); if (x == null) throw new NoSuchElementException(); return x; &#125;public E pollFirst() &#123; int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot // 把element的头部位置置空后，将head向前移 head = (h + 1) &amp; (elements.length - 1); return result; &#125; toArray方法 toArray方法主要是方便输出。用来真正的按照逻辑顺序，进行物理重排，实现方法和doubleCapacity实现相同。 12345678910111213141516public Object[] toArray() &#123; return copyElements(new Object[size()]); &#125;private &lt;T&gt; T[] copyElements(T[] a) &#123; if (head &lt; tail) &#123; // 如果顺序正常 System.arraycopy(elements, head, a, 0, size()); &#125; else if (head &gt; tail) &#123; // 否则将head右侧的先copy到数组中，在copy剩下的 int headPortionLen = elements.length - head; System.arraycopy(elements, head, a, 0, headPortionLen); System.arraycopy(elements, 0, a, headPortionLen, tail); &#125; return a; &#125; size方法 和很多数据结构类不同的是，他的size并不是依靠本身的变量字段进行维护，而是通过size方法计算而来。 123public int size() &#123; return (tail - head) &amp; (elements.length - 1); &#125; 总结一下，ArrayDeque实现了双端队列的特点，能够完成栈和队列的功能，效率比同样继承Deque的LinkedList效率高，因为在ArrayDeque中的计算大部分为位运算。ArrayDeque逻辑上循环的数组，但实际上并不是。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的栈和队列]]></title>
    <url>%2F2018%2F10%2F18%2F2018-10-17-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[java中的栈和队列 Stack 栈 push方法和pop方法 peek方法 Queue 队列 offer 方法和 pull方法 add方法和remove方法 java中的栈和队列Stack 栈栈是一个后进先出的数据结构，有这样的数据结构功能的还有Dequ类，推荐使用Dequ push方法和pop方法push方法是向栈顶放值 123456789101112public E push(E item) &#123;// 这里调用父类Vector的addElement方法 addElement(item); return item; &#125;// addElement方法是加锁的方法 调用element实际上就是数组长度加一并且在该问之上付值public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; pop方法是在将栈顶的值出栈 12345678910// 同样加锁的方法 调用方法 移除在数组最后位置的元素public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; peek方法peek方法是看一下栈顶元素的值，但不做任何操作 1234567public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; 这几个方法和linkedList类中的对应的方法非常像，所以其实LindedList也可以当作栈用。 Queue 队列队列和栈相反，是一个先进后出的数据结构，想成现实中的排队再明白不过了。 offer 方法和 pull方法offer方法可以将元素放入队列当中，pull可以将元素从头部移除。 add方法和remove方法add和remove方法分别调用offer和pull方法，不同的是，如果队列满了，add方法会抛出异常，而offer方法会返回null。如果队列空了，remove方法会抛出异常，而pull方法会返回null。 以后会提及队列的实现类以及Dequ相关类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Enum枚举类分析和相关拓展]]></title>
    <url>%2F2018%2F10%2F16%2F2018-10-15-Enum%E7%B1%BB%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Enum枚举类分析和相关拓展其实我认为使用枚举类就是对使用常量的扩充，例如类中使用类型，分类相同的类变量的时候，可以考虑使用枚举类来替换掉。 参考了网上的文章，大致有两个好处，第一是确定传入的参数类型。而不是形参是int类型，随便一个int类型就能够满足。第二是对比static静态变量更能够确定变量的意义。下面举一个例子来看。 Enum类实例123456789101112131415161718192021/* 列举简单的行驶工具 */public enum trafficTool &#123; BIKE,CAR,BUS,TRAIN,AIRPLANE&#125;public class TrafficToolTest &#123; public void chooseTool(TrafficTool trafficTool)&#123; switch (trafficTool)&#123; case BIKE: System.out.println("自行车");break; case CAR: System.out.println("汽车");break; &#125; &#125; public static void main(String[] args) &#123; TrafficToolTest trafficToolTest = new TrafficToolTest(); trafficToolTest.chooseTool(TrafficTool.BIKE); &#125;&#125; 和普通的类一样，同样也可以添加构造方法 12345678910SPRING("春天"),SUMMER("夏天"),FALL("秋天"),WINTER("冬天");private final String name;SeasonEnum(String name)&#123; this.name = name;&#125;String getName()&#123; return name;&#125; 也可以继承 123456789101112131415161718192021222324252627282930313233public enum SeasonEnum &#123; SPRING("春天") &#123; @Override public String comm() &#123; return "这是春天"; &#125; &#125;,SUMMER("夏天") &#123; @Override public String comm() &#123; return "这是夏天"; &#125; &#125;,FALL("秋天") &#123; @Override public String comm() &#123; return "这是冬天"; &#125; &#125;,WINTER("冬天") &#123; @Override public String comm() &#123; return "这是冬天"; &#125; &#125;; private final String name; SeasonEnum(String name)&#123; this.name = name; &#125; String getName()&#123; return name; &#125; public abstract String comm();&#125; 以上是枚举类的基本使用。 EnumMap 和 EnumSetpublic class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K, V&gt; 这是关于EnumMap的继承关系。可以发现这是key为枚举类的一个Map。 12345/* 简单创建，以后就可以实现枚举类的多种复用 */EnumMap&lt;SeasonEnum,Integer&gt; enumIntegerEnumMap = new EnumMap&lt;SeasonEnum, Integer&gt;(SeasonEnum.class);Set&lt;SeasonEnum&gt; set = enumIntegerEnumMap.keySet();enumIntegerEnumMap.put(SeasonEnum.SPRING,1);System.out.println(enumIntegerEnumMap.get(SeasonEnum.SPRING)); EnumSet 相对于 EnumMap 等同于 hashSet 相对于 HashMap 的存在，很好理解。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet和HashTable的的源码分析]]></title>
    <url>%2F2018%2F10%2F16%2F2018-10-15-HashSet%E5%92%8CHashTable%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashSet和HashTable的的源码分析 HashSet HashSet结构源码 HashSet的基本方法 HashSet的Iterator和contains方法 HashTable HashSet和HashTable的的源码分析HashSetHashSet其实就是使用HashMap来实现的，方法都是依靠Hash Map的方法。如hashSet构造，hashSet的添加等操作。这样能够实现hashset去重。因为hashMap的key不能重复。这样就能看上篇，当hashMap遇到key值重复的处理。 HashSet结构源码HashSet的结构就相当于HashMap只将key值put进去，但是Value值却为空的new Object。可以看作为只有key的HashMap. 12345678910111213141516171819202122/* 可以看到hashSet的这几个构造方法和HashMap息息相关 */private transient HashMap&lt;E,Object&gt; map;public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; HashSet的基本方法add和remove和size等基本方法都是调用HashMap的 如add方法: 1234public boolean add(E e) &#123; /* 这里的PRESENT等于new Object() */ return map.put(e, PRESENT)==null; &#125; HashSet的Iterator和contains方法同样的也是调用的HashMap的基本方法，但是需要先得到Map的keySet集合 1234567public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125;public boolean contains(Object o) &#123; return map.containsKey(o);&#125; HashTable首先HashTable和HashMap的结构类似。但是有最重要的区别就是HashTable是synchronized的，也就是线程安全的。在他的基本方法前都有synchronized锁所限制。 结构就不看了，只看一个Put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 其实大致和HashMap是类似的也是使用Entry作为基本结构 */public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); /* 这里的0x7FFFFFFF 是32-bit的int的最大值 */ int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings("unchecked") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; /* 如果这个entry存在，也就是键值重复 */ for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; /* 否则添加Entry节点 */ addEntry(hash, key, value, index); return null; &#125; private void addEntry(int hash, K key, V value, int index) &#123; modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; /* 如果当前count大于阈值的大小 重新生成table size和hash值 */ // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. @SuppressWarnings("unchecked") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 通过上面的代码可以看出HashTable和HashMap的结构还是有差异的，HashMap是纵向的列表当出现相同的hash值的时候，扩展出横向列表，当横向的列表到达一定的长度的时候，这个横向的链表就会自动整理成红黑树的形式，而hashTable不存在横向的这种结构的，当count&gt;=阈值的时候就会把Hash重置，使之不会出现hash值重复的情况。可以说hashTable比较hashMap的结构更简单，但是效率会比HashMap的低。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap的源码查看]]></title>
    <url>%2F2018%2F10%2F11%2F2018-10-10-hashmap%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[HashMap的源码查看 HashMap结构源码 基本属性 依赖的数据结构 Node节点 hashMap的三个构造方法 hashMap的方法源码 put方法 在看get方法之前先看和put方法息息相关的resize方法 get方法 remove方法 keySet方法 HashMap的源码查看HashMap结构源码基本属性123456789101112131415161718192021222324 /* 实际上结构就是一个node数组 */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). * 得到entryset */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. map的大小 */ transient int size;/* 操作次数 */ transient int modCount; /* 临界值，如果超过临界值就会自动扩充数组 */ int threshold; /* 加载因子 */ final float loadFactor; 依赖的数据结构Node节点首先看到hashmap中的node类继承了map.Entry&lt;k,v&gt;结构，有类型为K的key和类型为V的value；其次node是一个链表结构。 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;/* node的构造方法 */ Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; hashMap的三个构造方法12345678910111213141516171819202122232425262728/* 第一个参数 是默认的初始化阈值大小，第二个是加载因子大小 */public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) /* 如果制定的初始化阈值小于0 */ throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;/* 使用this调用上面的方法 */public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * 使用默认的阈值和因子，大小分别为16和0.75 * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; hashMap的方法源码hashMap中最重要的当然是put和get方法了，就要先从这两个最重要的方法入手。 put方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public V put(K key, V value) &#123; /* 调用putVal方法 */ return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * * @param hash hash for key key的hash码 * @param key the key key值 * @param value the value to put value值 * @param onlyIfAbsent if true, don't change existing value 如果是true 不改变当前值 * @param evict if false, the table is in creation mode. 如果是false，那么table就属于创建模式 （？） * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) /* 当Map为空的时候 这时候tab为16也就是n为16*/ /* 这是当map中的内容为空的时候 * newCap = DEFAULT_INITIAL_CAPACITY; * newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); */ n = (tab = resize()).length; /* 如果当前tab的length&amp;hash值再tab列表中不重复 */ if ((p = tab[i = (n - 1) &amp; hash]) == null) /* 新建一个noede 再tab[i]的位置上 */ tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; /* 当添加重复的key的时候 这时候hash和key的值都相等，就相当于不添加 */ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) /* 如果e是treeNode的时候 */ e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st /* 如果当前列表中的长度大于等于 8-1 的时候，把这个列表整理成树形结构 */ treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; /* 如果当前size大于threshold的时候扩充table */ if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 在看get方法之前先看和put方法息息相关的resize方法我理解的 hashMap 大致形状，总体为纵向拓展，如果 hash&amp;length-1 的值重复的话，说明位置冲突，首先会加在这个位置元素后面，如果大小超过 TREEIFY_THRESHOLD - 1 的时候自动为这列整理成树形状。这样就会变为纵向列表，横向列表或树的结构。 在未重复hash的前提下，如果table的大小超过设置的 threshold 的大小的时候，就会触发 resize 方法。下面就来看看resize方法的代码结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //newcap是oldcap的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; //循环原table数组 ？因为在扩容后 hash &amp; (size-1) 的位置发生了变化 ，所以应当进行重排 Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null)//说明e不存在hash冲突 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; //再去循环bin next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; //如果在低位 （老）数组中也就是元素hast和就数组取模为0时，说明重排后仍在老数组内 if (loTail == null) loHead = e; else loTail.next = e; loTail = e;//递归向下继续排 &#125; else &#123;//否则在高位数组中 ，也就是在扩容出来的数组中 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; //低位数组还是在原来的位置上 &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; //高位数组在旧数组+j的位置上 &#125; &#125; &#125; &#125; &#125; return newTab; &#125; get方法get方法是根据hash和key值进行查找,同理containKey方法也是调用getNode方法进行判断。 12345678910111213141516171819202122232425public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // 先回检查第一个节点 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; /* 从第二个节点开始循环 查找hash和key分别相同 */ if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; remove方法使用remove方法根据key移除节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;/** * Implements Map.remove and related methods * * @param hash key的hash值 * @param key 键值 * @param value 如果想匹配的话就是value，否则空 * @param matchValue 如果是ture那么就移除和value equal的 * @param movable 如果是false的话，移除这个节点不要移动其他节点 * @return the node, or null if none */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; /* 确定节点 */ if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; /* 如果hash值相同 key值也相同 说明就是这个节点 */ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; /* 否则横向查找下一个节点 */ if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; /* 省略-------- */ &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); /* 接下来把tab中对应的index remove掉 */ else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; keySet方法ketSet方法也是经常用到的方法，keySet方法实际上就是返回新建的keyset结构。具体结构可以看如下代码，可以看到只有使用forEach和Iterator方法的时候才会循环tab来找key的set数据。数据结构中都是调用外部方法的方法。 123456789101112131415161718192021222324252627final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; //返回当前size public final void clear() &#123; HashMap.this.clear(); &#125; //直接调用hashMap的clear方法 public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; /* 把当前操作数记下来 */ for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 这是几个非常常用的hashMap的方法和基本的数据结构源码的分析查看。就当做笔记记录一下。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList的源码查看]]></title>
    <url>%2F2018%2F10%2F08%2F2018-10-08-LinkedList%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[LinkedList的源码查看 结构源码 依靠结构 LinkedList构造函数 基本方法 添加 移除 remove方法 removeFirst removeLast 和removeFirst同理 赋值取值操作 get方法 set方法 LinkedList中的栈操作 peek方法 poll方法 push方法 pop方法 offer方法 LinkedList的源码查看结构源码依靠结构12345678910111213141516/* LinkedList的内部变量 可以看出LinkedList其实就是一个链表 */transient int size = 0;/** * 指向首节点 * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * 指向尾节点 * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last; 123456789101112/* 内部node实现 */private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;/* 双向链表 */ Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 空构造函数 比较常用 */public LinkedList() &#123; &#125;/* 有collection参数的构造函数 */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;/* 参数：当前数量也就是要得到当前链表的位置 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; // 对插入前情况的判断 if (index == size) &#123;// 如果在尾部插入 pred=最后一个节点 succ = null; pred = last; &#125; else &#123;// 否则在中部插入 succ=当前节点 pred=前一节点/* - - - - - - - - - *//* ^ ^ *//* 1 2 如果想在2位置插入元素，前一个元素不动，将后面的元素后移*/ succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o;//构造方法 前节点/内容/后节点 始终pred是前置节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null)//如果pred==null 说明 本身列表开始就是空的或者在开头插入元素 first = newNode; else//否则在后面插入newNode pred.next = newNode;//向后循环节点 pred = newNode; &#125;//如果succ==null 说明到最后一个节点后位置 将最后的元素pred赋值给last if (succ == null) &#123; last = pred; &#125; else &#123; /* 否则插入在succ前 */ pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 基本方法添加12345678910/* add方法默认调用linklast方法，也就是向后添加元素 */public boolean add(E e) &#123; linkLast(e); return true;&#125;/* 同样有addLast 达到相同的目的，就是不返回任何东西 */public void addLast(E e) &#123; linkLast(e); &#125; 12345678910111213141516/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; /* 获得最后一个元素当作该节点的前置节点 */ final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); /* 把当前节点付给last */ last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 当然也可以调用方法在最前面添加元素 123456789101112131415public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; 移除remove方法123456789101112131415161718192021222324252627282930313233public E remove(int index) &#123; /* 先判断是否越界 */ checkElementIndex(index); return unlink(node(index)); &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev;/* 如果prev是空 说明当前元素是第一个元素 */ if (prev == null) &#123; first = next; &#125; else &#123; /* 当前节点与前后节点断绝链接 */ prev.next = next; x.prev = null; &#125;/* 如果是最后一个元素 */ if (next == null) &#123; last = prev; &#125; else &#123; /* 当前节点与前后节点断绝链接 因为LinkedList是双向链表 */ next.prev = prev; x.next = null; &#125;/* 置空 */ x.item = null; size--; modCount++; return element;&#125; removeFirst12345678910111213141516171819202122public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; removeLast 和removeFirst同理赋值取值操作get方法12345public E get(int index) &#123; checkElementIndex(index); /* 得到index处节点的item信息 */ return node(index).item;&#125; set方法12345678public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; /* set方法会返回原来的值 */ return oldVal;&#125; LinkedList中的栈操作peek方法12345678910/** * Retrieves, but does not remove, the head (first element) of this list. * 只是检索栈首元素，但并不弹出 * @return the head of this list, or &#123;@code null&#125; if this list is empty * @since 1.5 */public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; 同理 peekFirst 和 peekLast poll方法12345678910/** * Retrieves and removes the head (first element) of this list. * 检索并且移除栈首元素 unlinkFirst是可以返回移除元素的 * @return the head of this list, or &#123;@code null&#125; if this list is empty * @since 1.5 */public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; 同理 pollFirst 和 pollLast push方法123456789101112/** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * 在栈首堆一个元素 * &lt;p&gt;This method is equivalent to &#123;@link #addFirst&#125;. * * @param e the element to push * @since 1.6 */public void push(E e) &#123; addFirst(e);&#125; pop方法1234567891011121314/** * Pops an element from the stack represented by this list. In other * words, removes and returns the first element of this list. * 出栈 * &lt;p&gt;This method is equivalent to &#123;@link #removeFirst()&#125;. * * @return the element at the front of this list (which is the top * of the stack represented by this list) * @throws NoSuchElementException if this list is empty * @since 1.6 */public E pop() &#123; return removeFirst();&#125; offer方法实际上 offer 是调用的 add 方法，但是区别就在 linkedlist 继承了 Dequ 和 List 父类。一般当 queue 用的时候要用 offer/push/pop 而当使用 list 的时候用 add/remove 。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList的源码查看]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-04-ArrayList%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[ArrayList的源码查看 结构源码 常用方法源码 ArrayList的源码查看结构源码1234567891011121314151617181920212223242526272829303132333435/* 没有参数的情况下 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/* 默认是拥有默认容量（10）的空的 array list */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/* 这个默认的容量是定义好的10 */ private static final int DEFAULT_CAPACITY = 10;/* 当参数是容量的大小的时候 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; /* 如果自定义初始容量大小*/ this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; /* 如果参数小于0 报参数异常的错误（IllegalArgumentException） */ throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;/* 当参数是一个Collection结构的时候 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) /* 如果不是object类型的话 转换成object类型 */ elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 常用方法源码 add 添加方法 1234567891011121314151617181920212223242526272829303132333435363738394041/* 只有一个参数的添加 */public boolean add(E e) &#123; /* 扩充容量 */ ensureCapacityInternal(size + 1); // Increments modCount!! /* ArrayList其实就是个数组 将新add的值放到数组的最后面 */ elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; /* 如果是空的话返回 默认或当前 */ if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;private void ensureExplicitCapacity(int minCapacity) &#123; /* The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. */ modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) /* 如果当前的容量大于给定的长度的时候 需要扩充 */ grow(minCapacity); &#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 原长度 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新长度 右移运算。长度为1.5倍的原长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; remove 移除元素方法 12345678910111213141516171819202122232425262728293031323334public E remove(int index) &#123; rangeCheck(index); //如果超出 IndexOutOfBoundsException modCount++; E oldValue = elementData(index); /* 想要移除元素的位置 */ int numMoved = size - index - 1; if (numMoved &gt; 0) /* arraycopy是个native方法 相当于把index+1位置上的元素挪到index位置上 */ System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/* 只会移除第一个符合条件的条目 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; /* 这个fastRemove方法和上面的方法大相径庭 */ fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; contain 是否包含 1234567891011121314151617public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125;public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; /* 内部就是for循环一个一个判断的 */ for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; get 方法 123456789public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;/* 本质就是返回数组位置的元素 */E elementData(int index) &#123; return (E) elementData[index]; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整理并学习stackOverFlow上的热门回答]]></title>
    <url>%2F2018%2F07%2F25%2F2018-07-25-stackOverFlow%E4%B8%8A%E7%9A%84%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基础Java知识平常没事的时候会逛逛stackOverFlow,上面有很多非常基础的问题，并且回答者讲解的非常的透彻，我想通过整理上面的热门回答来梳理一下自己的Java基础知识。 热门什么是NullPointerExpection,如何去尽可能的避免当你声明一个引用变量(对象)的时候，实际上是创建一个指向该对象的指针。参考如下代码 12int x ;x = 10 ; 在例子中，我们声明了变量 x 。因为是原始类型，系统会默认付给变量x初始值是0。但是第二行使用x=10，将数值10付给变量x，实际过程是将10写入变量x所指向的内存位置。然而，当我们声明一个引用类型，对于int来说也就是其包装类型。会出现不一样的情形。 12Integer num;num = new Integer(10); 当你创建num的时候，系统不会默认创建一个默认值，因为他引用对象，然而，他会包含一个指针，这个指针虽然存在，但是他没有初始值，所以java会将变量的指针指向空(null)。在第二行使用new关键字实例化了num，这时，会将变量num指针指向这个实例对象。 在当用到这个变量之前未给变量做实例化时，也就是变量的指针还指向空时，运行后会出现NullPointerExpection 这个问题。 可能觉得在实际codeing的时候不会出现上面的问题，但是实际上，每个方法的引用对象如果不判断传进来的值是否非空，都可能会出现这个问题 错误的示范： 12345public void doSomething(SomeObject obj) &#123; //do something to obj&#125;// 调用的时候 传递null值时,会出现空指针异常doSomething(null); 正确的示范： 1234567public void doSomething(SomeObject obj) &#123; if(obj != null) &#123; //do something &#125; else &#123; //do something else &#125;&#125; 尽量在每次开发的过程当中，仔细斟酌变量是否可能为空，当可能为空时一定要做这种判断来预防空指针。保证代码的健壮性。 如何比较字符串在当使用 == 比较字符串是可能会出现bug，这时可以用equals解决。所以引出一个问题，什么时候使用 == 什么时候使用equals 主要有两方面的差异： == 是比较对象引用，也就是真正的比较两个对象或者变量的地址是否是相同的。而equals比较的是值是否相等。 == 没有非空的判断，而equals如果比较的对象如果是空则会出现异常，所以一般使用equals的方法都是使用已知的非空对象.equals(Object) 如 &quot;hello&quot;.equals(x) equals是Object的方法，大部分类中也重写了equals方法，所以在比较对象的时候应该使用equals,而当比较基本数据类型如int的时候可以使用 == Java是传值还是传引用Java是传值的 。但是，通常我们定位值的时候称他为 “引用” 。具一个非常典型的例子 123456789101112131415public static void main(String[] args) &#123; Dog aDog = new Dog("Max"); // we pass the object to foo foo(aDog); // aDog variable is still pointing to the "Max" dog when foo(...) returns aDog.getName().equals("Max"); // true aDog.getName().equals("Fifi"); // false&#125;public static void foo(Dog d) &#123; d.getName().equals("Max"); // true // change d inside of foo() to point to a new Dog instance "Fifi" d = new Dog("Fifi"); d.getName().equals("Fifi"); // true&#125; 虽然foo方法内改变了传进来的aDog的值，注意这里是 值，所以在调用完foo方法之后再去判断变量aDog的时候他的引用到的值没有变，变的只是当时传进去的值而不是变量的应用，所以可以说，对象的引用是按值传递的。如果这样还是迷糊的话，还可以逆向来想，如果是传引用的话，在当foo方法改变了aDog的时候，也就是说明改变了aDog所引用到的真正的这个值。这样是不能成立。 所以不管怎么想：Java是传值的！！ 怎样快速打印出array数组内的值因为array并没有实现toString()方法，所以当使用array.toString()的时候会打印出类似 [I@17f052a3 的地址信息，在jdk1.5之后可以使用 1234int[] x = new int[]&#123;1,2,3,4,5&#125;;String arrayString = Arrays.toString(x);System.out.println(arrayString);//结果： [1, 2, 3, 4, 5] 这样的方式可以非常方便的打印出数组内所有元素,嵌套数组可以使用deepToString方法。 1234System.out.println(Arrays.toString(deepArray));//output: [[Ljava.lang.String;@106d69c, [Ljava.lang.String;@52e922]System.out.println(Arrays.deepToString(deepArray));结果：[[John, Mary], [Alice, Bob]]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash相关问题总结]]></title>
    <url>%2F2018%2F07%2F13%2F2018-07-12-bash%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[bash相关问题总结七月专题 - -关于bash中的 &lt;&lt;&lt; 的含义在StackOverflow中有个例子非常的详细。。先贴连接 What does &lt;&lt;&lt; mean? 以下是我的渣翻译，可能会翻译错。。 我们可以这样对字符串进行处理 1echo &quot;$string&quot; | command 然而在bash中，这样写（使用管道）就相当于把命令分到子shell中进行处理，考虑这种情况 12echo &quot;hello world&quot; | read first secondecho $second $first 它会输出一个空行，子shell成功的读到了两个变量，但是随后子shell退出，两个变量就消失掉了。所以输出是没有结果的。应当这样写 1234echo &quot;hello world&quot; | &#123; read first second echo $second $first&#125; 但是这样还是没有解决这种分成子shell去执行的尴尬。这时候就能够使用 &lt;&lt;&lt; 了 1read first second &lt;&lt;&lt; echo &quot;hello world&quot; 关于${!var} var是变量名使用${!var}的作用是当ver不存在的时候会原样输出，也就是显示${var} 关于bash中的trap命令的使用trap可以强化bash脚本，让脚本更加稳定。 trap的使用方式trap有三种使用方式，对应这不同的对信号的回应方式。 trap ”something“ signal 其中”something“ 是在接受signal信号之后作出的命令 trap signal trap不指定任何命令，接受信号的默认操作，默认操作是结束进程的运行 trap “” signal trap命令指定一个空命令串，允许忽视信号 常用信号 HUB(1) 挂起，通常因终端掉线或用户退出而引发 INT(2) 中断，通常因按下Ctrl+C组合键而引发 QUIT(3) 退出，通常因按下Ctrl+/组合键而引发 ABRT(6) 中止，通常因某些严重的执行错误而引发 ALRM(14) 报警，通常用来处理超时 TERM(15) 终止，通常在系统关机时发送 KILL(9) 杀死进程 STOP 停止进程执行 更过的信号 可以使用 trap -l 命令来查看]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 中的快捷键]]></title>
    <url>%2F2018%2F07%2F13%2F2018-07-15-idea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IDEA 中的快捷键以前经常用idea开发，但是竟然没有怎么使用到idea的快捷键。。没有真正的使用到idea中非常重要的特性。今天正好看到了有一篇微信公众号里文章总结了关于常用的idea快捷键。遂而也想小小总结一下，希望在以后的开发中多用快捷键，提高开发效率。 代码 ctrl+alt+o = 优化导入的包 alt+insert = 加入代码 ctrl+alt+T = 生成try–catch结构 alt+回车 = 导入包 ctrl+alt+l = 格式化代码 ctrl+e = 最近更改的代码 Shift+F6 = 重构-重命名 包、类、方法、变量、甚至注释等 搜索 ctrl+Shift+backspace =回到上次编辑的地方 ctrl+alt+left/right = 回到前后编辑的地方 Shift+Shift 在目录中查找类 ctrl+n 查找类 ctrl+Shift+n 查找文件 ctrl+e 打开最近文件 ctrl+f 文件内容查找 ctrl+shift+f 全局内容查找 ctrl+w 快速选中 ctrl+b/ctrl+alt+b 对应这回溯到父类和到子类的快捷键 对行的删除，复制，粘贴操作可以使用vim插件来实现最后vim的十大快捷键（copy的）Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T 另外补充 alt+1 project视图 alt+7 类方法结构 alt+home 显示导航栏 shift+f6 重命名 ctrl+shift+加号 折叠代码 关闭tab页其实是有必要的]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十六） bash学习终章]]></title>
    <url>%2F2018%2F07%2F08%2F2018-07-06-bash_15_%E7%BB%88%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[bash学习终章学习bash有很长时间了，很多时间花费在学习基础语法上，没有真正的上手实践编写一些使用的bash脚本，接下来我把剩余的比较常见的bash语法学习完，找一些github上的的大牛写过的bash脚本去先分析，然后自己边理解边实践吧，我的目标就是能够基本熟练的使用bash脚本。 bash的list结构这里所说到的list结构不是Java语言中的list结构，而是在做条件的时候的一种链式机构，可以使用 &amp;&amp; 或者 || 来处理多个命令的方法。 其中分为两种简单的结构 和结构 （and list） 这种结构会同时比较多个命令，如果前一个命令返回true，则下一个命令一次去执行。但是如果前一个命令返回false，那么后面都不去执行（命令链终止）。 12# command-1 &amp;&amp; command-2 &amp;&amp; command-3 &amp;&amp; ... command-nif [ ! -z &quot;$1&quot; ] &amp;&amp; echo &quot;Argument #1 = $1&quot; &amp;&amp; [ ! -z &quot;$2&quot; ] &amp;&amp; 与结构 （or list） 这个结构和 and list正好相反，如果前一个命令返回false，则下一个命令依次去执行。如果前一个命令时ture，那么终止命令链。 12# command-1 || command-2 || command-3 || ... command-n[ ! -f &quot;$file&quot; ] || (rm -f $file; echo &quot;File \&quot;$file\&quot; deleted.&quot;) bash中的数组数组也是非常常见的一种数据结构，那么在bash中如何初始化和使用数组呢 12345678# 第一种方式为数组赋值area[11]=23area[13]=37area[51]=UFOs# 第二种方式area2=( zero one two three four )# 第三种方式area3=([17]=seventeen [24]=twenty-four) 可以看到可以方便的使用小括号进行数组的初始化，以后会接触到更多关于bash数组的实例，比如写一个使用bash的冒泡排序。 Linux中的 /dev和 /proc /dev 是设备文件的目录，可以看出来dev时device设备的缩写。如果想查看某些特定设备的文件，可以直接去对应的 /dev/*的目录下面去找对应的目录就行了。 作为参考 /dev/hd[a-t]：IDE设备 /dev/sd[a-z]：SCSI设备 /dev/fd[0-7]：标准软驱 /dev/md[0-31]：软raid设备 /dev/loop[0-7]：本地回环设备 /dev/ram[0-15]：内存 /dev/null：无限数据接收设备 ,相当于回收站 /dev/zero：无限零资源 /dev/tty[0-63]：虚拟终端 /dev/ttyS[0-3]：串口 /dev/lp[0-3]：并口 /dev/console：控制台 /dev/fb[0-31]：framebuffer /dev/cdrom =&gt; /dev/hdc /dev/modem =&gt; /dev/ttyS[0-9] /dev/pilot =&gt; /dev/ttyS[0-9] /proc 可以看作是一个文件系统，但是是伪文件系统，因为他之存储一些当前内核状态的一系列特殊文件。以下就不详细举例了，可以看看这个文件夹下的内容。使用 cat命令或者less之类的查看。 bash中的null和0bash中的null和zero是通过设备资源文件 /dev/null , /dev/zero 来实现的 null 使用 dev/null 这个设备文件是一个”黑洞”，可以看作是一个只能够写文件。写进去的东西都会被清空，当然也可以使用从 /dev/null 写入到文件来实现清空文件内容的目的。 12cat newfile1 &gt; /dev/null #会什么也不输出cat /dev/null &gt; /var/log/wtmp # 清空该文件内容 zero 为指定目的的文件来清零（指定大小的文件） 以上就是我在bash学习中的所有内容，当然会在以后写一些实际的bash脚本。这个bash学习系列就写到这。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十五）bash中的函数定义与使用]]></title>
    <url>%2F2018%2F07%2F03%2F2018-07-03-bash_14_bash%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[bash中的函数其实bash函数和bash脚本时一样的，函数的使用如同使用一段bash脚本块一样。但是定义为bash函数执行更快。 函数定义与调用与很多脚本语言一样，使用 function 作为关键词来声明函数。下面来使用一段例子代码来说明函数的定义的格式。乍一看是不是和js有点像呢。。 12345function hello()&#123;echo &quot;使用函数会输出这句话&quot;return 1&#125;hello #使用函数 函数的参数传递与编写bash相似，参数使用 $+位置的形式获取 如$1获取紧跟在调用函数后的第一个参数的值。 1234567function hello()&#123;echo &quot;使用函数会输出这句话&quot;echo &quot;输出第一个参数 $1&quot;return 1&#125;hello world# 输出结果 ‘ 输出第一个参数 world ’ 函数的返回值使用return来返回特定值 如上面的函数中使用到了 return 1 ,在return后发生的语句都不能被执行。并且return的的值只能在1~256之间的数。使用$?来获取返回到值。 函数的嵌套如同在Java js中使用函数类似，bash中的函数也允许使用嵌套结构。但是需要在外层函数调用内容函数。这是当然的了，因为在内部声明函数，却没有调用，这当然时不起作用的了。 1234567891011function x1()&#123; echo &quot;在函数x1中！&quot; function x2()&#123; echo &quot;在函数x2中！&quot; &#125; x2 # 这里需要调用内层函数&#125;x1#结果：#在函数x1中！#在函数x2中！]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十四）linux中的IO]]></title>
    <url>%2F2018%2F07%2F01%2F2018-07-01-bash_13_bash%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[linux中的IO分类linux中总有三种文件，一种时stdin（标准输入），stdout（标准输出），stderr（标准错误），可以重定向这些和其他任意文件，重定向的目的就是可以将文件中的任意内容作为输出或者输出源。 正文系统为每一个打开的文件分配一个文件描述符（FD），为标准输入stdin，标准输出stdout,标准错误stderr分别分配给0，1，2 简单输入输出： 12345echo &quot;helloworld&quot; &gt; newfile1echo &quot;helloworld&quot; 1 &gt; newfile1 #等同于第一句echo &quot;helloworld&quot; 1 &gt;&gt; newfile1 #追加内容command &lt; newfile1 #标准输入 同理等同于cat 0 &lt; newfile1 使用标准输出和标准错误输出 123ls 2&gt; newfile #将错误信息输出到newfile中ls &gt; newfile 2&gt;1&amp; #将标准输入和标准输出一起输出到newfile中# 其中&amp;表示和的关系 绑定重定向 12345ls &gt;&amp; m #把标准输出到文件描述符m中ls &lt; &amp;- #关闭标准输入n &lt; &amp;- #关闭输入文件描述符nn &gt; &amp;- #关闭输出文件描述符n1&gt;&amp;-, &gt;&amp;- # 关闭标准输出 其实在linux 下一切都是文件。把所有都想成文件就好理解的多了。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十一）命令篇（2）]]></title>
    <url>%2F2018%2F06%2F24%2F2018-06-24-bash_10_bash%E5%91%BD%E4%BB%A4%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[bash命令令篇（二）基本命令基本命令就是非常需要初学者掌握的重要的知识点，只有掌握这种基本的命令才能稍微熟练的操作linux。具体的基本命令也不一一列举了，对于这种基本命令用几遍就能够掌握了。而且网上的教程一大堆。 时间日期命令 date: 打印或者是设置本地时间。主要语法可以 man date 主要有date -u 打印 UTC时间。在后面可以使用 +参数的形式格式化为具体的时间格式。 zdump: 输出特殊时区的时间。如 zdump EMP time： 输出详细的时间信息比如 time ls -l at: at命令一般使用在特定时间执行的时候。 batch：batch命令和at命令相似。不同在于batch命令能够同时处理多条命令。 cal：cal命令可以整洁的打印出来日历 sleep：sleep可以使shell暂停固定时间长度 hwclock：访问硬件系统时间。需要管理员权限。 文本和文件处理命令 sort：文件排序的实用性工具，同时出现在管道当中，可以使用-m选项合并预分类的输入文件。 uniq：使用uniq命令能够去除重复的行，通常和sort使用在管道当中。 1234$ cat list_1.txt|uniq -c|sort -nr 5 this is the second line 3 this is the first line 1 this is the third line expand:可以将tab转换成普通空格，unexpand可以将空格转换成tab，同样比较常见在管道命令当中。 cut：从文件中提取字段的工具 1$ cut -d &apos; &apos; -f 1,2 list_1.txt paste:合并两个文件的内容，是每行都对应合并。而不是一个文件合并到另一个文件的下面。 join：和paste命令相似，但是join命令只粘贴两文件有共同标记的行，一般这个标记是数字。 head：输出文件的前10行，也可以更改输出的行数。 tail：输出文件的末尾10行，同样的可以更改输出的行数。 grep：正则匹配出文件的内容，一般使用在管道中，用来匹配上一个输入或者文件的匹配到的内容 123$ cat list_1.txt| grep &quot;third&quot; this is the third line ^ 这里的third是红色的表示匹配到的内容 wc：输出文件的行数字数等信息 123$ wc /usr/share/doc/sed-4.1.2/README13 70 447 README[13 lines 70 words 447 characters] tr 字符翻译的过滤器，将特定字符替换成其他字符 1234$ tr &quot;is&quot; &quot;*&quot; &lt; list_1.txt th** ** the f*r*t l*neth** ** the *econd l*neth** ** the th*rd l*ne nl nl和cat -b有着相似的意义，都能够连同行号打印出来，不同的是，nl可以将空行去除掉。 iconv 这个命令能够将文件转换编码，如utf-8转换成utf-16这类的转化。 这类命令真的很多，需要积累的东西也很多，我在这里就做个简单的说明，具体的使用可以 man 命令 查看具体的使用方法。也是学习的一种方式！！]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十二）命令篇（3）]]></title>
    <url>%2F2018%2F06%2F24%2F2018-06-27-bash_11_bash%E5%91%BD%E4%BB%A4%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[bash命令篇（三）bash中的关于通信的命令 host 通过ip或者域名搜索互联网的主机地址（使用DNS） 12345$ host www.baidu.comwww.baidu.com has address 61.135.169.125www.baidu.com has address 61.135.169.121www.baidu.com is an alias for www.a.shifen.com.www.baidu.com is an alias for www.a.shifen.com. nslookup 向上寻找name server 123456789101112$ nslookup -sil 66.97.104.180 Server: 127.0.1.1Address: 127.0.1.1#53Non-authoritative answer:180.104.97.66.in-addr.arpa name = 66-97-104-180.dynamic.bugtusselwireless.com.Authoritative answers can be found from:104.97.66.in-addr.arpa nameserver = ns2.bugnet.net.104.97.66.in-addr.arpa nameserver = ns1.bugnet.net.ns1.bugnet.net internet address = 204.11.133.241ns2.bugnet.net internet address = 204.11.133.244 ping 熟知的ping命令，常用来探测与另一个主机是否有网络链接 ftp 从远程主机下载或者上传给远程主机的协议。 telnt 链接远程主机的协议 wget 使用非交互式的从网站web或者ftp站点下载文件。 rcp 远程拷贝，在两台不同的机器间拷贝。 ssh secure shell 他代替了telnt rcp等命令。 scp secure cp 他用来代替rcp命令，需要登录授权的远程拷贝文件的命令。 这里只是简略的谈谈常见的关于机器交互的命令，这些都是熟能生巧的东西，最重要的是要上手练习。 数学运算符 dc：dc是使用逆波兰表示法进行计算，如 11 + ，3 6 * bc：bc是现代linux下比较常见处理复杂运算的命令那个，可以计算浮点数。 1234567891011$bc -l -q4/3 /*未指定精度默认保留整数*/scale=5 /*指定精度为5*/4/31.33333ibase=2 /*指定进制转换的输入机制为二进制，输出默认为是十进制*/104^2 /*指数运算，注：指数不能为浮点数*/4*a(1) /*计算π值，a()是个函数：arctan()，好吧，老师教的都被狗吃了，π值是等于四倍的arctan(1)么？*/3.14159265358979323844quit /*退出*/ let: 表达式可以应用在let命令当中。 其实在我使用linux系统的几年里，感觉命令不能死记硬背，多用自然就会掌握了。但是有些比较冷门的命令还是背下来比较好 - -。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十三）命令篇（4）]]></title>
    <url>%2F2018%2F06%2F24%2F2018-06-28-bash_12_bash%E7%AE%A1%E7%90%86%E5%91%98%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[系统命令linux上提供非常多的有关于系统的命令，我只能挑出我比较常见的命令来记录下来。 用户与用户组 users 显示所有登录用户 groups 列出当前用户和他所在的用户组 12$ groupsnanyin adm cdrom sudo dip plugdev input lpadmin sambashare chown 命令可以改变文件所属的用户或者用户组。也可以简单的理解给用户某些文件的权限。 chgrp 命令可以改变用户所属组。 useradd 可以为系统添加一个用户，并且在创建该用户的home文件夹。删除用户可以使用userdel命令进行删除。 usermod 命令可以改变用户属性，可以是密码也可以是用户组之类的 id 命令可以打印出用户及所在用户组的用户名和组名以及对应的id值 whoami 打印出当前用户的用户名称 passwd 设置，更改和管理用户的密码 基本信息和状态 uname 可以输出系统的具体参数如内核版本等信息。 arch 可以输出系统基于多少位 nc （netcat）是用于连接和侦听TCP和UDP端口的完整工具包。 lsdev 输出设备，也就是硬件信息 df 格式化输出文件系统占用比 一般使用df -h stat 输出文件的状态信息。 系统工作流 ps 查看进程信息 通常后面加 ax 或者 aux 使用。 pstree 以树形结构展示进程信息。 top 输出cpu的信息使用 -b参数以text的形式输出。能够以静态的方式查看。 nice用于指定进程调节优先级的命令。 pidof 可以输出具体进程的id 如：pidof xclock 会输出 xclock的进程id号。 网络 nmap 网络映射和端口扫描（现在只记得大学时网络攻防里用过windows里有个工具叫nmap什么的。。）参数有很多。。 ifconfig 最熟的查看网络接口设置。 netstat 输出网络状态和信息，如路由表和连接状态等。 ip 可以查询和设置ip和访问网卡设别信息 文件系统 mount 挂载文件系统 umount 卸载设备 sync 强制立即从缓冲区写入数据以来达到立即更新数据的目的。 mkswap swapon swapoff 分别对应格式化为交换分区，启动交换分区，关闭交换分区。 fdisk 创建或更改分区表，也就是用来分区的工具。非常常见。当时我还是选择cfdisk lspci 输出总线信息，和连接总线的设备信息。 其实还有很多命令没有涉及到，如果想练习这些基本的系统命令的话，可以跟着arch wiki 装一遍arch，装完后这里的命令就都能记住了。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ElementryOS图形界面挂起之后唤醒后出现黑屏问题]]></title>
    <url>%2F2018%2F06%2F23%2F2018-06-23-%E5%85%B3%E4%BA%8EelementryOS%E6%8C%82%E8%B5%B7%E4%B9%8B%E5%90%8E%E5%94%A4%E9%86%92%E6%97%B6%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于ElementryOS图形界面挂起之后唤醒后出现黑屏问题这两天在ElementryOs上踩到了坑，为了以后少踩点这种坑，打算以后将这种小问题也写下来。 如何解决：安装 xserver-xorg 在ElementryOS的终端中使用 $ sudo apt-get install xserver-xorg 我使用这个方法可以解决问题 解决时间：2018-6-23 版本：ElementryOS Loki 0.4]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（十）命令篇（1）]]></title>
    <url>%2F2018%2F06%2F19%2F2018-06-19-bash_09-bash%E5%91%BD%E4%BB%A4%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Bash中的命令内建命令内建命令是bash工具集中自带的命令，好处是执行速度比外部命令要快，因为内建命令一般直接执行命令，而外部命令一般要分支出一个子进程。 I/O操作 echo 当然是最熟悉的echo命令进行输出了。但是需要注意的是在使用 echo `command ` 的时候echo会默认将取消输出的所有换行。 再当使用 echo “`command`“的时候可以避免换行符的缺失。 12345echo &quot;`ll`&quot;total 12Kdrwxr-xr-x 2 nanyin nanyin 4.0K Jun 19 21:18 bashdrwxr-xr-x 3 nanyin nanyin 4.0K Jun 18 21:16 git-rw-r--r-- 1 nanyin nanyin 1.1K Jun 19 21:31 总结.txt printf 在C中使用的printf 能够格式化输出内容。 12345# 基本使用printf format-string... parameter...# 例子declare -r PI=3.1415926535printf &quot;pi to 2 decimal is %1.2f&quot; $PI # pi to 2 decimal is 3.14% read 读取参数的命令，可以通过这个命令读取输入参数。通常情况下，在输入read数据期间输入\会抑制换行符。 -r选项会导致输入的\被字面解释。同样read命令有很多参数可以使用 123echo &quot;please input a value:&quot;read var1echo &quot;input var1 is $var1&quot; 当read 后面不跟任何值的话他默认给 $REPLY 赋值，之后可以取这个值作为read进来的值。 在当输入内容后面加上 / 的话会起到输入时候的换行的作用，而使用 -r 参数会将 /按照原样输出出来 123456echo &quot;input var1 is $var1&quot;echo &quot;Enter a string terminated by a \\, then press &lt;ENTER&gt;.&quot;echo &quot;Then, enter a second string (no \\ this time), and again press &lt;ENTER&gt;.&quot;readecho &quot;the default value is $REPLY&quot;# 当read后面不写具体值的时候会把值付给 REPLY read有很多有用的参数可以调用，实现复杂的输入功能。 12345read -s -n1 -p &quot;Hit a key &quot; keypress# read 有很多非常有意思的参数，比如 -s的意思就是不要回显输入# -n1 的意思是输入指定数量的字符# -p 是先输出前面的提示。echo; echo &quot;Keypress was &quot;\&quot;$keypress\&quot;&quot;.&quot; read也可以使用文件作为输入的源 12345678910111213echo &quot;文件temp_file中内容有两行 一行是hello world 第二行是 Hello World&quot;read var1 var2 &lt; temp_fileecho &quot;var1 is $var1 var2 is $var2&quot;echo &quot;这里显然输出的第一行的内容&quot;echo &quot;---------------------------&quot;echo &quot;其实还能自定义IFS分割符然后根据规则自定义文件输入&quot;echo &quot;all users in the list:&quot;OIFS=$IFS ; IFS=:while read name passwd uid gid fullname ignoredo echo &quot;$name ($fullname)&quot;done &lt; /etc/passwdIFS=$OIFS 文件系统操作操作文件系统的命令有很多但是都非常的常用也非常的简单。这里不做具体的说明其中举一两个非常常见的。 cd : 切换目录 pwd ： 查看当前工作目录 变量操作let 是能够进行简单变量运算的命令 比如 1234let a=1+2echo $alet b=&quot;2+3&quot;echo $b eval 命令是能够将字符串转换成成命令。并且可以多次调用以去评估是否是命令去执行 12345678910111213141516 command_string=&quot;ps ax&quot; process=&quot;ps ax&quot; eval &quot;$command_string&quot; | grep &quot;$process&quot;# 26973 pts/3 R+ 0:00 grep --color ps ax# 26974 pts/3 R+ 0:00 ps axa=&apos;$b&apos;b=&apos;$c&apos;c=decho $a # $b # First level.eval echo $a # $c # Second level.eval eval echo $a # d # Third level. set和unset命令，一看就知道是设置和取消变量的意思。 export 命令一般使用在设置环境变量上，如在/etc/profile文件中设置JAVA_HOME declare和typeset命令指定和/或限制变量的属性。 getopts 是能够定义属性的 比如 在解压tar包的时候使用-xvf之类的命令的时候就是使用getopts来达到不同的 -a -b 之类的实现。这个命令一般出现在case 或者while循环中 123456789101112131415161718while getopts &quot;:abcde:fg&quot; Option# Initial declaration.# a, b, c, d, e, f, and g are the options (flags) expected.# The : after option &apos;e&apos; shows it will have an argument passed with it.# e参数后面的的表示会有参数传递给他do case $Option in a ) # Do something with variable &apos;a&apos;. b ) # Do something with variable &apos;b&apos;. ... e) # Do something with &apos;e&apos;, and also with $OPTARG, # which is the associated argument passed with option &apos;e&apos;. ... g ) # Do something with variable &apos;g&apos;. esacdoneshift $(($OPTIND - 1))# Move argument pointer to next.]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（八）循环和分支（2）]]></title>
    <url>%2F2018%2F06%2F12%2F2018-06-12-bash_08_bash%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%88%86%E6%94%AF%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[循环和分支(二)多重循环就像C，Java一样，bash同样可以实现多重循环,下面的例子简单的实现双重循环，如果加上循环控制可能就更难一些了。 12345678for ((i=0;i&lt;5;i++))do for bin in 1 2 4 do echo $bin doneecho $idone 循环控制影响循环行为的语句。有 break 和 continue 两个循环控制命令,break 命令可以终止循环，而continue可以跳过当前循环提前进入下一次循环，这里和C语言定义的类似。 下面举一个简单的break和continue的例子； 123456789101112131415161718192021LIMIT=9a=0#while [[ $a -le $LIMIT ]]#do#let &quot;a=a+1&quot;#if [ $a -eq 3 ] || [ $a -eq 11 ]#then# continue#fi#echo $a# donewhile [[ $a -le $LIMIT ]]do let &quot;a=a+1&quot; if [ $a -gt 2 ] then break fi echo $adone 简单的break循环只能跳出最内容的循环，而不能跳出多层的循环，可以使用 break N 来跳出多层循环。n为想要跳出循环的层数。 和break像似的continue，同样可以使用 continue N 来实现。这里使用到了一个非常简单明了的例子 123456789101112131415161718192021#!/bin/bashfor outer in I II III IV V # outer loopdo echo; echo -n &quot;Group $outer: &quot; # -------------------------------------------------------------------- for inner in 1 2 3 4 5 6 7 8 9 10 # inner loop do if [[ &quot;$inner&quot; -eq 7 &amp;&amp; &quot;$outer&quot; = &quot;III&quot; ]] then continue 2 # Continue at loop on 2nd level, that is &quot;outer loop&quot;. # Replace above line with a simple &quot;continue&quot; # to see normal loop behavior. fi echo -n &quot;$inner &quot; # 7 8 9 10 will not echo on &quot;Group III.&quot; done # --------------------------------------------------------------------doneecho; echoexit 0 测试和分支使用 case 和 select 结构体，不像一个循环，因为它没有一个迭代的一个过程，但是它们能够通过条件指导程序的流向。 通过程序块控制程序流向Case (in) /esac在bash中的case结构类似C中的switch结构，是在拥有多种条件下可以使用到的代码块。case结构可以参见下面代码。 (其实是可以有condition的左边的括号的，嗯，可以加上的) 123456789case &quot;$variable&quot; in &quot;$condition1&quot; ) command... ;; &quot;$condition2&quot; ) command... ;; 下面以后会非常有用处的例子 1234567891011121314151617#! /bin/bashcase &quot;$1&quot; in &quot;&quot;) echo &quot;Usage: $&#123;0##*/&#125; &lt;filename&gt;&quot;; exit $E_PARAM;; # No command-line parameters, # or first parameter empty.# Note that $&#123;0##*/&#125; is $&#123;var##pattern&#125; param substitution. # 可以通过使用##partern把前面的./去掉 -*) FILENAME=./$1;; # If filename passed as argument ($1) #+ starts with a dash, #+ replace it with ./$1 #+ so further commands don&apos;t interpret it #+ as an option. * ) FILENAME=$1;; # Otherwise, $1.esac selectselect是和case结构意义相同的结构体，可以使用自定义的PS3也就是选择提示符。格式如下： 12345select variable [in list]do command... breakdone 简单实例，这个例子不完整需要再去考虑很多东西。 12345678910111213141516PS3=&quot;Choose your favorite vegetable:&quot;select vegetable in &quot;beans&quot; &quot;carrots&quot; &quot;potatoes&quot;do if [[ $vegetable = &quot;beans&quot; ]] || [[ $vegetable = &quot;carrots&quot; ]] || [[$vegetable = &quot;potatoes&quot; ]] then echo echo &quot;your favorite veggie is $vegetable&quot; echo continue else echo &quot;your vegetable not on this list&quot; break fidone]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（七）循环和分支（1）]]></title>
    <url>%2F2018%2F06%2F12%2F2018-06-11-bash_07_bash%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[循环和分支循环循环就是一块当条件为真的迭代的代码块。 for循环for arg in [list] 这是最基础的循环形式。如果do和for在一行里，那么就需要在do前面加分号如：for arg in list ;do 1234for arg in listdo.. commend(s)done for循环有很多用法，举几个例子来了解一下for循环都能够干些什么吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# for i in &quot;hello world !&quot; # 这样当作整个字符串for i in hello world !do echo $idone# 与命令结合if [ -e &quot;/bin/bash&quot; ]then echo &quot;is exist&quot;fi# 输出当前目录下匹配文件的内容 类似使用find命令FILE=&quot;*txt&quot;for file in $FILEdo echo &quot;Contents of $file&quot; echo &quot;------------------&quot; cat &quot;$file&quot; echodone# 如果in list内容缺失就表示使用 in $@ 也就是所有传进来的参数for ado echo &quot;$a&quot;done#通过使用命令来构造for循环的listfor b in `ls`do echo $bdone# 使用for循环输出用户的信息PASSWORD_FILE=/etc/passwdn=1for name in $(awk &apos;BEGIN&#123;FS=&quot;:&quot;;&#125;&#123;print $1&#125;&apos;&lt; &quot;$PASSWORD_FILE&quot;)do echo &quot;USER #$n=$name&quot; let &quot;n+=1&quot;done#使用函数给for循环作值give_parm()&#123; echo &quot;1 2 3 5 6&quot;&#125;for c in $(give_parm)do echo $cdone# 类C语言的for循环for (( ai=1;ai&lt;5;ai++))do echo $aidone while循环while循环用来测试一个条件,并且一直循环直到条件为true也就是退出码为0的时候退出循环。一般while循环用在提前不知道循环次数的时候。while循环使用中括号把条件括起来，也可以使用双中括号。 1234while [condition]do····commendsdone 当while有多个条件的时候，只有最后一个参数会决定循环次数 1234567891011while echo &quot;previous-variable = $previous&quot; echo previous=$var1 [ &quot;$var1&quot; != end ] # Keeps track of what $var1 was previously. # Four conditions on *while*, but only the final one controls loop. # The *last* exit status is the one that counts.doecho &quot;Input variable #1 (end to exit) &quot; read var1 echo &quot;variable #1 = $var1&quot;done 也有类似C语言的while条件。 12345678while (( a &lt;= LIMIT )) # Double parentheses,do # + and no &quot;$&quot; preceding variables. echo -n &quot;$a &quot; ((a += 1)) # let &quot;a+=1&quot; 算数运算 # Yes, indeed. # Double parentheses permit incrementing a variable with C-like syntax. # 双小括号允许递增一个变量使用类C的运算方式done 同样的while后的条件可以是一个函数 12345678910111213141516condition ()&#123; ((t++)) if [ $t -lt 5 ] then return 0 # true else return 1 # false fi&#125;while condition# ^^^^^^^^^# Function call -- four loop iterations.do echo &quot;Still going: t = $t&quot;done while可以和read命令进行结合，形成 while read 结构体，能够有效的读和处理文件。 1234while read linedo echo $line #读取1.txt中的每一行done &lt; 1.txt until循环until循环是和while循环正好相反，until会一直进行循环，直到条件变为false； 1234until [ condition-is-true ]do command(s)...done]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（九）命令置换和算数扩展]]></title>
    <url>%2F2018%2F06%2F12%2F2018-06-16-bash_09_%E5%91%BD%E4%BB%A4%E7%BD%AE%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[命令置换命令置换可以输出一条或者多条命令的输出。可以让命令在不同语境下起作用，最常见的是使用 \`` 符号进行对命令的包裹，这样就能够输出使用命令得出的结果。可以成为另外一个命令的参数，也可以成为循环的参数。 123echo `hostname`echo $(&quot;hostname&quot;)# 两种使用都可以，都能够达到命令置换的目的 算数运算使用反引号，双括号，和let进行相对来说简单 使用反引号使用反引号内用expr命令进行整型数的运算。 1z=`expr $z+1` 使用双括号和let进行运算1234z=$((z+3))let z=z+3let &quot;z += 3&quot; # Quotes permit the use of spaces in variable assignment. 今天的内容有点少。。。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的入门]]></title>
    <url>%2F2018%2F06%2F07%2F2018-06-06-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式最近会时常遇到编写正则表达式，所以现在写一篇正则表达式的文章来简单记录一下学习正则的过程。 在这个网站有正则表达式的中文文档 -》 正则表达式手册 特殊字符一般使用反斜杠 \ 来转义特殊字符 如在正则中有特殊意义的* 或者. 如果要使用原意则需要使用\来进行转义 如 \*。下面介绍几个具体的实例。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 . 匹配除去换行符之外的所有字符 * 匹配前面字符0次或者多次 ? 匹配前面大的字符0次或者1次 + 匹配前面字符一次或多次 \w 匹配字母或者数字 \s 匹配任意空白 \d 匹配数字 \b 匹配单词的开始或者结束 一般使用 ^ 开头并且以 $ 结束，如验证5-12位数字的时候可以这样写 ^\d{5,12}$ 当字符串为 &quot;hello world 是，使用$时匹配到一处，而使用\b时会匹配到四处，分别为每个单词的开头和结尾。 特殊字符非常重要，是正则表达式的基本。在上面的例子中使用到了重复，也就是{m,n} m和n是重复的次数，如果n存在，那么就重复m到n次如果不存在，就重复m次。 字符匹配当使用到非特殊字符的时候，可以使用中括号，如 [aeiou]用来表示其中的字符都可以匹配到。比如 字符串 ‘how hello’ 使用到正则表达式 h[oe] 这样可以提示匹配到两处 当需要使用与特殊字符相反的含义的时候 使用反斜杠+大写字符的格式来进行匹配。比如匹配非字母和数字的字符就应该使用\W(因为使用匹配字母和数字的特殊字符是\w)。非特殊字符的反义使用^号。如[^aeiou]表示原因字符意外的任意字符。 当想匹配多种情况的时候，比如我想匹配x或者y字符串那么就使用 x|y 来表示匹配x或者y。这样可以解决很多二义性的匹配串。 分组的匹配当想对一个字符串进行重复，那么可以使用分组的功能。使用小括号来实现。典型的ip地址的匹配就可以这样使用(\d{1,3}.){3}\d{1,3} 使用 \\+数字 的形式 来实现重复那个分组的操作如 \b(\w+)\b\s+\1\b 就可以匹配相同的字符串。 贪婪模式当使用?紧跟其他任何一个其他限制符之后比如. * 之后，匹配模式是非贪婪的，尽可能少的匹配搜素的所有字符串。比如搜多ppppppp字符串，使用‘o+?’会匹配到单个o 关于 的后续 (?:pattern) 匹配pattern但不获取结果。这在使用|来组合一个模式的各个部分非常有用，比如常规匹配两种字符串“username|userManner”可以使用user(?:name|Manner)来简写。 (?=pattern) 正向肯定预查。比如windows(?=95|03|NT)能够匹配到windows95中的windows而不能匹配到windowsxp中的windows (?!pattern) 正向否定预查。与上面的意思相似，就是能够匹配到非的指定条件。比如windows(?!95|03|NT`能够匹配到windowsxp中的windows而不能匹配到windows95中的windows (?&lt;=pattern) 反向肯定预查。和第一个很相近，只不过方向不同。 (?&lt;!) 反向否定预查 。 这次的正则表达式就先总结到这里，以后肯定会遇到更多的关于正则的问题。有时间一定还要读读英文的正则教程]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（五） bash中关于变量的更多的知识]]></title>
    <url>%2F2018%2F05%2F02%2F2018-05-05-bash_05_%E6%93%8D%E4%BD%9C%E5%8F%98%E9%87%8F%202%2F</url>
    <content type="text"><![CDATA[字符串操作bash支持很多关于字符串的操作，不过可惜的是，这些操作缺乏统一性，有一些是使用参数等，另外一些是通过内建命令expr命令来实现，这会导致不同的语法功能的重叠，会比较混乱，下面简单介绍一下使用参数和命令的实现字符串的操作。 字符串长度（String Length） $(#string) 这里是和C语言中的strlen()是相同的。 expr length $string 同样表示string串的长度。 1234567#! /bin/bashstring=abcdefgHIGKL#使用第一种方法$(#string)echo "string的长度是：$&#123;#string&#125;"#使用第二种方法使用expr内建命令 优点简单易懂echo "string的长度是：`expr length $string`"` 字符串从开头匹配子字串的长度 方法如下： 123stringZ=abcABC123ABCab echo `expr match "$stringZ" 'abc[A-Z]*.2'`echo `expr $stringZ : 'abc[A-Z]*.2'` 匹配到子串的位置 (index) 1echo `expr index $stringZ 'abc[A-Z]*.2'` 子字符串的截取 ${string:position} 从positon位置截取字符串string。 ${string:positong:length} 从positon位置截取字符串string，并且限定截取长度为length。 expr substr $string $positon $length 意思同上。 expr match $string ‘\(substring \)’ 这里的substring是正则表达式。 12345#截取字符串echo $&#123;stringZ:5&#125;echo $&#123;stringZ:5:4&#125;echo `expr substr $stringZ 5 4`echo `expr match $stringZ '\(abc[A-Z]*.2\)'` 从字符串中移除子字符串 ${string#substring} substring是子字符串。并且需要注意的是：该方法表示的是向后移除该子字符串最短匹配到的字符串。 ${string##substring} 与上面的正好相反。该方法表示的是向后移除该字符串最长匹配到的字符串。 ${string%substring} 该方法表示的是由后向前移除该子字符串最短匹配到的字符串。 ${string%%substring} 该方法表示的是由后向前移除该字符串最长匹配到的字符串。 12345678910echo "移除字符串"echo $&#123;stringZ#a*b&#125; echo $&#123;stringZ##a*b&#125;echo $&#123;stringZ%a*c&#125;echo $&#123;stringZ%%a*c&#125;#结果：#ABC123ABCabc#c#abcABC123ABC# 子字符串替换 ${string/substring/replacement} 替换第一个匹配到substring的字符串，替换为replacement。 ${string//substring/replacement} 替换所有匹配到的字符。 ${string/#substring/replacement} 替换由前向后匹配到的字符。 ${string/%substring/replacement} 替换由后向前匹配到的字符。 12345678910echo "---------字符串替换---------"echo $&#123;stringZ/abc/xyz&#125;echo $&#123;stringZ//abc/xyz&#125;echo $&#123;stringZ/#abc/xyz&#125;echo $&#123;stringZ/%abc/xyz&#125;#结果：#xyzABC123ABCabc#xyzABC123ABCxyz#xyzABC123ABCabc#abcABC123ABCxyz 使用awk操作字符串现学先卖，三十分钟学会AWK,快速了解和应用awk。 基于以上，使用awk练习。 工作流分为大致三部分， read-&gt;excute-&gt;repeat,实现对文本的处理。 程序机构 BEGIN 语法：BEGIN {awk-commands} 是可以省略的部分块，主要作用是声明变量，初始化变量， BODY块 ：{commonds}，是必须填写的部分，主要作用是处理文本，会对输入的每一行都执行body块中的命令，并且body是没有关键字的。 -END ：END {commands},同BEGIN，是可以省略的部分 基础语法 awk命令行，可以通过执行awk [-option] files来实现对files文件的处理。 如 awk {print} mark.txt 这里就不具体举例了，开头的链接里讲的非常详细，这里只做简单的记录和查看。 使用命令文件方式 awk -f command.awk marks.txt 使用-f参数，可以使用文件中的命令。 awk基本选项 ： 这里不具体总结，linux环境下终端 man awk可以看到非常多的选项。 基本使用示例 基本打印文件内容 123456$ awk '&#123;print&#125;' mark.txt 1) Amit Physics 802) Rahul Maths 903) Shyam Biology 874) Kedar English 855) Hari History 89 打印具体项内容 123456$ awk '&#123;print $1 "\t" $2 &#125;' mark.txt1) Amit2) Rahul3) Shyam4) Kedar5) Hari 添加限定条件的打印内容 12345$ awk '/a/ &#123;print $1 "\t" $2 &#125;' mark.txt2) Rahul3) Shyam4) Kedar5) Hari 结果只显示匹配到a的行 打印匹配到的行数 12$ awk 'BEGIN&#123;count=0&#125; /a/ &#123; count++&#125; END&#123;print count&#125;' mark.txt4 打印字符数量超过16的行 123$ awk 'length($0) &gt; 18' marks.txt3) Shyam Biology 874) Kedar English 85 NOTE:在这里的参数和bash中的参数类似。$0当前行，$1之后表示对应文件的行的列。 内建变量AWK提供了很多内建变量提供使用，能够起到很大的作用。 标准awk变量 ARGC 命令行参数个数 12$ awk 'BEGIN&#123;print "argument=",ARGC&#125;' one two threeargument= 4 ARGV 命令行参数数组 如 ARGV[1]=... CONVFMT 数字的约定格式，默认值是%.6g ENVIRON 环境变量 12$ awk 'BEGIN &#123;print "User is",ENVIRON["USER"]&#125;'User is nanyin FILENAME 当前文件的名称 12$ awk 'END&#123;print "this file name is", FILENAME&#125;' mark.txtthis file name is mark.txt FS 分割符 默认是空格也可以使用-F设置分割符 NF 当前行的字段数目 12$ awk 'END&#123;print NF&#125;' mark.txt4 NR 行号 FNR 当前文件的行号 OFS 输出字段分隔符 ORS 输出行分割符 RLENGTH 表示match函数匹配字符床的长度 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RLENGTH&#125;&#125;'3 RSTART 表示match函数第一次匹配到的位置 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RSTART&#125;&#125;' 8 操作符与C语言的操作符基本相同，如数字的一元二元三元操作等，字符串的链接，数组元素等 正则表达式AWK对正则的处理非常强大，通常你一个小小的正则表达式能够处理很复杂的问题。关于正则，有时间整理一篇专门关于正则的文章。 数组AWK支持关联数组，也就是说，不仅可以使用数字索引的数组，还可以使用字符串作为索引。删除数组元素使用delete语句 流程控制流程控制if while for 与C相同 函数查手册吧。。一次性看不完。。。。内建函数手册，这里有在这章比较重要的字符串函数。接下来就来看看有哪些函数比较重要。 AWK对字符串操作的函数 整理出awk对字符串的几个具体函数操作。 asort(source,dest,how) asorti(source,dest,how) 以上两个函数的how先不解释，前两个参数分别为source数组和排序方式，第二个可以不写，默认使用第一位的进行排位。 1234awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asort(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' xiaohong aiaolan` asorti()函数会将顺序替换到数组的value处如： 123awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asorti(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' 1 0 gensub(regexp,replacement,how[,target]) 类似gsub和sub 替换匹配到的正则regexp为replacement.如果how是g或者G(global的简写),则表示替换所有使用regexp匹配到的字符串,target是目标字符串 如果使用regexp未匹配到，则返回原始target的值 1234567891011# 第一个echo a b c a d | gawk '&#123;print gensub(/a/,"AA",2)&#125;' a b c AA d# 第二个awk 'BEGIN&#123;a="abc def"b = gensub(/(.+) (.+)/,"\\2 \\1","g",a)print b&#125;'def abc gsub(regexp,replacement[,target]) gsub中的‘g’其实是表示的是global,寻找目标的匹配到从左最长的，不重叠的,找到并且替换掉。 1&#123; gsub(/Britain/, "United Kingdom"); print &#125; 返回的值为匹配到的次数 index(in,find) 寻找in串内符合find匹配到的字符的index位置 123$ awk 'BEGIN&#123;quote&gt; print index("hello","lo")&#125;'4 length([string]) 顾名思义，不解释了 12$ awk 'BEGIN&#123;print length("hello")&#125;'5 NOTE: If no argument is supplied, length() returns the length of $0. match(string,regexp,[,array]) 使用正则匹配字符串，返回匹配到的位置，若未匹配到返回0 split(string,array[,fieldsep[,seps]]) 分割string字符串，使用array存放分割后产生的字符组，使用fieldsep组为分割符，seps存放每次分割产生的分割符。一个分割出来的存放到array[1]中，第二个存放到array[2]中，以此类推。如果分割符fieldsep不写，则默认分割符为空格。 12345$ awk 'BEGIN&#123;print split("cul-de-sac",a,"-",seps);for(i=1;i&lt;4;i++)&#123;print a[i]&#125;&#125;' 3culdesac sprintf(format,expression1,..) 是printf的功能，并且能够返回字符串 strtonum (str) 类似java的parseInt()函数，由String字符串转成数字 sub（regexp,replacement[,target]） 最左最长匹配原则进行匹配，sub个gsub的作用相同，分割字符串，并进行替换 substr(string,start[,end]) 分割字符串 tolower(string) &amp; toupper(string) 大小写转换 关于awk的就总结到这了。。十分基础的总结。。推荐文档，清晰明了。下一篇打算先整理整理正则表达式。现在哪里都会用到正则，还是很有必要看看正则的。]]></content>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（五） bash中关于变量的更多的知识]]></title>
    <url>%2F2018%2F05%2F02%2F2018-05-05-bash_05_%E6%93%8D%E4%BD%9C%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[字符串操作bash支持很多关于字符串的操作，不过可惜的是，这些操作缺乏统一性，有一些是使用参数等，另外一些是通过内建命令expr命令来实现，这会导致不同的语法功能的重叠，会比较混乱，下面简单介绍一下使用参数和命令的实现字符串的操作。 字符串长度（String Length） $(#string) 这里是和C语言中的strlen()是相同的。 expr length $string 同样表示string串的长度。 1234567#! /bin/bashstring=abcdefgHIGKL#使用第一种方法$(#string)echo "string的长度是：$&#123;#string&#125;"#使用第二种方法使用expr内建命令 优点简单易懂echo "string的长度是：`expr length $string`"` 字符串从开头匹配子字串的长度 方法如下： 123stringZ=abcABC123ABCab echo `expr match "$stringZ" 'abc[A-Z]*.2'`echo `expr $stringZ : 'abc[A-Z]*.2'` 匹配到子串的位置 (index) 1echo `expr index $stringZ 'abc[A-Z]*.2'` 子字符串的截取 ${string:position} 从positon位置截取字符串string。 ${string:positong:length} 从positon位置截取字符串string，并且限定截取长度为length。 expr substr $string $positon $length 意思同上。 expr match $string ‘\(substring \)’ 这里的substring是正则表达式。 12345#截取字符串echo $&#123;stringZ:5&#125;echo $&#123;stringZ:5:4&#125;echo `expr substr $stringZ 5 4`echo `expr match $stringZ '\(abc[A-Z]*.2\)'` 从字符串中移除子字符串 ${string#substring} substring是子字符串。并且需要注意的是：该方法表示的是向后移除该子字符串最短匹配到的字符串。 ${string##substring} 与上面的正好相反。该方法表示的是向后移除该字符串最长匹配到的字符串。 ${string%substring} 该方法表示的是由后向前移除该子字符串最短匹配到的字符串。 ${string%%substring} 该方法表示的是由后向前移除该字符串最长匹配到的字符串。 12345678910echo "移除字符串"echo $&#123;stringZ#a*b&#125; echo $&#123;stringZ##a*b&#125;echo $&#123;stringZ%a*c&#125;echo $&#123;stringZ%%a*c&#125;#结果：#ABC123ABCabc#c#abcABC123ABC# 子字符串替换 ${string/substring/replacement} 替换第一个匹配到substring的字符串，替换为replacement。 ${string//substring/replacement} 替换所有匹配到的字符。 ${string/#substring/replacement} 替换由前向后匹配到的字符。 ${string/%substring/replacement} 替换由后向前匹配到的字符。 12345678910echo "---------字符串替换---------"echo $&#123;stringZ/abc/xyz&#125;echo $&#123;stringZ//abc/xyz&#125;echo $&#123;stringZ/#abc/xyz&#125;echo $&#123;stringZ/%abc/xyz&#125;#结果：#xyzABC123ABCabc#xyzABC123ABCxyz#xyzABC123ABCabc#abcABC123ABCxyz 使用awk操作字符串现学先卖，三十分钟学会AWK,快速了解和应用awk。 基于以上，使用awk练习。 工作流分为大致三部分， read-&gt;excute-&gt;repeat,实现对文本的处理。 程序机构 BEGIN 语法：BEGIN {awk-commands} 是可以省略的部分块，主要作用是声明变量，初始化变量， BODY块 ：{commonds}，是必须填写的部分，主要作用是处理文本，会对输入的每一行都执行body块中的命令，并且body是没有关键字的。 -END ：END {commands},同BEGIN，是可以省略的部分 基础语法 awk命令行，可以通过执行awk [-option] files来实现对files文件的处理。 如 awk {print} mark.txt 这里就不具体举例了，开头的链接里讲的非常详细，这里只做简单的记录和查看。 使用命令文件方式 awk -f command.awk marks.txt 使用-f参数，可以使用文件中的命令。 awk基本选项 ： 这里不具体总结，linux环境下终端 man awk可以看到非常多的选项。 基本使用示例 基本打印文件内容 123456$ awk '&#123;print&#125;' mark.txt 1) Amit Physics 802) Rahul Maths 903) Shyam Biology 874) Kedar English 855) Hari History 89 打印具体项内容 123456$ awk '&#123;print $1 "\t" $2 &#125;' mark.txt1) Amit2) Rahul3) Shyam4) Kedar5) Hari 添加限定条件的打印内容 12345$ awk '/a/ &#123;print $1 "\t" $2 &#125;' mark.txt2) Rahul3) Shyam4) Kedar5) Hari 结果只显示匹配到a的行 打印匹配到的行数 12$ awk 'BEGIN&#123;count=0&#125; /a/ &#123; count++&#125; END&#123;print count&#125;' mark.txt4 打印字符数量超过16的行 123$ awk 'length($0) &gt; 18' marks.txt3) Shyam Biology 874) Kedar English 85 NOTE:在这里的参数和bash中的参数类似。$0当前行，$1之后表示对应文件的行的列。 内建变量AWK提供了很多内建变量提供使用，能够起到很大的作用。 标准awk变量 ARGC 命令行参数个数 12$ awk 'BEGIN&#123;print "argument=",ARGC&#125;' one two threeargument= 4 ARGV 命令行参数数组 如 ARGV[1]=... CONVFMT 数字的约定格式，默认值是%.6g ENVIRON 环境变量 12$ awk 'BEGIN &#123;print "User is",ENVIRON["USER"]&#125;'User is nanyin FILENAME 当前文件的名称 12$ awk 'END&#123;print "this file name is", FILENAME&#125;' mark.txtthis file name is mark.txt FS 分割符 默认是空格也可以使用-F设置分割符 NF 当前行的字段数目 12$ awk 'END&#123;print NF&#125;' mark.txt4 NR 行号 FNR 当前文件的行号 OFS 输出字段分隔符 ORS 输出行分割符 RLENGTH 表示match函数匹配字符床的长度 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RLENGTH&#125;&#125;'3 RSTART 表示match函数第一次匹配到的位置 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RSTART&#125;&#125;' 8 操作符与C语言的操作符基本相同，如数字的一元二元三元操作等，字符串的链接，数组元素等 正则表达式AWK对正则的处理非常强大，通常你一个小小的正则表达式能够处理很复杂的问题。关于正则，有时间整理一篇专门关于正则的文章。 数组AWK支持关联数组，也就是说，不仅可以使用数字索引的数组，还可以使用字符串作为索引。删除数组元素使用delete语句 流程控制流程控制if while for 与C相同 函数查手册吧。。一次性看不完。。。。内建函数手册，这里有在这章比较重要的字符串函数。接下来就来看看有哪些函数比较重要。 AWK对字符串操作的函数 整理出awk对字符串的几个具体函数操作。 asort(source,dest,how) asorti(source,dest,how) 以上两个函数的how先不解释，前两个参数分别为source数组和排序方式，第二个可以不写，默认使用第一位的进行排位。 1234awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asort(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' xiaohong aiaolan` asorti()函数会将顺序替换到数组的value处如： 123awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asorti(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' 1 0 gensub(regexp,replacement,how[,target]) 类似gsub和sub 替换匹配到的正则regexp为replacement.如果how是g或者G(global的简写),则表示替换所有使用regexp匹配到的字符串,target是目标字符串 如果使用regexp未匹配到，则返回原始target的值 1234567891011# 第一个echo a b c a d | gawk '&#123;print gensub(/a/,"AA",2)&#125;' a b c AA d# 第二个awk 'BEGIN&#123;a="abc def"b = gensub(/(.+) (.+)/,"\\2 \\1","g",a)print b&#125;'def abc gsub(regexp,replacement[,target]) gsub中的‘g’其实是表示的是global,寻找目标的匹配到从左最长的，不重叠的,找到并且替换掉。 1&#123; gsub(/Britain/, "United Kingdom"); print &#125; 返回的值为匹配到的次数 index(in,find) 寻找in串内符合find匹配到的字符的index位置 123$ awk 'BEGIN&#123;quote&gt; print index("hello","lo")&#125;'4 length([string]) 顾名思义，不解释了 12$ awk 'BEGIN&#123;print length("hello")&#125;'5 NOTE: If no argument is supplied, length() returns the length of $0. match(string,regexp,[,array]) 使用正则匹配字符串，返回匹配到的位置，若未匹配到返回0 split(string,array[,fieldsep[,seps]]) 分割string字符串，使用array存放分割后产生的字符组，使用fieldsep组为分割符，seps存放每次分割产生的分割符。一个分割出来的存放到array[1]中，第二个存放到array[2]中，以此类推。如果分割符fieldsep不写，则默认分割符为空格。 12345$ awk 'BEGIN&#123;print split("cul-de-sac",a,"-",seps);for(i=1;i&lt;4;i++)&#123;print a[i]&#125;&#125;' 3culdesac sprintf(format,expression1,..) 是printf的功能，并且能够返回字符串 strtonum (str) 类似java的parseInt()函数，由String字符串转成数字 sub（regexp,replacement[,target]） 最左最长匹配原则进行匹配，sub个gsub的作用相同，分割字符串，并进行替换 substr(string,start[,end]) 分割字符串 tolower(string) &amp; toupper(string) 大小写转换 关于awk的就总结到这了。。十分基础的总结。。推荐文档，清晰明了。下一篇打算先整理整理正则表达式。现在哪里都会用到正则，还是很有必要看看正则的。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式学习记录（一）]]></title>
    <url>%2F2018%2F04%2F17%2F2018-04-17-Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Java设计模式学习记录（一）每次学习完设计模式，过一阵就忘了，所以写几篇博客记录下，让自己的记忆更深刻一下。 推荐 Java中23种设计模式–超快速入门及举例代码 这篇博客。能快速了解设计模式。 推荐github上的项目java-design-patterns 有例子源码，可以通过具体例子了解设计模式。 Java设计模式的基本分类java的设计模式大体上分为三大类： 创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 设计模式遵循的原则有六个 开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 里氏代换原则（Liskov Substitution Principle） 只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口来降低耦合度。 迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（三） bash中的退出码和测试（Test）]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-bash_exitCode%2F</url>
    <content type="text"><![CDATA[bash学习记录（三） bash退出码和测试1. Bash退出码 脚本的退出命令，类似C语言中的 return value ，可以供脚本的父进程调用。 每条命令返回一条状态状态，命令执行成功返回0，执行失败返回非0状态码可以理解为一个错误码（error code）。 最后的命令返回的状态或者 exit nnn（这里的nnn必须是1～255之间的整数）传递给shell。 exit nnn exit exit $? 或者空。都可以，是bash Return value的方式。 可以使用 ！来反转状态。 2. Bash中的test每个编程语言都会有对一个情况下测试的功能，Bash也不例外，bash提供test命令，多种的括号操作，最终要的If/else结构语句来实现test功能。 测试结构体(Test Constructs) 一个if/else结构体会测试一系列命令的返回值是否是0也就是命令是否执行成功。如果成功执行另外一系列操作。 bash使用 [ 来进行测试，但是在后来的版本里，bash引进了 [[ 来拓展test命令，bash把[[$a -lt $b]]看作一个元素，他会返回一个状态码（成功0，不成功是非0） 当使用let 和 (()) 的时候，对计算表达式进行运算的时候也会返回exit code，用于对算式的测试 1234567891011121314151617181920212223242526272829(( 0 &amp;&amp; 1 )) # Logical ANDecho $? # 1 ***# And so ...let &quot;num = (( 0 &amp;&amp; 1 ))&quot;echo $num # 0# But ...let &quot;num = (( 0 &amp;&amp; 1 ))&quot;echo $? # 1 ***(( 200 || 11 )) # Logical ORecho $? # 0 ***# ...let &quot;num = (( 200 || 11 ))&quot;echo $num # 1let &quot;num = (( 200 || 11 ))&quot;echo $? # 0 ***(( 200 | 11 )) # Bitwise ORecho $? # 0 ***# ...let &quot;num = (( 200 | 11 ))&quot;echo $num # 203let &quot;num = (( 200 | 11 ))&quot;echo $? # 0 ***# The &quot;let&quot; construct returns the same exit status#+ as the double-parentheses arithmetic expansion. if可以测试任何条件 不仅仅是包在括号里面的条件。 Else if and elif elif相当与 else if，要请求分支需要用到elif 12345678910111213if [ condition1 ]thencommand1command2command3elif [ condition2 ]# Same as else ifthencommand4command5elsedefault-commandfi Equivalence of test, /usr/bin/test,[ ], and /usr/bin/[ 使用这几个做判断都是一样的。更复杂的表达式要使用[[]]来代替[]。 Using the [[ … ]] test construct, rather than [ … ] can prevent many logic errors in scripts. 这是Advanced Bash-Scripting Guide给出的建议。 文件测试操作（File） -e 文件是否存在 -a 文件是否存在（以弃用） -f 是否是普通文件(不是目录文件或者设备文件) -s 是否是空文件 -d 是否是目录 -b 是否是块设备(block device) -c 是否是字符设备(character device) -h 是否是链接文件(symbolic link) -S file is socket -r -w -x 分别对应文件的 读写执行权限 -O 是否是文件的拥有者 -G group-id是否和你自己的相同 -N 在最后一次被读之后文件已经更改 f1 -nt f2 f1比f2新 -ot f1比f2旧 -ef f1和f2 引用同一个文件 例子 12345678for directory in $directorys; do if [ -d $directory ] then linkchk $directory else echo "$directory is not a directory" echo "Usage: $0 dir1 dir2 ..." fidone 其他比较操作（Integer，String）整型和字符串类型使用两组不同的操作 整形 -eq 相等比较 if [ &quot;$a&quot; -eq &quot;$b&quot; ] -ne 比较不相等 if [ &quot;$a&quot; -ne &quot;$b&quot; ] -gt 大于等于(is greater than or equal to) if [ &quot;$a&quot; -ge &quot;$b&quot; ] -lt 小于(is less than) if [ &quot;$a&quot; -lt &quot;$b&quot; ] -le 小于等于(is less than or equal to) `if [ “$a” -le “$b” ] &lt; &gt; &lt;= &gt;= 对应大于，小于，小于等于，大于等于这些相应的操作 String类型 = 判断字符串是否相等 == 和 = 相同，同样是判断字符串是否相同 但 == 在 [] 和 [[]] 中定义不同，下面举例： 12345[[ $a == z* ]] # True if $a starts with an &quot;z&quot; (pattern matching).[[ $a == &quot;z*&quot; ]] # True if $a is equal to z* (literal matching).[ $a == z* ] # File globbing and word splitting take place.[ &quot;$a&quot; == &quot;z*&quot; ] # True if $a is equal to z* (literal matching). != 不等于 &lt; and &gt; 大于小于 按照ASCII 码比较 -z 空字符串,因此，字符串长度为0 -n 字符串不为空 逻辑比较 -a 表示逻辑与 -o 表示逻辑或 -a -o 要使用在单个中括号中if [ &quot;$expr1&quot; -a &quot;$expr2&quot; ] &amp;&amp; and || 但是要在双中括号中使用[[ condition1 &amp;&amp; condition2 ]] 嵌套 if else如其他编程语言类似,if else结构能够嵌套，但是嵌套结构和使用 &amp;&amp; 比较符结果相同 12345678910111213141516a=3if [ &quot;$a&quot; -gt 0 ]then if [ &quot;$a&quot; -lt 5 ] then echo &quot;The value of \&quot;a\&quot; lies somewhere between 0 and 5.&quot; fifi# Same result as:if [ &quot;$a&quot; -gt 0 ] &amp;&amp; [ &quot;$a&quot; -lt 5 ]then echo &quot;The value of \&quot;a\&quot; lies somewhere between 0 and 5.&quot;fi]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（四） bash中的操作及相关话题]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-16-bash_operationAndRelatedTopics%2F</url>
    <content type="text"><![CDATA[bash学习记录（四） bash中的操作及相关话题计算符 Operators一.赋值（assignment）变量赋值：初始化变量或者改变变量的值 在所有的赋值操作中，计算赋值和字符串复制都是可以的，并不存在差异。 123var=27category=minerals # No spaces allowed after the &quot;=&quot;. 二.计算操作符+，-，*，/,%（取模运算），+=，-=，*=,/=,%=这些操作符和其他语言（比如java）语义相同。唯一有个差异的是 ** 是乘方操作 12345678910111213#一般赋值i=1bash=&quot;/bin/bash&quot;#一般操作符let &quot;z=i+1&quot;echo $zlet &quot;i+=2&quot;echo $ilet &quot;z=i**2&quot;echo $z 需要注意的是bash不能理解浮点数，他会默认把浮点数当作字符串来处理。 需要在脚本中使用 bc来计算浮点数 三.其他操作符 按位操作： &lt;&lt; : bitwise left shift (multiplies by 2 for each shift position) &gt;&gt;: bitwise right shift (divides by 2 for each shift position) &amp;,|，～，^ : 分别对应 位与，位或，位否,异或 逻辑操作 ！ ：非 &amp;&amp; ： AND || ： OR 杂项 ， ：逗号操作符，连接多个计算表达式，但是需要注意的是，这样只能返回最后一个算式的值 1234567let "t1 = ((5 + 3, 7 - 1, 15 - 4))"echo "t1 = $t1" # t1 = 11# Here t1 is set to the result of the last operation. Why?let "t2 = ((a = 9, 15 / 3))" # Set "a" and calculate "t2".echo "t2 = $t2 a = $a" # t2 = 5 a = 9`]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（二） bash中的变量和参数]]></title>
    <url>%2F2018%2F04%2F11%2F2018-4-11-bash_%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[bash学习记录（二） bash中的变量和参数变量就是一个标签在脚本中代表数据，不过是给分配在电脑内存中的数据一个名字，经常会出现在数学计算和大量操作(manipulation of quantities)和字符串解析(string parsing)中。 变量置换 (Variable Substitution) $The name of a variable is a placeholder for its value, the data it holds. Referencing (retrieving) its value is called variable substitution. 大致意思就是变量引用具体的值。使用$来引用变量 如 1234567bash$ variable1=23bash$ echo variable1//variable1bash$ echo $variable1//23 在(“..”)里引用不会干涉变量的引用，这叫做局部引用(partial quoting),也叫弱引用.但使用(‘..’)单引号会直接把变量名打印出来，不会引用变量，叫做全引用(full quoting),也叫做强引用。 注意：其实使用$variable1和使用${variable1}是一样的但是某些语境下前者可能会出问题。 未初始化的变量有一个默认的的值为”null“而不是‘0’，并且bash中的变量不分类型。 变量分配(Variable Assignment) =等号-&gt; the assignment operator (no space before and after) 前后不能有空格 12345#举一个比较典型的小例子，之前不知道区别。。a=`ls -l` # Assigns result of &apos;ls -l&apos; command to &apos;a&apos;echo $a # Unquoted, however, it removes tabs and newlines.echoecho &quot;$a&quot; # The quoted variable preserves whitespace. 使用双引号扩起来的$a有空格，而没有双引号的是去掉空格的。 12R=$(cat /etc/redhat-release)arch=$(uname -m) 可以看出使用$()的作用和使用``的作用相同，都可以对命令进行包裹。 bash变量没有类型不像其他的很多编程语言，bash脚本中的变量是没有类型的。无类型的变量是把双刃剑，一方面更加灵活，另一方面会渗透一些小的问题。 所以bash提供声明变量，会在后面的章节对声明变量的参数等信息详细列出来。 特殊的变量类型(Special Variable Types) 本地变量：变量只能在代码块和函数中可见 系统变量：变量影响shell的行为和用户的接口（比如设置Java环境变量） 如果脚本需要设置环境变量那么就去 export .. 位置参数： $0是脚本名称，1-9等对应其位置，10之后要使用大括号扩起来。$#对应最后一个元素 使用shift命令可以将位置参数重新排列，实际上就是向左移动一级。 这次篇幅较小，主要讲了讲bash中的变量和位置参数的含义和使用，属于非常基础，非常容易理解的部分。]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash学习记录（一） 初识和bash中的特殊字符]]></title>
    <url>%2F2018%2F04%2F10%2F2018-04-10-bash%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[bash学习记录（一）初识bash和特殊字符初识Bash鉴于本人的表达能力，不适合想要去系统学习bash的人来查看，提前分享两个不同阶段，不同人群学习的资料。 想要学习bash但是不想学习太深的人: bash-handbook 想要系统学习bash的人：Advanced Bash-Scripting Guide 其实bash很难，要考虑的东西很多，但现在学到的只是皮毛，希望能够多看多实践，才能更进一步。 Starting Off With a Sha-Bangsha-bang(#!)在起始的位置来告诉你的系统这个文件是命令的集合，能够使用哪个命令解释器来执行（/bin/bash）-&gt;path,这个命令路径必须正确 如果系统默认解释器是/bin/bash 或者其他 则不用使用 #! /bin/bash 来放到开头 Special Characters下面来简单总结一下有特殊意义的字符 ‘#‘ 跟在#号后面的相当与是注释，不会被解释器执行,可以出现单行，也可以出现在命令后作注释用 ; 分号 允许将多条命令放到单行用 ;; 两个分号，在case的场景下使用 如 1234567case "$variable" inabc) echo "\$variable = abc" ;;xyz) echo "\$variable = xyz" ;;esac . dot 相当与linux的内建命令source 作为文件名的一部分 如 .vimrc等 作为目录导向 如 ./表示当前目录 ../相当与父目录 正则表达式中可以表示为1个字符 “ 双引号 部分引用字符串，大部分还是字符串，但是能够引用变量 ‘$value’，并且特殊字符需要转义 ‘ 单引号 可以保存全部特殊字符，不能引用变量 , 逗号 表示连接多个计算表达式,多个表达式都会执行，但是只有最后一个计算式会返回值 。也做链接字符串 12let "t2 = ((a = 9, 15 / 3))"# Set "a = 9" and "t2 = 15 / 3" \ 反斜杠 escape [backslash] 可是实现对单个字符的转义 / 斜杠 Filename path separator [forward slash]本身就叫做文件分割符可以明了做什么用的了 ` command substitution 命令替换 如 a=`echo “hello world” `;echo $a 等 或者 a=`date` ; echo $a : 冒号 空命令等价与‘NOP’ do-nothing operation 也是有状态的相当与内建函数 true 比如 12345678910111213while :dooperation-1operation-2...operation-ndone# Same as:# while true# do# ...# done 作if判断的分支 12345if conditionthen : # Do nothing and branch aheadelse # Or else ...take-some-actionfi 放在必须要有两元操作的地方作为分隔符，如：: ${username=`whoami`} 配合管道命令 :&gt; :&gt;&gt;如果文件没有存在则创建 做分割符 如 echo $PATH 会出现很多以：作为分割符的字符串 在函数里可以作为站位符防止函数提为空 !叹号 作为 非出现 如 ！null 或者退出码 exit code。在不同的语境下可以作为间接变量引用。 * 星号 可以作为全匹配来使用 如 echo * 。 表示乘法 1*2 ? 问号 test operator. Within certain expressions, the ? indicates a test for a condition. 还可以作为匹配任意单个字符。 $ 变量引用 正则表达式中表示行尾 ${} 变量引用 $(…) 多个变量同时引用 123file1="file"file2="nofile"echo $'file1,file2' 输出内容：file1,file2 $* $@ 位置参数 $*是将所有参数作为一个整体返回（字符串），而$@是将每个参数作为单元返回一个参数列表 () 小括号 操作组(a=hello; echo $a) 数组初始化 {} 花括号扩展 用来扩展参数 如 abou{t,y,u} [] 中括号 shell内建测试的一部分 表达数组的部分如array[1] 表示字符集的范围，在正表达式中，方括号表示该位置可以匹配的字符集范围。 [[]] 双中括号(double brackets)。 这个结构也是测试，测试[[]]之中的表达式(Shell的关键字)。这个比单中括号更能防止脚本里面的逻辑错误 $[ … ] and (()) 都表示Integer计算 integer expansion. 1234a=3b=7echo $[$a+$b]echo (($a+$b)) | 管道 非常基础的概念 如 ls|grep .. 。 &amp;：后台执行 &amp;&amp; 和 || ：逻辑操作符 + - * % 各自意义就不详细解释了 资料引用 Advanced Bash-Scripting Guide 文章特别详尽，有兴趣非常鼓励看原文。这里我只做了部分比较常用的比较容易理解的部分做了精简（原谅我英文不好 :) 破产版总结 - - ）。 作为bash学习总结的第一篇文章，篇幅不大，尽量做到简单，详尽易懂。当遇到问题能够回头看一看，希望能够起到好的作用！！]]></content>
      <categories>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基本语法]]></title>
    <url>%2F2018%2F04%2F04%2F2018-04-08-markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown语法总结概述其实markdown语法很简洁，并且相当多的博客，还有重要的github上的readme也是用markdown进行编辑。所以有必要整理一下。废话不多说，进入正文 正文一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 在编辑的过程当中每编辑一块的内容，就要空一行，否则会出问题。。。 标题markdown支持两种标题的语法，类 Setext 和类 atx 形式。类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 -———— 效果 This is an H1This is an H2 也能使用atx 使用 # 来进行1-6阶的划分 如： # This is an H1 ## This is an H2 效果 This is an H1This is an H2 区块引用 区块应用 使用 &gt; 符号进行标识 。能每行都使用 &gt; 进行标识，也能只在第一行标识效果相同 列表 无序列表 可以使用*号或者+号或者-号都是一样的 有序列表 可以使用数字加英文.加空格使用有序列表 分割线三个以上的* 就是分割线 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ “Title”) inline link. [This link](http://example.net/) has no title attribute. 效果 This is an example inline link. This link has no title attribute. 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ “Google” [2]: http://search.yahoo.com/ “Yahoo Search” [3]: http://search.msn.com/ “MSN Search” I get 10 times more traffic from Google than fromYahoo or MSN. 强调使用两个*或者_表示强调 使用一个或者一个_表示斜体 如： helloworld helloworld 代码使用`符号来使用代码块行内代码使用`包起来 如 print() 图片同样的图片也有行内式和参考式向链接一样只不过在前面多个 ! 大概语法就是这么多 markdown简单方便，推荐使用。。自己写这种东西自己感觉写的都好菜，可能没有什么写博客的习惯，慢慢写吧，总有一天会整体清晰的。算了，自己看吧 :)]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql中出现Invalid default value for CREATE_TIME 错误]]></title>
    <url>%2F2018%2F01%2F01%2F2019-01-01-Mysql%E4%B8%AD%E5%87%BA%E7%8E%B0Invalid_default_value_for_CREATE_TIME%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Mysql中出现Invalid default value for ‘CREATE_TIME’错误最近做了新的系统，并把mysql升级到了5.7版本，在倒入sql时候，出现如题的错误‘Mysql中出现Invalid default value for ‘CREATE_TIME’错误’,找到了解决方法。 是因为在5.7版本中的sql_mode有NO_ZERO_IN_DATE,NO_ZERO_DATE这两个东西，去掉就好了。如何去掉？ 临时方法 123mysql&gt; set session -&gt; sql_mode=&apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;Query OK, 0 rows affected, 1 warning (0.00 sec) 永久性修改 直接修改配置文件 1234cd /etc/mysql/mysql.conf.dvim mysqld.cnf# 找到【mysqld】在下面插入sql_mode=&apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos; 我使用第二种方法解决了问题。]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019-08-05-SpringBoot启动原理]]></title>
    <url>%2F2019%2F08%2F05%2F2019-08-05-SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[调用callRunners启动过程图解使用一张简单的流程图将上面所有的主要方法串联起来，来查看SpringBoot的启动流程。 在整个启动流程的过程中又一个重要的组件就是listeners.它来监听应用运行的过程。在程序中的体现就是特定的节点调用listeners的回调方法。具体的调用listeners过程如下图所展示的： 结束这篇文章根据代码来分析SpringBoot的启动过程。分析的比较潦草，有些地方分析的不清晰或者分析出错的地方，欢迎指正，共同进步！。]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-15-SpringBoot的WEB开发之国际化]]></title>
    <url>%2F2019%2F07%2F16%2F2019-07-15-SpringBoot%E7%9A%84WEB%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[重启程序，进行测试： 总结如何在SpringBoot中使用国际化 编写国际化相关的 ResourceBundle文件，也就是对应的语言配置文件如：index_en_US.properties,index_zh_CN.properties，注意这个文件格式是固定的xxx_语言代码_大写的国家代码，并且必须是properties文件。 编写html接收国际化变量，使用Thymeleaf引擎可以使用语法#{}来使用国际化变量。 如何改造因为SpringBoot默认实现了LocaleResolver,并且标注了ConditionalOnMissingBean注解，所以，只需要自己实现LocaleResolver类，重写相关方法，就可以达到改造的目的。需要注意的是，在注册bean的时候，方法名必须localeResolver,或者指定bean的名称为localeResolver。]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-13-SpringBoot的WEB开发]]></title>
    <url>%2F2019%2F07%2F15%2F2019-07-13-SpringBoot%E7%9A%84WEB%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[测试结果]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-10-SpringBoot的日志]]></title>
    <url>%2F2019%2F07%2F13%2F2019-07-10-SpringBoot%E7%9A%84%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[使用自定义的配置文件更换log4j2作为日志框架]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-08-SpringBoot的配置文件（拓展）]]></title>
    <url>%2F2019%2F07%2F13%2F2019-07-08-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[加载的基本过程： Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包 根据spring.factories配置加载AutoConfigure类 根据 @Conditional注解的条件，进行自动配置并将Bean注入Spring Context]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-01-Mysql中出现Invalid_default_value_for_CREATE_TIME的错误]]></title>
    <url>%2F2019%2F07%2F12%2F2019-01-01-Mysql%E4%B8%AD%E5%87%BA%E7%8E%B0Invalid_default_value_for_CREATE_TIME%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[我使用第二种方法解决了问题。]]></content>
      <categories>
        <category>博客</category>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-11-使用Mysql的外键]]></title>
    <url>%2F2019%2F07%2F11%2F2019-07-11-%E4%BD%BF%E7%94%A8Mysql%E7%9A%84%E5%A4%96%E9%94%AE%2F</url>
    <content type="text"><![CDATA[index_name 指的是外键的标识，如果子表已经显式的定义了可以支持外键的索引（上面例子中的par_ind），则忽略。否则，mysql会依照以下规则隐式的创建一个外键索引。 如果定义CONSTRAINT symbol 值，则使用这个值，否则使用外键名 index_name. 如果上面两个都没有定义，外键名使用引用外键列的名称。 更新/删除行为Mysql如何使用外键来保证参照的完整性。 对于支持外键的innoDB存储引擎来说，MYSQL拒绝在子表中插入或删除在父表中没有匹配到的外键候选值。 当父表中的外键候选值发生变化的时候，根据不同的行为策略，来影响子表中对应的外键的键值。具体的策略如下： CASCADE 【级联】如果在父表中删除和更新数据，会自动的删除和更新子表中的匹配到的所有数据。支持删除级联ON DELETE CASCADE和更新级联ON UPDATE CASCADE,两个表之间，不要定义几个这样的子句，这些子句作用域父表或子表中的同一列。 SET NULL 【置空】如果在父表中删除和更新数据，则自动的置空NULL子表中的外键对应的字段。如果在更新或删除操作中指定了ON DELETE SET NULL或者ON UPDATE SET NULL 时，必须保障*子表外键的那个字段没有设置为 NOT NULL * RESTRICT 【限制】如果在伏笔啊哦中删除和更新数据，子表拒绝删除或更新对应字段内容。 NO ACTION【无动作】NO ACTION 是标准SQL中的关键字，在mysql中NO ACTION和RESTRICT的作用相同，都是在在修改或者删除之前去检查从表中是否有对应的数据，如果有，拒绝操作。 但是有些数据库系统会有延迟检查功能，会导致NO Action 会延迟检查是否有对应数据，但是MYSQL外键的检查是立即执行的，所以RESTRICT和NO ACTION是完全相同的 SET DEFAULT需要注意的是，set default只是MySQL 解析器认可，但是InnoDB和NDB 拒绝在定义表时，出现ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT 语句。]]></content>
      <categories>
        <category>博客</category>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-06-SpringBoot的配置文件]]></title>
    <url>%2F2019%2F07%2F09%2F2019-07-06-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[将HelloService手动通过配置类的方式添加到容器中，作用和使用xml的方式一样，但是更简单，更容易看懂。]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-04-SpringBoot深入自动配置]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-04-SpringBoot%E6%B7%B1%E5%85%A5%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[excludeFilters的作用是指定哪些类型不符合组件扫描的条件，也就是排除掉指定的类。]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-03-SpringBoot与微服务简介]]></title>
    <url>%2F2019%2F07%2F04%2F2019-07-03-SpringBoot%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[保存之后使用mvn package命令打成jar包，可以在输出信息中找出打完的jar包的位置。使用java -jar xxxxxx.jar命令运行程序。 微服务微服务其实是一种架构风格，一个应用应该是一组小型服务组成，小型服务通过http api的方式进行沟通。每一个小型服务都是一个功能元素，能够独立替换和独立升级的应用单元。 详细请参考martinfowler.com 中的这篇微服务文章：微服务]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-28-设计模式之命令模式]]></title>
    <url>%2F2019%2F07%2F02%2F2019-06-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-27-设计模式之迭代器模式]]></title>
    <url>%2F2019%2F07%2F02%2F2019-06-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单而强大的迭代器模式。]]></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-05-28-设计模式之策略模式]]></title>
    <url>%2F2019%2F06%2F28%2F2019-05-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-05-27-设计模式之责任链模式]]></title>
    <url>%2F2019%2F06%2F28%2F2019-05-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[public class King { private static RequestHandler chain; private void buildChain() { chain = new OrcCommander(new OrcOfficer(null)); } private void makeRequest(Request req) { chain.handleRequest(req); } public static void main(String[] args) { King king = new King(); king.buildChain(); king.makeRequest(new Request(RequestType.DEFEND_CASTLE, “defend castle”)); king.makeRequest(new Request(RequestType.TORTURE_PRISONER, “torture prisoner”)); }}]]></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-19-设计模式之状态模式]]></title>
    <url>%2F2019%2F06%2F27%2F2019-06-19-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-26-PlantUML类图使用总结]]></title>
    <url>%2F2019%2F06%2F27%2F2019-06-26-PlantUML%E7%B1%BB%E5%9B%BE%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、依赖关系依赖是一种使用的关系，代码中体现到依赖的关系的情况:局部变量、方法的参数或者对静态方法的调用,依赖是最弱的一种关联。依赖关系使用虚线和普通的小箭头来实现，箭头指向被依赖的对象。如图中的x依赖y一样，所以指向y,这个被x依赖的对象。 二、关联关系关联是拥有的关系，如玩家与游戏中的角色一样。关联可能是单向的，也可能是双向的，也同样能够自己关联自己。代码中体现到关联的关系的情况：成员变量。关联关系使用实线和小尖头来实现，箭头指向被关联的对象。 三、组合关系组合关系是整体与部分的关系，但是如果整体不存在，那部分也不能存在。就如同公司与部门一样，公司解散了，部门也就不存在了。和关联关系相同，在代码中的体现也是成员变量。组合关系使用空心的菱形和实线来表示。 四、聚合关系聚合关系是整体与部分的关系，但是和组合关系不同的是，聚合关系中的部分可以脱离整体而存在，就如同麦当劳中的套餐与汉堡一样。在代码中的体现同样是成员变量。聚合关系使用实心的菱形和实线来表示。 所以可以说聚合关系和组合关系是关系更加确定，更加紧密的关联关系。 各关系的强弱顺序 泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖 PlantUML支持更多的更复杂的情景下的图形绘制，具体可以查看PlantUML的中文网站。]]></content>
      <categories>
        <category>博客</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-25-设计模式之备忘录模式]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-25-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在游戏存档后死亡，再重复读存档，得到之前存档之前的状态。游戏不会主动存档和读取存档，只会记录存档中的内容，而玩家会主动从游戏中读取存档，然后恢复到存档的状态。]]></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-14-设计模式之代理模式]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-24-设计模式之观察者模式]]></title>
    <url>%2F2019%2F06%2F24%2F2019-06-24-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-05-29-设计模式之工厂模式]]></title>
    <url>%2F2019%2F06%2F19%2F2019-05-29-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-30-利用springboot构建SpringData+JAP+RestFul应用]]></title>
    <url>%2F2019%2F06%2F19%2F2019-01-30-%E5%88%A9%E7%94%A8springboot%E6%9E%84%E5%BB%BASpringData%2BJAP%2BRestFul%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这样可以访问localhost:3000的时候可以访问到Index文件内容。]]></content>
      <categories>
        <category>博客</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-17-使用IDEA设置springboot热部署]]></title>
    <url>%2F2019%2F06%2F19%2F2019-02-17-%E4%BD%BF%E7%94%A8IDEA%E8%AE%BE%E7%BD%AEspringboot%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[IDEA在IDEA中添加配置如下 打开 setting ,搜索 compiler 后，把 Build Project automaticial 选项勾上 使用 ctrl+shift+A 快捷键打开窗口，并搜索 Registry... 。勾选 compiler.automake.allow.when.app.running]]></content>
      <categories>
        <category>博客</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-10-28-Junit4 2]]></title>
    <url>%2F2019%2F06%2F19%2F2018-10-28-Junit4%202%2F</url>
    <content type="text"><![CDATA[经过以上的步骤执行完一个test。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-28-Junit4]]></title>
    <url>%2F2019%2F06%2F19%2F2018-10-28-Junit4%2F</url>
    <content type="text"><![CDATA[经过以上的步骤执行完一个test。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-04-08-markdown基本语法]]></title>
    <url>%2F2019%2F06%2F18%2F2018-04-08-markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “MarkDown基本语法”subtitle: “为了博客的正常编辑，在正式整理之前，把markdown的基本语法先整理一下，万一忘了还能找个地方看看。。”date: 2018-04-04 12:00:00author: “NanYin”header-img: “img/home-bg.jpg”tags: - markdown - 语法categories: Markdowncopyright: true Markdown语法总结概述其实markdown语法很简洁，并且相当多的博客，还有重要的github上的readme也是用markdown进行编辑。所以有必要整理一下。废话不多说，进入正文 正文一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 在编辑的过程当中每编辑一块的内容，就要空一行，否则会出问题。。。 标题markdown支持两种标题的语法，类 Setext 和类 atx 形式。类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 -———— 效果 This is an H1This is an H2 也能使用atx 使用 # 来进行1-6阶的划分 如： # This is an H1 ## This is an H2 效果 This is an H1This is an H2 区块引用 区块应用 使用 &gt; 符号进行标识 。能每行都使用 &gt; 进行标识，也能只在第一行标识效果相同 列表 无序列表 可以使用*号或者+号或者-号都是一样的 有序列表 可以使用数字加英文.加空格使用有序列表 分割线三个以上的* 就是分割线 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ “Title”) inline link. [This link](http://example.net/) has no title attribute. 效果 This is an example inline link. This link has no title attribute. 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ “Google” [2]: http://search.yahoo.com/ “Yahoo Search” [3]: http://search.msn.com/ “MSN Search” I get 10 times more traffic from Google than fromYahoo or MSN. 强调使用两个*或者_表示强调 使用一个或者一个_表示斜体 如： helloworld helloworld 代码使用`符号来使用代码块行内代码使用`包起来 如 print() 图片同样的图片也有行内式和参考式向链接一样只不过在前面多个 ! 大概语法就是这么多 markdown简单方便，推荐使用。。自己写这种东西自己感觉写的都好菜，可能没有什么写博客的习惯，慢慢写吧，总有一天会整体清晰的。算了，自己看吧 :)]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-04-10-bash学习记录]]></title>
    <url>%2F2019%2F06%2F18%2F2018-04-10-bash%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[| 管道 非常基础的概念 如 ls|grep .. 。 &amp;：后台执行 &amp;&amp; 和 || ：逻辑操作符 + - * % 各自意义就不详细解释了 资料引用 Advanced Bash-Scripting Guide 文章特别详尽，有兴趣非常鼓励看原文。这里我只做了部分比较常用的比较容易理解的部分做了精简（原谅我英文不好 :) 破产版总结 - - ）。 作为bash学习总结的第一篇文章，篇幅不大，尽量做到简单，详尽易懂。当遇到问题能够回头看一看，希望能够起到好的作用！！]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-12-bash_exitCode]]></title>
    <url>%2F2019%2F06%2F18%2F2018-04-12-bash_exitCode%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-16-bash_operationAndRelatedTopics]]></title>
    <url>%2F2019%2F06%2F18%2F2018-04-16-bash_operationAndRelatedTopics%2F</url>
    <content type="text"><![CDATA[需要注意的是bash不能理解浮点数，他会默认把浮点数当作字符串来处理。 需要在脚本中使用 bc来计算浮点数 三.其他操作符 按位操作： &lt;&lt; : bitwise left shift (multiplies by 2 for each shift position) &gt;&gt;: bitwise right shift (divides by 2 for each shift position) &amp;,|，～，^ : 分别对应 位与，位或，位否,异或 逻辑操作 ！ ：非 &amp;&amp; ： AND || ： OR 杂项 ， ：逗号操作符，连接多个计算表达式，但是需要注意的是，这样只能返回最后一个算式的值 1234567let "t1 = ((5 + 3, 7 - 1, 15 - 4))"echo "t1 = $t1" # t1 = 11# Here t1 is set to the result of the last operation. Why?let "t2 = ((a = 9, 15 / 3))" # Set "a" and calculate "t2".echo "t2 = $t2 a = $a" # t2 = 5 a = 9`]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-04-17-Java设计模式第一篇]]></title>
    <url>%2F2019%2F06%2F18%2F2018-04-17-Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “Java设计模式学习记录（一）”subtitle: “Java设计模式分类和原则”date: 2018-04-17 15:00:00author: “NanYin”header-img: “img/home-bg.jpg”tags: - Java - 设计模式categories: - 设计模式 copyright: trueJava设计模式学习记录（一）每次学习完设计模式，过一阵就忘了，所以写几篇博客记录下，让自己的记忆更深刻一下。 推荐 Java中23种设计模式–超快速入门及举例代码 这篇博客。能快速了解设计模式。 推荐github上的项目java-design-patterns 有例子源码，可以通过具体例子了解设计模式。 Java设计模式的基本分类java的设计模式大体上分为三大类： 创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 设计模式遵循的原则有六个 开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 里氏代换原则（Liskov Substitution Principle） 只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口来降低耦合度。 迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-06-06-正则表达式]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-06-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “正则表达式的入门”subtitle: “关于正则表达式的基本语法”date: 2018-06-06 17:00:00author: “NanYin”header-img: “img/home-bg.jpg”tags: 正则表达式 Linuxcategories: Linuxcopyright: true 正则表达式最近会时常遇到编写正则表达式，所以现在写一篇正则表达式的文章来简单记录一下学习正则的过程。 在这个网站有正则表达式的中文文档 -》 正则表达式手册 特殊字符一般使用反斜杠 \ 来转义特殊字符 如在正则中有特殊意义的* 或者. 如果要使用原意则需要使用\来进行转义 如 \*。下面介绍几个具体的实例。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 . 匹配除去换行符之外的所有字符 * 匹配前面字符0次或者多次 ? 匹配前面大的字符0次或者1次 + 匹配前面字符一次或多次 \w 匹配字母或者数字 \s 匹配任意空白 \d 匹配数字 \b 匹配单词的开始或者结束 一般使用 ^ 开头并且以 $ 结束，如验证5-12位数字的时候可以这样写 ^\d{5,12}$ 当字符串为 &quot;hello world 是，使用$时匹配到一处，而使用\b时会匹配到四处，分别为每个单词的开头和结尾。 特殊字符非常重要，是正则表达式的基本。在上面的例子中使用到了重复，也就是{m,n} m和n是重复的次数，如果n存在，那么就重复m到n次如果不存在，就重复m次。 字符匹配当使用到非特殊字符的时候，可以使用中括号，如 [aeiou]用来表示其中的字符都可以匹配到。比如 字符串 ‘how hello’ 使用到正则表达式 h[oe] 这样可以提示匹配到两处 当需要使用与特殊字符相反的含义的时候 使用反斜杠+大写字符的格式来进行匹配。比如匹配非字母和数字的字符就应该使用\W(因为使用匹配字母和数字的特殊字符是\w)。非特殊字符的反义使用^号。如[^aeiou]表示原因字符意外的任意字符。 当想匹配多种情况的时候，比如我想匹配x或者y字符串那么就使用 x|y 来表示匹配x或者y。这样可以解决很多二义性的匹配串。 分组的匹配当想对一个字符串进行重复，那么可以使用分组的功能。使用小括号来实现。典型的ip地址的匹配就可以这样使用(\d{1,3}.){3}\d{1,3} 使用 \\+数字 的形式 来实现重复那个分组的操作如 \b(\w+)\b\s+\1\b 就可以匹配相同的字符串。 贪婪模式当使用?紧跟其他任何一个其他限制符之后比如. * 之后，匹配模式是非贪婪的，尽可能少的匹配搜素的所有字符串。比如搜多ppppppp字符串，使用‘o+?’会匹配到单个o 关于 的后续 (?:pattern) 匹配pattern但不获取结果。这在使用|来组合一个模式的各个部分非常有用，比如常规匹配两种字符串“username|userManner”可以使用user(?:name|Manner)来简写。 (?=pattern) 正向肯定预查。比如windows(?=95|03|NT)能够匹配到windows95中的windows而不能匹配到windowsxp中的windows (?!pattern) 正向否定预查。与上面的意思相似，就是能够匹配到非的指定条件。比如windows(?!95|03|NT`能够匹配到windowsxp中的windows而不能匹配到windows95中的windows (?&lt;=pattern) 反向肯定预查。和第一个很相近，只不过方向不同。 (?&lt;!) 反向否定预查 。 这次的正则表达式就先总结到这里，以后肯定会遇到更多的关于正则的问题。有时间一定还要读读英文的正则教程]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-06-11-bash_07_bash中的循环和分支]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-11-bash_07_bash%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%88%86%E6%94%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-12-bash_08_bash中的循环和分支（二）]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-12-bash_08_bash%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%88%86%E6%94%AF%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-16-bash_09_命令置换]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-16-bash_09_%E5%91%BD%E4%BB%A4%E7%BD%AE%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[今天的内容有点少。。。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-19-bash_09-bash命令篇（一）]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-19-bash_09-bash%E5%91%BD%E4%BB%A4%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-23-关于elementryOS挂起之后唤醒时黑屏问题]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-23-%E5%85%B3%E4%BA%8EelementryOS%E6%8C%82%E8%B5%B7%E4%B9%8B%E5%90%8E%E5%94%A4%E9%86%92%E6%97%B6%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “关于ElementryOS图形界面挂起之后唤醒后出现黑屏问题”subtitle: “关于ElementryOS图形界面挂起之后唤醒后出现黑屏问题”date: 2018-06-23 12:00:00author: “NanYin”header-img: “img/bg_1.jpg”tags: - Linuxcategories: - Linux copyright: true关于ElementryOS图形界面挂起之后唤醒后出现黑屏问题这两天在ElementryOs上踩到了坑，为了以后少踩点这种坑，打算以后将这种小问题也写下来。 如何解决：安装 xserver-xorg 在ElementryOS的终端中使用 $ sudo apt-get install xserver-xorg 我使用这个方法可以解决问题 解决时间：2018-6-23 版本：ElementryOS Loki 0.4]]></content>
      <categories>
        <category>博客</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-24-bash_10_bash命令篇（二）]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-24-bash_10_bash%E5%91%BD%E4%BB%A4%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[nl nl和cat -b有着相似的意义，都能够连同行号打印出来，不同的是，nl可以将空行去除掉。 iconv 这个命令能够将文件转换编码，如utf-8转换成utf-16这类的转化。 这类命令真的很多，需要积累的东西也很多，我在这里就做个简单的说明，具体的使用可以 man 命令 查看具体的使用方法。也是学习的一种方式！！]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-27-bash_11_bash命令篇（三）]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-27-bash_11_bash%E5%91%BD%E4%BB%A4%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[let: 表达式可以应用在let命令当中。 其实在我使用linux系统的几年里，感觉命令不能死记硬背，多用自然就会掌握了。但是有些比较冷门的命令还是背下来比较好 - -。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-28-bash_12_bash管理员命令]]></title>
    <url>%2F2019%2F06%2F18%2F2018-06-28-bash_12_bash%E7%AE%A1%E7%90%86%E5%91%98%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[chown 命令可以改变文件所属的用户或者用户组。也可以简单的理解给用户某些文件的权限。 chgrp 命令可以改变用户所属组。 useradd 可以为系统添加一个用户，并且在创建该用户的home文件夹。删除用户可以使用userdel命令进行删除。 usermod 命令可以改变用户属性，可以是密码也可以是用户组之类的 id 命令可以打印出用户及所在用户组的用户名和组名以及对应的id值 whoami 打印出当前用户的用户名称 passwd 设置，更改和管理用户的密码 基本信息和状态 uname 可以输出系统的具体参数如内核版本等信息。 arch 可以输出系统基于多少位 nc （netcat）是用于连接和侦听TCP和UDP端口的完整工具包。 lsdev 输出设备，也就是硬件信息 df 格式化输出文件系统占用比 一般使用df -h stat 输出文件的状态信息。 系统工作流 ps 查看进程信息 通常后面加 ax 或者 aux 使用。 pstree 以树形结构展示进程信息。 top 输出cpu的信息使用 -b参数以text的形式输出。能够以静态的方式查看。 nice用于指定进程调节优先级的命令。 pidof 可以输出具体进程的id 如：pidof xclock 会输出 xclock的进程id号。 网络 nmap 网络映射和端口扫描（现在只记得大学时网络攻防里用过windows里有个工具叫nmap什么的。。）参数有很多。。 ifconfig 最熟的查看网络接口设置。 netstat 输出网络状态和信息，如路由表和连接状态等。 ip 可以查询和设置ip和访问网卡设别信息 文件系统 mount 挂载文件系统 umount 卸载设备 sync 强制立即从缓冲区写入数据以来达到立即更新数据的目的。 mkswap swapon swapoff 分别对应格式化为交换分区，启动交换分区，关闭交换分区。 fdisk 创建或更改分区表，也就是用来分区的工具。非常常见。当时我还是选择cfdisk lspci 输出总线信息，和连接总线的设备信息。 其实还有很多命令没有涉及到，如果想练习这些基本的系统命令的话，可以跟着arch wiki 装一遍arch，装完后这里的命令就都能记住了。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-01-bash_13_bash中的输入输出]]></title>
    <url>%2F2019%2F06%2F18%2F2018-07-01-bash_13_bash%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[其实在linux 下一切都是文件。把所有都想成文件就好理解的多了。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-03-bash_14_bash中的函数]]></title>
    <url>%2F2019%2F06%2F18%2F2018-07-03-bash_14_bash%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-06-bash_15_终章]]></title>
    <url>%2F2019%2F06%2F18%2F2018-07-06-bash_15_%E7%BB%88%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[zero 为指定目的的文件来清零（指定大小的文件） 以上就是我在bash学习中的所有内容，当然会在以后写一些实际的bash脚本。这个bash学习系列就写到这。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-12-bash问题总结]]></title>
    <url>%2F2019%2F06%2F18%2F2018-07-12-bash%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于${!var} var是变量名使用${!var}的作用是当ver不存在的时候会原样输出，也就是显示${var} 关于bash中的trap命令的使用trap可以强化bash脚本，让脚本更加稳定。 trap的使用方式trap有三种使用方式，对应这不同的对信号的回应方式。 trap ”something“ signal 其中”something“ 是在接受signal信号之后作出的命令 trap signal trap不指定任何命令，接受信号的默认操作，默认操作是结束进程的运行 trap “” signal trap命令指定一个空命令串，允许忽视信号 常用信号 HUB(1) 挂起，通常因终端掉线或用户退出而引发 INT(2) 中断，通常因按下Ctrl+C组合键而引发 QUIT(3) 退出，通常因按下Ctrl+/组合键而引发 ABRT(6) 中止，通常因某些严重的执行错误而引发 ALRM(14) 报警，通常用来处理超时 TERM(15) 终止，通常在系统关机时发送 KILL(9) 杀死进程 STOP 停止进程执行 更过的信号 可以使用 trap -l 命令来查看]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-15-idea快捷键]]></title>
    <url>%2F2019%2F06%2F18%2F2018-07-15-idea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “IDEA 中的快捷键”subtitle: “IDEA 中的经常用到的快捷键”date: 2018-07-12 17:00:00author: “NanYin”header-img: “img/home-bg.jpg”tags: - ideacopyright: turecategories: - 工具 IDEA 中的快捷键以前经常用idea开发，但是竟然没有怎么使用到idea的快捷键。。没有真正的使用到idea中非常重要的特性。今天正好看到了有一篇微信公众号里文章总结了关于常用的idea快捷键。遂而也想小小总结一下，希望在以后的开发中多用快捷键，提高开发效率。 代码 ctrl+alt+o = 优化导入的包 alt+insert = 加入代码 ctrl+alt+T = 生成try–catch结构 alt+回车 = 导入包 ctrl+alt+l = 格式化代码 ctrl+e = 最近更改的代码 Shift+F6 = 重构-重命名 包、类、方法、变量、甚至注释等 搜索 ctrl+Shift+backspace =回到上次编辑的地方 ctrl+alt+left/right = 回到前后编辑的地方 Shift+Shift 在目录中查找类 ctrl+n 查找类 ctrl+Shift+n 查找文件 ctrl+e 打开最近文件 ctrl+f 文件内容查找 ctrl+shift+f 全局内容查找 ctrl+w 快速选中 ctrl+b/ctrl+alt+b 对应这回溯到父类和到子类的快捷键 对行的删除，复制，粘贴操作可以使用vim插件来实现最后vim的十大快捷键（copy的）Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T 另外补充 alt+1 project视图 alt+7 类方法结构 alt+home 显示导航栏 shift+f6 重命名 ctrl+shift+加号 折叠代码 关闭tab页其实是有必要的]]></content>
      <categories>
        <category>博客</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-25-stackOverFlow上的热门问题]]></title>
    <url>%2F2019%2F06%2F18%2F2018-07-25-stackOverFlow%E4%B8%8A%E7%9A%84%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-04-ArrayList的源码查看]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-04-ArrayList%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-08-LinkedList的源码查看]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-08-LinkedList%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[offer方法实际上 offer 是调用的 add 方法，但是区别就在 linkedlist 继承了 Dequ 和 List 父类。一般当 queue 用的时候要用 offer/push/pop 而当使用 list 的时候用 add/remove 。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-10-hashmap的源码查看]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-10-hashmap%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[这是几个非常常用的hashMap的方法和基本的数据结构源码的分析查看。就当做笔记记录一下。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-15-Enum类及相关拓展]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-15-Enum%E7%B1%BB%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[EnumSet 相对于 EnumMap 等同于 hashSet 相对于 HashMap 的存在，很好理解。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-15-HashSet和HashTable的源码分析]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-15-HashSet%E5%92%8CHashTable%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[通过上面的代码可以看出HashTable和HashMap的结构还是有差异的，HashMap是纵向的列表当出现相同的hash值的时候，扩展出横向列表，当横向的列表到达一定的长度的时候，这个横向的链表就会自动整理成红黑树的形式，而hashTable不存在横向的这种结构的，当count&gt;=阈值的时候就会把Hash重置，使之不会出现hash值重复的情况。可以说hashTable比较hashMap的结构更简单，但是效率会比HashMap的低。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-17-Java中的栈和队列]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-17-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[这几个方法和linkedList类中的对应的方法非常像，所以其实LindedList也可以当作栈用。 Queue 队列队列和栈相反，是一个先进后出的数据结构，想成现实中的排队再明白不过了。 offer 方法和 pull方法offer方法可以将元素放入队列当中，pull可以将元素从头部移除。 add方法和remove方法add和remove方法分别调用offer和pull方法，不同的是，如果队列满了，add方法会抛出异常，而offer方法会返回null。如果队列空了，remove方法会抛出异常，而pull方法会返回null。 以后会提及队列的实现类以及Dequ相关类。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-24-Java中Deque及其子类]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-24-Java%E4%B8%ADDeque%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[总结一下，ArrayDeque实现了双端队列的特点，能够完成栈和队列的功能，效率比同样继承Deque的LinkedList效率高，因为在ArrayDeque中的计算大部分为位运算。ArrayDeque逻辑上循环的数组，但实际上并不是。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-11-08-String和StringBuffer和StringBuilder的联系和区别]]></title>
    <url>%2F2019%2F06%2F18%2F2018-11-08-String%E5%92%8CStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-12-18-关于SpringMvc使用DELETE和PUT请求时405错误]]></title>
    <url>%2F2019%2F06%2F18%2F2018-12-18-%E5%85%B3%E4%BA%8ESpringMvc%E4%BD%BF%E7%94%A8DELETE%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E6%97%B6405%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-4-11-bash_变量]]></title>
    <url>%2F2019%2F06%2F18%2F2018-4-11-bash_%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[可以看出使用$()的作用和使用``的作用相同，都可以对命令进行包裹。 bash变量没有类型不像其他的很多编程语言，bash脚本中的变量是没有类型的。无类型的变量是把双刃剑，一方面更加灵活，另一方面会渗透一些小的问题。 所以bash提供声明变量，会在后面的章节对声明变量的参数等信息详细列出来。 特殊的变量类型(Special Variable Types) 本地变量：变量只能在代码块和函数中可见 系统变量：变量影响shell的行为和用户的接口（比如设置Java环境变量） 如果脚本需要设置环境变量那么就去 export .. 位置参数： $0是脚本名称，1-9等对应其位置，10之后要使用大括号扩起来。$#对应最后一个元素 使用shift命令可以将位置参数重新排列，实际上就是向左移动一级。 这次篇幅较小，主要讲了讲bash中的变量和位置参数的含义和使用，属于非常基础，非常容易理解的部分。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-18-Pop!_Os的Ibus输入法上方panel图标消失的问题]]></title>
    <url>%2F2019%2F06%2F18%2F2018-12-18-Pop!_Os%E7%9A%84Ibus%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8A%E6%96%B9panel%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决！！]]></content>
      <categories>
        <category>博客</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-04-Ubuntu配置全过程 2]]></title>
    <url>%2F2019%2F06%2F18%2F2019-01-04-Ubuntu%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B%202%2F</url>
    <content type="text"><![CDATA[其中会让你输入密码，输入就行了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-10-29-什么是消息中间件，RPC框架，数据库中间件]]></title>
    <url>%2F2019%2F06%2F18%2F2018-10-29-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8CRPC%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[title: “消息中间件，RPC框架，数据库中间件的概念认知”date: “2018-10-29 22:05”author: “NanYin”copyright: turetags: - Javacategories: - Java 消息中间件，RPC框架，数据库中间件的概念认知消息中间件什么是消息中间件对中间件的理解大概就是具体业务和底层逻辑解耦的组件。相当于前端业务和底层逻辑的中间桥梁。 消息中间件是在分布式系统中发送和接受消息的基础服务设施。 能够做什么？ 业务解耦：交易系统不需要知道短信通知服务的存在，只需要发布消息 削峰填谷：比如上游系统的吞吐能力高于下游系统，在流量洪峰时可能会冲垮下游系统，消息中间件可以在峰值时堆积消息，而在峰值过去后下游系统慢慢消费消息解决流量洪峰的问题 事件驱动：系统与系统之间可以通过消息传递的形式驱动业务，以流式的模型处理 RPC框架什么是RPC框架远程过程调用协议RPC（Remote Procedure Call Protocol) 两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。 能够做什么？ 建立客户端和服务器之间的TCP链接，不同的RPC协议，有不同的连接寻址方式。 在发起远程调用时，由于网络协议是二进制的，所以在传输前要进行对传输实体进行转换二进制的过程，也是就序列化过程（Serialize），通过寻址和二进制的数据传输到服务器端 在接受到数据后，需要进行反序列化过程解析二进制数据。 其实就是解决在分布式下，横向拓展的前提下，不同服务器相互调用方法的问题。 数据库中间件什么是数据库中间件同样在分布式的架构中，数据库也放到不同的服务器上，需要通过中间的路由进行调用。这个路由实际上就是数据库中间件。 能够做什么？ 实现读写分离，但是每个服务器上都需要有一份完整的数据库 实现分库分表，通过消息中间件进行查询分派到某一个特定的服务器上，通过这个服务器查询出内容返回到消息中间件，再通过中间件返回到客户端。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-01-04-Ubuntu配置全过程]]></title>
    <url>%2F2019%2F06%2F18%2F2019-01-04-Ubuntu%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[其中会让你输入密码，输入就行了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-01-25-过程问题]]></title>
    <url>%2F2019%2F06%2F18%2F2019-01-25-%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-01-29-基本Llinux命令(必须掌握)]]></title>
    <url>%2F2019%2F06%2F18%2F2019-01-29-%E5%9F%BA%E6%9C%ACLlinux%E5%91%BD%E4%BB%A4(%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1)%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “Linux常用命令整理”date: 2019-01-29 12:00:00author: “NanYin”copyright: turetags: - Linuxcategories: - Linux linux中必须掌握的基本命令在开始前，我推荐安装 trdr（too long dont read）工具，用来简化man命令，来实现查看命令含义和用法的作用。 一 、系统工作命令 echo echo命令一般用于shell中打印变量或者字符串的作用，主要用来显示和提醒。 输出一段信息 如：echo &quot;hello world&quot; 其中&quot;不是必须的 输出一段带环境变量的信息 如：echo &quot;My Path is $PATH&quot; 输出并不带换行符号 如：echo -n &quot;Hello World&quot; 输出一段激活转依字符 如： echo -e &quot;Column 1 \t Column 2&quot; date date 命令主要用来设置和打印系统时间。 输出默认时区格式的事件 date +&quot;%c&quot; 输出当前事件按照UTC和iso格式输出 date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; 输出事件戳 date +&quot;%s&quot; reboot 命令主要用来重启系统 重启系统 reboot 强制重启 reboot -f poweroff 命令用户关机 wget 命令 用于从web中下载文件，支持 http,https,ftp 获取URL中的内容到foo中 wget https://example.com/foo 获取URL中的内容到bar中 wget -O bar https://example.com/foo 继续未完成的下载 wget -c https://example.com 后台下载 wget -q https://example.com ps命令主要用于查看正在运行的进程的信息 打印全部正在执行的进程 ps aux 打印全部正在执行的进程并且伴有完整的命令串 ps auxww 通过 grep 管道过滤 ps aux | grep &quot;tomcat&quot; 得到进程的父进程pid :ps -o ppid= -p pid top命令 主要用户动态的实时的显示正在运行的程序 top -i 不显示空闲或者是僵尸进程 top -u $user 显示指定用户的进程 top -p PID 只显示指定进程PID top -p $(pgrep -d &#39;,&#39; process_name) 通过进程名来查询 pidof 命令主要用于查找指定进程的id号 pidof -s 进返回一个进程号 pidof -c 仅显示具有相同root目录下的进程 二、系统状态 ifconfig 命令主要用于网络接口的查看和配置 Ifconfig eth0 查看etho0接口网络设置 ifconfig -a 查看所有接口的详细信息 ifconfig eth0 down 关闭接口eth0 ifconfig eth0 ipaddr 设置端口ip地址 uname 打印出现当前机器和系统的相关信息 uname -n 打印当前的hostname uname -a 打印当前可用的系统的信息，包括硬件软件。 who 打印哪些用户登录再这台机器上 who 显示username等比较全的信息 who am i 打印出当前用户 last 用于查看当前用户最近的登录信息 三、文件和目录 pwd 用于打印当前目录 cd 用于切换目录 ls 用于罗列目录下的文件或者文件夹 ls -l按行罗列文件或文件夹 ls -a 显示所有文件，包括隐藏的文件。 ls -lh 按照大小排泄排列 touch 命令主要用于改变文件的访问时间和修改时间。 touch filename 以当前时间创建文件 touch -t yyyy-mm-dd filename 以某一时间来改变文件时间 mkdir 命令主要用于创建文件 mkdir dir 创建文件夹 mkdir -p /path/dir 创建指定路径下的文件 cp 命令主要用于文件的复制 cp path/to/file.ext path/to/copy.ext 复制文件到另一个地址 cp path/to/file.ext path/to/target_parent_directory 复制文件到指定地址，并且保持文件名不变 cp -r path/to/directory path/to/copy 递归的复制整个文件夹及其中的内容到指定目录 cp -i *.txt path/to/target_directory 以交互的模式复制文件到指定文件夹中 mv 命令主要用于移动文件 mv source target 移动文件 mv -f 强制移动，覆盖现有文件时不要提示 rm命令主要用于删除文件 rm path/to/file path/to/another/file 删除特定文件夹中的文件 rm -r path/to/directory 递归删除文件夹及文件夹中的文件 rm -rf 递归删除，并且不要提示信息 dd 命令主要用于转化和复制文件,制作usb镜像 Clone a drive to another drive with 4MB block and ignore error dd if=/dev/source_drive of=/dev/dest_drive bs=4m conv=noerror file命令主要用于确定文件类型 file filename 输出文件类型 file -s filename 用于特殊的文件或者设备文件。 四、文本编辑命令 cat 打印和串联文件 cat file 打印文件内容到标准输出 cat file1 file2 &gt; targetFile 将多个文件内容串联到目标文件中 cat -n file 打印出行数到标准输出 more 用于互动的阅读文件内容，可以上下滚动 more file 打开文件，&lt;space&gt;用于移动到下一页，/用于搜索文件内容， q用于退出当前界面 head 输出文件开始的部分 head -n count_of_line filename 查看文件的前n行 head -c number_of_byte filename 查看文件的前n个字节 tail 输出文件最后的部分 tail -n num file打印出文件最后num行 tail -n +num file 打印出文件从num开始的几行 tail -f file 保持阅读状态直到 Ctrl + c wc命令用于统计文件的单词，字节，行数 wc -l filename 统计文件的行数 wc -w filename 统计文件的字数 wc -c filename 统计文件的字节数 显示文件的状态 stat filename 显示文件的属性比如大小，权限等。 stat -x filename格式化显示文件的详细属性信息。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-01-29-基本Llinux命令(必须掌握) 2]]></title>
    <url>%2F2019%2F06%2F18%2F2019-01-29-%E5%9F%BA%E6%9C%ACLlinux%E5%91%BD%E4%BB%A4(%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1)%202%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “Linux常用命令整理”subtitle: “linux中必须掌握的基本命令”date: 2019-01-29 12:00:00author: “NanYin”header-img: “img/Linux/linux_bg.jpg”tags: - Linux linux中必须掌握的基本命令在开始前，我推荐安装 trdr（too long dont read）工具，用来简化man命令，来实现查看命令含义和用法的作用。 一 、系统工作命令 echo echo命令一般用于shell中打印变量或者字符串的作用，主要用来显示和提醒。 输出一段信息 如：echo &quot;hello world&quot; 其中&quot;不是必须的 输出一段带环境变量的信息 如：echo &quot;My Path is $PATH&quot; 输出并不带换行符号 如：echo -n &quot;Hello World&quot; 输出一段激活转依字符 如： echo -e &quot;Column 1 \t Column 2&quot; date date 命令主要用来设置和打印系统时间。 输出默认时区格式的事件 date +&quot;%c&quot; 输出当前事件按照UTC和iso格式输出 date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; 输出事件戳 date +&quot;%s&quot; reboot 命令主要用来重启系统 重启系统 reboot 强制重启 reboot -f poweroff 命令用户关机 wget 命令 用于从web中下载文件，支持 http,https,ftp 获取URL中的内容到foo中 wget https://example.com/foo 获取URL中的内容到bar中 wget -O bar https://example.com/foo 继续未完成的下载 wget -c https://example.com 后台下载 wget -q https://example.com ps命令主要用于查看正在运行的进程的信息 打印全部正在执行的进程 ps aux 打印全部正在执行的进程并且伴有完整的命令串 ps auxww 通过 grep 管道过滤 ps aux | grep &quot;tomcat&quot; 得到进程的父进程pid :ps -o ppid= -p pid top命令 主要用户动态的实时的显示正在运行的程序 top -i 不显示空闲或者是僵尸进程 top -u $user 显示指定用户的进程 top -p PID 只显示指定进程PID top -p $(pgrep -d &#39;,&#39; process_name) 通过进程名来查询 pidof 命令主要用于查找指定进程的id号 pidof -s 进返回一个进程号 pidof -c 仅显示具有相同root目录下的进程 二、系统状态 ifconfig 命令主要用于网络接口的查看和配置 Ifconfig eth0 查看etho0接口网络设置 ifconfig -a 查看所有接口的详细信息 ifconfig eth0 down 关闭接口eth0 ifconfig eth0 ipaddr 设置端口ip地址 uname 打印出现当前机器和系统的相关信息 uname -n 打印当前的hostname uname -a 打印当前可用的系统的信息，包括硬件软件。 who 打印哪些用户登录再这台机器上 who 显示username等比较全的信息 who am i 打印出当前用户 last 用于查看当前用户最近的登录信息 三、文件和目录 pwd 用于打印当前目录 cd 用于切换目录 ls 用于罗列目录下的文件或者文件夹 ls -l按行罗列文件或文件夹 ls -a 显示所有文件，包括隐藏的文件。 ls -lh 按照大小排泄排列 touch 命令主要用于改变文件的访问时间和修改时间。 touch filename 以当前时间创建文件 touch -t yyyy-mm-dd filename 以某一时间来改变文件时间 mkdir 命令主要用于创建文件 mkdir dir 创建文件夹 mkdir -p /path/dir 创建指定路径下的文件 cp 命令主要用于文件的复制 cp path/to/file.ext path/to/copy.ext 复制文件到另一个地址 cp path/to/file.ext path/to/target_parent_directory 复制文件到指定地址，并且保持文件名不变 cp -r path/to/directory path/to/copy 递归的复制整个文件夹及其中的内容到指定目录 cp -i *.txt path/to/target_directory 以交互的模式复制文件到指定文件夹中 mv 命令主要用于移动文件 mv source target 移动文件 mv -f 强制移动，覆盖现有文件时不要提示 rm命令主要用于删除文件 rm path/to/file path/to/another/file 删除特定文件夹中的文件 rm -r path/to/directory 递归删除文件夹及文件夹中的文件 rm -rf 递归删除，并且不要提示信息 dd 命令主要用于转化和复制文件,制作usb镜像 Clone a drive to another drive with 4MB block and ignore error dd if=/dev/source_drive of=/dev/dest_drive bs=4m conv=noerror file命令主要用于确定文件类型 file filename 输出文件类型 file -s filename 用于特殊的文件或者设备文件。 四、文本编辑命令 cat 打印和串联文件 cat file 打印文件内容到标准输出 cat file1 file2 &gt; targetFile 将多个文件内容串联到目标文件中 cat -n file 打印出行数到标准输出 more 用于互动的阅读文件内容，可以上下滚动 more file 打开文件，&lt;space&gt;用于移动到下一页，/用于搜索文件内容， q用于退出当前界面 head 输出文件开始的部分 head -n count_of_line filename 查看文件的前n行 head -c number_of_byte filename 查看文件的前n个字节 tail 输出文件最后的部分 tail -n num file打印出文件最后num行 tail -n +num file 打印出文件从num开始的几行 tail -f file 保持阅读状态直到 Ctrl + c wc命令用于统计文件的单词，字节，行数 wc -l filename 统计文件的行数 wc -w filename 统计文件的字数 wc -c filename 统计文件的字节数 显示文件的状态 stat filename 显示文件的属性比如大小，权限等。 stat -x filename格式化显示文件的详细属性信息。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-08-悲观锁和乐观锁]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-08-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[比较替换(compareAndSwap)是一个原子操作，也是一个自旋操作，等待一个周期再次尝试。 CAS操作的缺点 ABA问题，何谓ABA：当两个线程读取到当前值为A，其中一个线程把值改为B后再把B改为A，这是另外一个线程使用cas操作读取到的值仍然是A，CAS会认为这个值从来没有变过，这就是ABA问题。也就是说遗失掉中间的过程，在链式的操作总更能体会到ABA问题的严重性。 自旋时间过长，消耗CPU资源。 只能对单个共享变量的原子性操作]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-12-Java中常用关键字]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-12-Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-22-Synchronized关键字总结]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-22-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[实际上double-check也是懒汉模式的一种，能够保证线程安全。很完美。。 synchronzied底层实现synchronized 同步语句块的实现使用的是monitorenter 和monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 volatile和synachronized的区别 volatile是线程同步的轻量级实现，所以说使用volatile的性能肯定要强于synchronized。 volatile作用于变量，而synachronzied作用于方法和代码块。 多线程间使用volatile不会发生阻塞，而使用synachronized可能发生阻塞 volatile保证变量在多线程间的可见性，向虚拟机声明这个变量不稳定，需要每次都从主存中获取，而synchronized既能够保证可见性，又能保证原子性。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-23-线程池代码解析]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-23-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AQS「AbstractQueuedSynchronizer」 队列同步器AQS的使用方式是继承,之类通过继承AQS,实现抽象方法来实现管理同步器. 其中上文中的ThreadPoolExcutor中的Worker就是继承AQS来实现的. AQS使用一个全局变量state来表示当前的锁的状态,如果state&gt;0,说明已经获取到了锁,如果state=0,说明释放了锁. AQS依靠CLH队列完成对状态的管理.当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 其中CLH的一个节点包括了:当前的状态,前驱,后继,当前节点保存的线程. 具体的AQS过程可以参考QAS原理 补充的countDownLatch和cyclicBarrier的区别]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-24-JVM相关知识整理]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-24-JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “JVM基本知识整理”subtitle: “关于java的内存空间,对象的创建过程和对象的定位方式概念上的整理”date: 2019-04-24 12:00:00author: “NanYin”copyright: turetags: - JVM - Javacategories: - Java - JVM java内存空间 其中如图中所展示的，按功能分了大致分为两类，一类为线程共享的JAVA堆和元数据区和直接内存，另一类是线程私有的虚拟机栈，方法区栈和程序计数器。 下面针对这几种区域来详细将这几个区域分别的作用是什么。 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程执行程序的字节码的的行号的指示器。字节码解释器工作时通过改变程序计数器的值来改变将要选取的下一个指令。并且由于每个线程执行的运行的指令不同，每个线程有个字的程序计数器，并且互不干扰。所以程序计数器被称作是线程私有的。这种线程私有的区域有着很明显的特征就是生命周期和当前线程的周期保持一致。并且需要注意的是程序计数器是内存中唯一一个不会出现outOfMemory的区域。 程序计数器有两个作用： A: 字节码解释器通过读取程序计数器的值来选取下一条将要执行的语句。 B:在多线程切换的情况下，记录当前线程执行的位置，方便于切换回时进程运行的位置。 虚拟机栈Java内存可以粗糙的分为堆内存和栈内存，所谓的堆就是图中的java堆（Heap），而所谓的栈就是指的虚拟机栈（VM Stack）的局部变量表。虚拟机栈是由一个个栈针构成的，可以想为一个方法为一个栈针，随着方法的被调用完成（完成的条件有两个，一个是return，另外一个是发生异常），对应着方法的栈针出栈。栈针中都包含：局部变量表，操作数栈，动态链接和方法出口。局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置） 本地方法栈本地方法栈同样是线程私有的,区别是java虚拟机栈是用于java字节码的,而本地方法栈是用来执行Native方法的.结构都和虚拟机栈的结构相同. Java堆Java堆是整个虚拟机中最大的一块区域,是线程共享的区域,再虚拟机启动时创建,该块存在的唯一目的就是存放类的事例和数组. 方法区和Java堆一样都是线程共享的区域,主要用于存放已经被虚拟机加载的类信息,常量,静态变量和已经被编译后的代码等数据.方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。 运行时常量池原来的运行时常量池是方法区的一部分,而在1.7之后,讲运行时常量池放到堆(Heap)中开辟了一个区域专门用来放运行时常量池.运行时常量池中遥遥包括两部分,一部分是实际存在的字面量,所谓字面量包括[1.文本字符串,2.被声明为final的常量,基本数据类型…..],另一部分是符号引用,包含[类和结构的名称,字段的名称,方法的名称] 元数据区替代了永久代,使用的是直接内存,什么是直接内存,它有能够干什么? 首先直接内存区域不是虚拟机运行时数据区的一部分,也不是虚拟机定义的一部分,但是经常会使用到. JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 对象的创建过程 对象的创建过程分为上图中的5步 类加载检查:当虚拟机遇到new的时候,会检查这个类是否存在,是否被加载,解释和初始化过,如果没有则进行类的初始化过程. 分配内存:再进行类加载检查后,会在堆内存中为新的对象分配内存,分配的规则有两种,一种是指针碰撞,另一种是空闲列表,针对不同的垃圾回收器会使用不同的方法.第一种方法指针碰撞的原理大致为它会将分配过的内存和未分配的内存间建立一个指针,当分配内存的时候,向为分配内存的地方移动新的对象的大小的位置,适用于比较规整的内存空间.第二种方法是维护一个分配内存的列表,每次分配内存都想列表中添加相关记录,表明这些对象在哪. 初始化零值:保证在分配完内存后,为分配的内存区域初始化为零值 设置对象头:虚拟机对对象的各种设置信息,保存在对象头中. 执行init方法:在执行init方法前,从虚拟机的角度来看其实对象已经生成了,但是在程序员的角度对象并没有生成,只有在init方法执行过后,对象才算生成. 对象的定位方式Java虚拟机定位对象的方式主要有两种,一是使用句柄,二是直接使用指针.]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-28-Java_IO操作]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-28-Java_IO%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “Java中的各种IO操作”subtitle: “”date: 2019-04-28 12:00:00author: “NanYin”header-img: “img/Java相关/java.jpg”copyright: turetags: - Javacategories: - Java Java中的IO操作Java总的来说有三类IO,效率不高,操作简单的BIO(blocking IO),非阻塞的NIO(New IO),和异步非阻塞IO,也就是升级版的NIO(Asynchronous I/O). 在学习这三类IO前,需要了解什么是阻塞.什么是异步.两个的含义有什么区别. 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个调用时，在没有得到结果之前，该 调用 就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 BIOBIO过程就如同名字一样,是一个阻塞的IO,服务端通常为每一个客户端都建立一个独立的线程来通过调用accept()来监听客户端消息.如果想处理多个客户端请求则服务端需要建立等同数量的线程来处理这些消息,这就是普遍的一请求一应答的模型.处理完成后返回应答给客户端后销毁线程,因为线程是一个昂贵的资源,这样重复的新建线程,销毁线程,很浪费处理器资源,所以使用BIO同时能够尽可能的少创建线程,就可以用到线程池的方式实现,来达到服务端创建线程数远远小于客户端数的目的,但这种方法只是伪异步IO. 在处理链接数量少的情况下,BIO的效率还不错,并且主要逻辑模型清晰明了,代码简单.但是在上万的链接的情况下,BIO处理起来就非常吃紧了. NIONIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。 NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。 NIO特性和NIO与传统IO的区别 传统IO(BIO)是一种阻塞IO模型,而NIO是非阻塞的IO模型,区别为当线程读取数据的时候,非阻塞IO可以不用等,而阻塞IO需要一直等待IO完成后才能继续. IO面向流,而NIO面向缓冲区. 通道(channel) NIO通过通道进行数据读写.通道是双向的,而传统的IO是单向的.通道链接的都是Buffer,所以通道可以异步的读写. 选择器(Selectors) NIO拥有选择器,而IO没有.选择器的作用就是用来使用单个线程来处理多个通道(NIO面向buffer,通道只与buffer交互).AIO AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-29-Hibernate重点总结]]></title>
    <url>%2F2019%2F06%2F18%2F2019-04-29-Hibernate%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “Hibernate重点知识总结”subtitle: “”date: 2019-04-29 12:00:00author: “NanYin”header-img: “img/Java相关/java.jpg”copyright: turetags: - Javacategories: - Hibernate Hibernate重点知识总结Hibernate的三种状态 瞬时态(transient):当实体还未和session关联,如new Person(“1”); 持久态(persistent): 通过get或者load得到的实体类,这时的状态都是持久态. 游离态(detached): 当通过get或者load得到持久态的对象后,执行删除delete时,这时已经脱离session.因delete而变为游离态可有save或者saveOrUpate转化为持久态.或则当session关闭后,session中的对象就变为游离态. hibernate中update和saveOrUpdate的区别update只能是对象有主键时起作用,而saveOrUpdate则在对象没有主键时执行插入操作.对应的update操作只能操作游离态的对象,而不能对瞬时态的对象操作.而saveOrUpdate则两种状态的对象都可以操作. hibernate中的update和merge方法的区别当执行update方法的时候,一个session中具有与当前update相同的持久化标识(identifier)的实例,使用upate操作后会报错,而使用merge后把处理自由态的po对象A的属性copy到session当中处于持久态的po的属性中，执行完成后原来是持久状态还是持久态，而我们提供的A还是自由态。 hibernate中get和load的区别一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方法，hibernate一定要获取到真实的数据，否则返回null。 hibernate中list和iterator的区别(1)、List方式是1次性把所有的数据全部取到内存中，构造一个超大的结果集，主要的时间开销是这一步，这一步的时间开销要远远超过JDBC和 Iterator方式下构造结果集的时间开销，并且内存开销也很惊人；而对结果集的遍历操作，速度则是非常的惊人（经过测试，30万记录的内 存遍历不到100ms，由于这一步不受JDBC影响，因此结果可信）。因此，List方式适合于对结果集进行反复多次操作的情况，例如分页显示，往后往前 遍历，跳到第一行，跳到最后一行等等。 (2)、Iterator方式只取记录id到内存中，并没有把所有数据取到内存中，因此构造结果集的时间开销很小，比JDBC和List方式都要少，并且内 存开销也小很多。而对结果集的遍历的操作的时候，Iterator仍然要访问数据库，所有主要的时间开销都花在这里。因此，Iterator方式适合于只 对结果集进行1次遍历操作的情况，并且Iterator方式特别适合于从超大结果集中取少量数据，这种情况Iterator性能非常好。 总结: list把数据一次加载到内存,再进行遍历操作就非常快了.而Iterator方式只会把id放到内存中,但是再次遍历时仍然要访问数据库查询数据,适合一次遍历的情况. hibernate中的inverse属性设置inverse=“false”为主控方,由主控方类维护对象间的关系.比如再many-to-one的关系中,再one的一方设置inverse=&quot;true&quot;这样能够提高效率,比如班级里一个老师多个学生,老师记住多个学生比较困难,而学生记住一个老师很容易.同理one-to-many.再多对多的关系中,再任意一方设置inverse=&#39;true&#39;即可. hibernate中的cascade属性级联操作：指当主控方执行某项操作时，是否要对被关联方也执行相同的操作。 什么情况下懒加载能够有效的提高效率懒加载是当用到对象的时候再从数据库加载数据,持久化来使用.从这句话中就可以理解为,因为及联的关系,一个表的数据可能会带出多张表的数据,这时候使用懒加载就能够实现效率的提高,没必要一次性把所有数据都加载出来,而是用时加载.hibernate默认是使用懒加载的,当然可以使用lazy=false来禁用懒加载. 什么是hibernate的二级缓存缓存就是将以前的数据存放到内存中,当查询数据的时候,现在内存中查询,是否有这个对象,如果没有再从数据库中查询对象,这样大大的提高了查询的效率. Hibenate的session就是一级缓存,当查询数据的时候都会先从session中查询对象是否存在,不存在才从数据库查询.但是session是非线程安全的,多线程共享的情况下会出现问题.并且session是表示的是一段会话,表示的是一次事务,基于以上两点,所以在一次事务完成后,session就应立即关闭.所以这里说的一级缓存意义不大. Hibernate的二级缓存其实就是使用外部缓存,如Echache或者redis等,使用配置文件配置缓存策略等. Hibernate中使用hibernateTemplate的好处有哪些? HibernateTemplate简化了与Hibernate Session的交互 常见的函数简化为单个方法调用。 异常会自动捕获并转换为运行时异常 session 自动关闭]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-05-05-Spring_Framework重点学习 2]]></title>
    <url>%2F2019%2F06%2F18%2F2019-05-05-Spring_Framework%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%202%2F</url>
    <content type="text"><![CDATA[上面只是简单的掩饰注解的用法,但实际上业务会比这难上许多. springMVC 工作流程先上一张图:来自https://www.cnblogs.com/xiaoxi/p/6164383.html 由图中可以看到SpringMvc中最重要的起到中枢的是DispatcherServlet(前端控制器). 在DispatcherServlet接受到客户端请求后,使用 handlerMapping 进行映射处理.在生成处理器映射器之后, 返回一个handler,如果有拦截器的化还生成拦截器.交给 DispatcherServlet 进行下一步处理. 第二步交给 handlerAdatper (处理器适器) HandlerAdapter 经过适配调用具体的处理器( Controller ，也叫后端控制器)。Controller执行完成返回ModelAndView。 第三步,DispatcherServlet将最终的结果交给 viewResolver 试图解析器进行视图解析 DispatcherServlet 根据返回的view进行视图渲染,最终返回给客户端用户.]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-05-05-Spring_Framework重点学习]]></title>
    <url>%2F2019%2F06%2F18%2F2019-05-05-Spring_Framework%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[上面只是简单的掩饰注解的用法,但实际上业务会比这难上许多. springMVC 工作流程先上一张图:来自https://www.cnblogs.com/xiaoxi/p/6164383.html 由图中可以看到SpringMvc中最重要的起到中枢的是DispatcherServlet(前端控制器). 在DispatcherServlet接受到客户端请求后,使用 handlerMapping 进行映射处理.在生成处理器映射器之后, 返回一个handler,如果有拦截器的化还生成拦截器.交给 DispatcherServlet 进行下一步处理. 第二步交给 handlerAdatper (处理器适器) HandlerAdapter 经过适配调用具体的处理器( Controller ，也叫后端控制器)。Controller执行完成返回ModelAndView。 第三步,DispatcherServlet将最终的结果交给 viewResolver 试图解析器进行视图解析 DispatcherServlet 根据返回的view进行视图渲染,最终返回给客户端用户.]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-05-30-设计模式之单例模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-05-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-01-设计模式之建造者模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-02-设计模式之原型模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-02-设计模式之适配器模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-03-设计模式之桥接模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-03-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上面的例子中，颜色和图形是两个独立不同的维度，两个可以分别变化。将两个维度设计为两个不同的继承的结构，在两个结构之间使用在抽象类中的关联来达到链接的目的，这个链接成为两个继承结构通信的桥梁。所以为桥接模式。]]></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-03-设计模式之组合模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-03-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-10-设计模式之装饰者模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-10-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-12-设计模式之外观模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-13-设计模式之享元模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-13-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-17-设计模式之模版模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-17-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[其实模版方法模式是创建一个算法的骨架，具体的内容由子类去填充的这个过程。]]></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-15-设计模式之访问者模式]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-15-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-18-Mac下idea在Dock栏一直存在图标和控制台中文乱码问题]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-18-Mac%E4%B8%8Bidea%E5%9C%A8Dock%E6%A0%8F%E4%B8%80%E7%9B%B4%E5%AD%98%E5%9C%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>博客</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-05-bash_05_操作变量 2]]></title>
    <url>%2F2019%2F06%2F18%2F2018-05-05-bash_05_%E6%93%8D%E4%BD%9C%E5%8F%98%E9%87%8F%202%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “bash学习记录（五） bash中关于变量的更多的知识”subtitle: “关于bash的变量的拓展和应用”date: 2018-05-01 17:00:00author: “NanYin”header-img: “img/home-bg.jpg”tags: - bash - Linux 字符串操作bash支持很多关于字符串的操作，不过可惜的是，这些操作缺乏统一性，有一些是使用参数等，另外一些是通过内建命令expr命令来实现，这会导致不同的语法功能的重叠，会比较混乱，下面简单介绍一下使用参数和命令的实现字符串的操作。 字符串长度（String Length） $(#string) 这里是和C语言中的strlen()是相同的。 expr length $string 同样表示string串的长度。 1234567#! /bin/bashstring=abcdefgHIGKL#使用第一种方法$(#string)echo "string的长度是：$&#123;#string&#125;"#使用第二种方法使用expr内建命令 优点简单易懂echo "string的长度是：`expr length $string`"` 字符串从开头匹配子字串的长度 方法如下： 123stringZ=abcABC123ABCab echo `expr match "$stringZ" 'abc[A-Z]*.2'`echo `expr $stringZ : 'abc[A-Z]*.2'` 匹配到子串的位置 (index) 1echo `expr index $stringZ 'abc[A-Z]*.2'` 子字符串的截取 ${string:position} 从positon位置截取字符串string。 ${string:positong:length} 从positon位置截取字符串string，并且限定截取长度为length。 expr substr $string $positon $length 意思同上。 expr match $string ‘\(substring \)’ 这里的substring是正则表达式。 12345#截取字符串echo $&#123;stringZ:5&#125;echo $&#123;stringZ:5:4&#125;echo `expr substr $stringZ 5 4`echo `expr match $stringZ '\(abc[A-Z]*.2\)'` 从字符串中移除子字符串 ${string#substring} substring是子字符串。并且需要注意的是：该方法表示的是向后移除该子字符串最短匹配到的字符串。 ${string##substring} 与上面的正好相反。该方法表示的是向后移除该字符串最长匹配到的字符串。 ${string%substring} 该方法表示的是由后向前移除该子字符串最短匹配到的字符串。 ${string%%substring} 该方法表示的是由后向前移除该字符串最长匹配到的字符串。 12345678910echo "移除字符串"echo $&#123;stringZ#a*b&#125; echo $&#123;stringZ##a*b&#125;echo $&#123;stringZ%a*c&#125;echo $&#123;stringZ%%a*c&#125;#结果：#ABC123ABCabc#c#abcABC123ABC# 子字符串替换 ${string/substring/replacement} 替换第一个匹配到substring的字符串，替换为replacement。 ${string//substring/replacement} 替换所有匹配到的字符。 ${string/#substring/replacement} 替换由前向后匹配到的字符。 ${string/%substring/replacement} 替换由后向前匹配到的字符。 12345678910echo "---------字符串替换---------"echo $&#123;stringZ/abc/xyz&#125;echo $&#123;stringZ//abc/xyz&#125;echo $&#123;stringZ/#abc/xyz&#125;echo $&#123;stringZ/%abc/xyz&#125;#结果：#xyzABC123ABCabc#xyzABC123ABCxyz#xyzABC123ABCabc#abcABC123ABCxyz 使用awk操作字符串现学先卖，三十分钟学会AWK,快速了解和应用awk。 基于以上，使用awk练习。 工作流分为大致三部分， read-&gt;excute-&gt;repeat,实现对文本的处理。 程序机构 BEGIN 语法：BEGIN {awk-commands} 是可以省略的部分块，主要作用是声明变量，初始化变量， BODY块 ：{commonds}，是必须填写的部分，主要作用是处理文本，会对输入的每一行都执行body块中的命令，并且body是没有关键字的。 -END ：END {commands},同BEGIN，是可以省略的部分 基础语法 awk命令行，可以通过执行awk [-option] files来实现对files文件的处理。 如 awk {print} mark.txt 这里就不具体举例了，开头的链接里讲的非常详细，这里只做简单的记录和查看。 使用命令文件方式 awk -f command.awk marks.txt 使用-f参数，可以使用文件中的命令。 awk基本选项 ： 这里不具体总结，linux环境下终端 man awk可以看到非常多的选项。 基本使用示例 基本打印文件内容 123456$ awk '&#123;print&#125;' mark.txt 1) Amit Physics 802) Rahul Maths 903) Shyam Biology 874) Kedar English 855) Hari History 89 打印具体项内容 123456$ awk '&#123;print $1 "\t" $2 &#125;' mark.txt1) Amit2) Rahul3) Shyam4) Kedar5) Hari 添加限定条件的打印内容 12345$ awk '/a/ &#123;print $1 "\t" $2 &#125;' mark.txt2) Rahul3) Shyam4) Kedar5) Hari 结果只显示匹配到a的行 打印匹配到的行数 12$ awk 'BEGIN&#123;count=0&#125; /a/ &#123; count++&#125; END&#123;print count&#125;' mark.txt4 打印字符数量超过16的行 123$ awk 'length($0) &gt; 18' marks.txt3) Shyam Biology 874) Kedar English 85 NOTE:在这里的参数和bash中的参数类似。$0当前行，$1之后表示对应文件的行的列。 内建变量AWK提供了很多内建变量提供使用，能够起到很大的作用。 标准awk变量 ARGC 命令行参数个数 12$ awk 'BEGIN&#123;print "argument=",ARGC&#125;' one two threeargument= 4 ARGV 命令行参数数组 如 ARGV[1]=... CONVFMT 数字的约定格式，默认值是%.6g ENVIRON 环境变量 12$ awk 'BEGIN &#123;print "User is",ENVIRON["USER"]&#125;'User is nanyin FILENAME 当前文件的名称 12$ awk 'END&#123;print "this file name is", FILENAME&#125;' mark.txtthis file name is mark.txt FS 分割符 默认是空格也可以使用-F设置分割符 NF 当前行的字段数目 12$ awk 'END&#123;print NF&#125;' mark.txt4 NR 行号 FNR 当前文件的行号 OFS 输出字段分隔符 ORS 输出行分割符 RLENGTH 表示match函数匹配字符床的长度 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RLENGTH&#125;&#125;'3 RSTART 表示match函数第一次匹配到的位置 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RSTART&#125;&#125;' 8 操作符与C语言的操作符基本相同，如数字的一元二元三元操作等，字符串的链接，数组元素等 正则表达式AWK对正则的处理非常强大，通常你一个小小的正则表达式能够处理很复杂的问题。关于正则，有时间整理一篇专门关于正则的文章。 数组AWK支持关联数组，也就是说，不仅可以使用数字索引的数组，还可以使用字符串作为索引。删除数组元素使用delete语句 流程控制流程控制if while for 与C相同 函数查手册吧。。一次性看不完。。。。内建函数手册，这里有在这章比较重要的字符串函数。接下来就来看看有哪些函数比较重要。 AWK对字符串操作的函数 整理出awk对字符串的几个具体函数操作。 asort(source,dest,how) asorti(source,dest,how) 以上两个函数的how先不解释，前两个参数分别为source数组和排序方式，第二个可以不写，默认使用第一位的进行排位。 1234awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asort(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' xiaohong aiaolan` asorti()函数会将顺序替换到数组的value处如： 123awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asorti(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' 1 0 gensub(regexp,replacement,how[,target]) 类似gsub和sub 替换匹配到的正则regexp为replacement.如果how是g或者G(global的简写),则表示替换所有使用regexp匹配到的字符串,target是目标字符串 如果使用regexp未匹配到，则返回原始target的值 1234567891011# 第一个echo a b c a d | gawk '&#123;print gensub(/a/,"AA",2)&#125;' a b c AA d# 第二个awk 'BEGIN&#123;a="abc def"b = gensub(/(.+) (.+)/,"\\2 \\1","g",a)print b&#125;'def abc gsub(regexp,replacement[,target]) gsub中的‘g’其实是表示的是global,寻找目标的匹配到从左最长的，不重叠的,找到并且替换掉。 1&#123; gsub(/Britain/, "United Kingdom"); print &#125; 返回的值为匹配到的次数 index(in,find) 寻找in串内符合find匹配到的字符的index位置 123$ awk 'BEGIN&#123;quote&gt; print index("hello","lo")&#125;'4 length([string]) 顾名思义，不解释了 12$ awk 'BEGIN&#123;print length("hello")&#125;'5 NOTE: If no argument is supplied, length() returns the length of $0. match(string,regexp,[,array]) 使用正则匹配字符串，返回匹配到的位置，若未匹配到返回0 split(string,array[,fieldsep[,seps]]) 分割string字符串，使用array存放分割后产生的字符组，使用fieldsep组为分割符，seps存放每次分割产生的分割符。一个分割出来的存放到array[1]中，第二个存放到array[2]中，以此类推。如果分割符fieldsep不写，则默认分割符为空格。 12345$ awk 'BEGIN&#123;print split("cul-de-sac",a,"-",seps);for(i=1;i&lt;4;i++)&#123;print a[i]&#125;&#125;' 3culdesac sprintf(format,expression1,..) 是printf的功能，并且能够返回字符串 strtonum (str) 类似java的parseInt()函数，由String字符串转成数字 sub（regexp,replacement[,target]） 最左最长匹配原则进行匹配，sub个gsub的作用相同，分割字符串，并进行替换 substr(string,start[,end]) 分割字符串 tolower(string) &amp; toupper(string) 大小写转换 关于awk的就总结到这了。。十分基础的总结。。推荐文档，清晰明了。下一篇打算先整理整理正则表达式。现在哪里都会用到正则，还是很有必要看看正则的。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-05-bash_05_操作变量]]></title>
    <url>%2F2019%2F06%2F18%2F2018-05-05-bash_05_%E6%93%8D%E4%BD%9C%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[layout: posttitle: “bash学习记录（五） bash中关于变量的更多的知识”subtitle: “关于bash的变量的拓展和应用”date: 2018-05-01 17:00:00author: “NanYin”header-img: “img/home-bg.jpg”tags: - bash - Linuxcategories: - Bashcopyright: true 字符串操作bash支持很多关于字符串的操作，不过可惜的是，这些操作缺乏统一性，有一些是使用参数等，另外一些是通过内建命令expr命令来实现，这会导致不同的语法功能的重叠，会比较混乱，下面简单介绍一下使用参数和命令的实现字符串的操作。 字符串长度（String Length） $(#string) 这里是和C语言中的strlen()是相同的。 expr length $string 同样表示string串的长度。 1234567#! /bin/bashstring=abcdefgHIGKL#使用第一种方法$(#string)echo "string的长度是：$&#123;#string&#125;"#使用第二种方法使用expr内建命令 优点简单易懂echo "string的长度是：`expr length $string`"` 字符串从开头匹配子字串的长度 方法如下： 123stringZ=abcABC123ABCab echo `expr match "$stringZ" 'abc[A-Z]*.2'`echo `expr $stringZ : 'abc[A-Z]*.2'` 匹配到子串的位置 (index) 1echo `expr index $stringZ 'abc[A-Z]*.2'` 子字符串的截取 ${string:position} 从positon位置截取字符串string。 ${string:positong:length} 从positon位置截取字符串string，并且限定截取长度为length。 expr substr $string $positon $length 意思同上。 expr match $string ‘\(substring \)’ 这里的substring是正则表达式。 12345#截取字符串echo $&#123;stringZ:5&#125;echo $&#123;stringZ:5:4&#125;echo `expr substr $stringZ 5 4`echo `expr match $stringZ '\(abc[A-Z]*.2\)'` 从字符串中移除子字符串 ${string#substring} substring是子字符串。并且需要注意的是：该方法表示的是向后移除该子字符串最短匹配到的字符串。 ${string##substring} 与上面的正好相反。该方法表示的是向后移除该字符串最长匹配到的字符串。 ${string%substring} 该方法表示的是由后向前移除该子字符串最短匹配到的字符串。 ${string%%substring} 该方法表示的是由后向前移除该字符串最长匹配到的字符串。 12345678910echo "移除字符串"echo $&#123;stringZ#a*b&#125; echo $&#123;stringZ##a*b&#125;echo $&#123;stringZ%a*c&#125;echo $&#123;stringZ%%a*c&#125;#结果：#ABC123ABCabc#c#abcABC123ABC# 子字符串替换 ${string/substring/replacement} 替换第一个匹配到substring的字符串，替换为replacement。 ${string//substring/replacement} 替换所有匹配到的字符。 ${string/#substring/replacement} 替换由前向后匹配到的字符。 ${string/%substring/replacement} 替换由后向前匹配到的字符。 12345678910echo "---------字符串替换---------"echo $&#123;stringZ/abc/xyz&#125;echo $&#123;stringZ//abc/xyz&#125;echo $&#123;stringZ/#abc/xyz&#125;echo $&#123;stringZ/%abc/xyz&#125;#结果：#xyzABC123ABCabc#xyzABC123ABCxyz#xyzABC123ABCabc#abcABC123ABCxyz 使用awk操作字符串现学先卖，三十分钟学会AWK,快速了解和应用awk。 基于以上，使用awk练习。 工作流分为大致三部分， read-&gt;excute-&gt;repeat,实现对文本的处理。 程序机构 BEGIN 语法：BEGIN {awk-commands} 是可以省略的部分块，主要作用是声明变量，初始化变量， BODY块 ：{commonds}，是必须填写的部分，主要作用是处理文本，会对输入的每一行都执行body块中的命令，并且body是没有关键字的。 -END ：END {commands},同BEGIN，是可以省略的部分 基础语法 awk命令行，可以通过执行awk [-option] files来实现对files文件的处理。 如 awk {print} mark.txt 这里就不具体举例了，开头的链接里讲的非常详细，这里只做简单的记录和查看。 使用命令文件方式 awk -f command.awk marks.txt 使用-f参数，可以使用文件中的命令。 awk基本选项 ： 这里不具体总结，linux环境下终端 man awk可以看到非常多的选项。 基本使用示例 基本打印文件内容 123456$ awk '&#123;print&#125;' mark.txt 1) Amit Physics 802) Rahul Maths 903) Shyam Biology 874) Kedar English 855) Hari History 89 打印具体项内容 123456$ awk '&#123;print $1 "\t" $2 &#125;' mark.txt1) Amit2) Rahul3) Shyam4) Kedar5) Hari 添加限定条件的打印内容 12345$ awk '/a/ &#123;print $1 "\t" $2 &#125;' mark.txt2) Rahul3) Shyam4) Kedar5) Hari 结果只显示匹配到a的行 打印匹配到的行数 12$ awk 'BEGIN&#123;count=0&#125; /a/ &#123; count++&#125; END&#123;print count&#125;' mark.txt4 打印字符数量超过16的行 123$ awk 'length($0) &gt; 18' marks.txt3) Shyam Biology 874) Kedar English 85 NOTE:在这里的参数和bash中的参数类似。$0当前行，$1之后表示对应文件的行的列。 内建变量AWK提供了很多内建变量提供使用，能够起到很大的作用。 标准awk变量 ARGC 命令行参数个数 12$ awk 'BEGIN&#123;print "argument=",ARGC&#125;' one two threeargument= 4 ARGV 命令行参数数组 如 ARGV[1]=... CONVFMT 数字的约定格式，默认值是%.6g ENVIRON 环境变量 12$ awk 'BEGIN &#123;print "User is",ENVIRON["USER"]&#125;'User is nanyin FILENAME 当前文件的名称 12$ awk 'END&#123;print "this file name is", FILENAME&#125;' mark.txtthis file name is mark.txt FS 分割符 默认是空格也可以使用-F设置分割符 NF 当前行的字段数目 12$ awk 'END&#123;print NF&#125;' mark.txt4 NR 行号 FNR 当前文件的行号 OFS 输出字段分隔符 ORS 输出行分割符 RLENGTH 表示match函数匹配字符床的长度 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RLENGTH&#125;&#125;'3 RSTART 表示match函数第一次匹配到的位置 12$ awk 'BEGIN &#123;if(match("One Three","ree")) &#123;print RSTART&#125;&#125;' 8 操作符与C语言的操作符基本相同，如数字的一元二元三元操作等，字符串的链接，数组元素等 正则表达式AWK对正则的处理非常强大，通常你一个小小的正则表达式能够处理很复杂的问题。关于正则，有时间整理一篇专门关于正则的文章。 数组AWK支持关联数组，也就是说，不仅可以使用数字索引的数组，还可以使用字符串作为索引。删除数组元素使用delete语句 流程控制流程控制if while for 与C相同 函数查手册吧。。一次性看不完。。。。内建函数手册，这里有在这章比较重要的字符串函数。接下来就来看看有哪些函数比较重要。 AWK对字符串操作的函数 整理出awk对字符串的几个具体函数操作。 asort(source,dest,how) asorti(source,dest,how) 以上两个函数的how先不解释，前两个参数分别为source数组和排序方式，第二个可以不写，默认使用第一位的进行排位。 1234awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asort(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' xiaohong aiaolan` asorti()函数会将顺序替换到数组的value处如： 123awk 'BEGIN&#123;a[0]="xiaohong";a[1]="aiaolan";asorti(a);for(i=2;i&gt;=0;i--) &#123;print a[i]&#125;&#125;' 1 0 gensub(regexp,replacement,how[,target]) 类似gsub和sub 替换匹配到的正则regexp为replacement.如果how是g或者G(global的简写),则表示替换所有使用regexp匹配到的字符串,target是目标字符串 如果使用regexp未匹配到，则返回原始target的值 1234567891011# 第一个echo a b c a d | gawk '&#123;print gensub(/a/,"AA",2)&#125;' a b c AA d# 第二个awk 'BEGIN&#123;a="abc def"b = gensub(/(.+) (.+)/,"\\2 \\1","g",a)print b&#125;'def abc gsub(regexp,replacement[,target]) gsub中的‘g’其实是表示的是global,寻找目标的匹配到从左最长的，不重叠的,找到并且替换掉。 1&#123; gsub(/Britain/, "United Kingdom"); print &#125; 返回的值为匹配到的次数 index(in,find) 寻找in串内符合find匹配到的字符的index位置 123$ awk 'BEGIN&#123;quote&gt; print index("hello","lo")&#125;'4 length([string]) 顾名思义，不解释了 12$ awk 'BEGIN&#123;print length("hello")&#125;'5 NOTE: If no argument is supplied, length() returns the length of $0. match(string,regexp,[,array]) 使用正则匹配字符串，返回匹配到的位置，若未匹配到返回0 split(string,array[,fieldsep[,seps]]) 分割string字符串，使用array存放分割后产生的字符组，使用fieldsep组为分割符，seps存放每次分割产生的分割符。一个分割出来的存放到array[1]中，第二个存放到array[2]中，以此类推。如果分割符fieldsep不写，则默认分割符为空格。 12345$ awk 'BEGIN&#123;print split("cul-de-sac",a,"-",seps);for(i=1;i&lt;4;i++)&#123;print a[i]&#125;&#125;' 3culdesac sprintf(format,expression1,..) 是printf的功能，并且能够返回字符串 strtonum (str) 类似java的parseInt()函数，由String字符串转成数字 sub（regexp,replacement[,target]） 最左最长匹配原则进行匹配，sub个gsub的作用相同，分割字符串，并进行替换 substr(string,start[,end]) 分割字符串 tolower(string) &amp; toupper(string) 大小写转换 关于awk的就总结到这了。。十分基础的总结。。推荐文档，清晰明了。下一篇打算先整理整理正则表达式。现在哪里都会用到正则，还是很有必要看看正则的。]]></content>
      <categories>
        <category>博客</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
</search>
